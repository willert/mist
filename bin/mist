#!/usr/bin/perl
# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"5.10/Devel/InnerPackage.pm"} = <<'5.10_DEVEL_INNERPACKAGE';
  package Devel::InnerPackage;
  
  use strict;
  use base qw(Exporter);
  use vars qw($VERSION @EXPORT_OK);
  
  $VERSION = '0.3';
  @EXPORT_OK = qw(list_packages);
  
  =pod
  
  =head1 NAME
  
  
  Devel::InnerPackage - find all the inner packages of a package
  
  =head1 SYNOPSIS
  
      use Foo::Bar;
      use Devel::InnerPackage qw(list_packages);
  
      my @inner_packages = list_packages('Foo::Bar');
  
  
  =head1 DESCRIPTION
  
  
  Given a file like this
  
  
      package Foo::Bar;
  
      sub foo {}
  
  
      package Foo::Bar::Quux;
  
      sub quux {}
  
      package Foo::Bar::Quirka;
  
      sub quirka {}
  
      1;
  
  then
  
      list_packages('Foo::Bar');
  
  will return
  
      Foo::Bar::Quux
      Foo::Bar::Quirka
  
  =head1 METHODS
  
  =head2 list_packages <package name>
  
  Return a list of all inner packages of that package.
  
  =cut
  
  sub list_packages {
              my $pack = shift; $pack .= "::" unless $pack =~ m!::$!;
  
              no strict 'refs';
              my @packs;
              my @stuff = grep !/^(main|)::$/, keys %{$pack};
              for my $cand (grep /::$/, @stuff)
              {
                  $cand =~ s!::$!!;
                  my @children = list_packages($pack.$cand);
      
                  push @packs, "$pack$cand" unless $cand =~ /^::/ ||
                      !__PACKAGE__->_loaded($pack.$cand); # or @children;
                  push @packs, @children;
              }
              return grep {$_ !~ /::(::ISA::CACHE|SUPER)/} @packs;
  }
  
  ### XXX this is an inlining of the Class-Inspector->loaded()
  ### method, but inlined to remove the dependency.
  sub _loaded {
         my ($class, $name) = @_;
  
      no strict 'refs';
  
         # Handle by far the two most common cases
         # This is very fast and handles 99% of cases.
         return 1 if defined ${"${name}::VERSION"};
         return 1 if defined @{"${name}::ISA"};
  
         # Are there any symbol table entries other than other namespaces
         foreach ( keys %{"${name}::"} ) {
                 next if substr($_, -2, 2) eq '::';
                 return 1 if defined &{"${name}::$_"};
         }
  
         # No functions, and it doesn't have a version, and isn't anything.
         # As an absolute last resort, check for an entry in %INC
         my $filename = join( '/', split /(?:'|::)/, $name ) . '.pm';
         return 1 if defined $INC{$filename};
  
         '';
  }
  
  
  =head1 AUTHOR
  
  Simon Wistow <simon@thegestalt.org>
  
  =head1 COPYING
  
  Copyright, 2005 Simon Wistow
  
  Distributed under the same terms as Perl itself.
  
  =head1 BUGS
  
  None known.
  
  =cut 
  
  
  
  
  
  1;
5.10_DEVEL_INNERPACKAGE

$fatpacked{"5.10/List/Util.pm"} = <<'5.10_LIST_UTIL';
  # List::Util.pm
  #
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # This module is normally only loaded if the XS module is not available
  
  package List::Util;
  
  use strict;
  use vars qw(@ISA @EXPORT_OK $VERSION $XS_VERSION $TESTING_PERL_ONLY);
  require Exporter;
  
  @ISA        = qw(Exporter);
  @EXPORT_OK  = qw(first min max minstr maxstr reduce sum shuffle);
  $VERSION    = "1.23";
  $XS_VERSION = $VERSION;
  $VERSION    = eval $VERSION;
  
  eval {
    # PERL_DL_NONLAZY must be false, or any errors in loading will just
    # cause the perl code to be tested
    local $ENV{PERL_DL_NONLAZY} = 0 if $ENV{PERL_DL_NONLAZY};
    eval {
      require XSLoader;
      XSLoader::load('List::Util', $XS_VERSION);
      1;
    } or do {
      require DynaLoader;
      local @ISA = qw(DynaLoader);
      bootstrap List::Util $XS_VERSION;
    };
  } unless $TESTING_PERL_ONLY;
  
  
  if (!defined &sum) {
    require List::Util::PP;
    List::Util::PP->import;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  List::Util - A selection of general-utility list subroutines
  
  =head1 SYNOPSIS
  
      use List::Util qw(first max maxstr min minstr reduce shuffle sum);
  
  =head1 DESCRIPTION
  
  C<List::Util> contains a selection of subroutines that people have
  expressed would be nice to have in the perl core, but the usage would
  not really be high enough to warrant the use of a keyword, and the size
  so small such that being individual extensions would be wasteful.
  
  By default C<List::Util> does not export any subroutines. The
  subroutines defined are
  
  =over 4
  
  =item first BLOCK LIST
  
  Similar to C<grep> in that it evaluates BLOCK setting C<$_> to each element
  of LIST in turn. C<first> returns the first element where the result from
  BLOCK is a true value. If BLOCK never returns true or LIST was empty then
  C<undef> is returned.
  
      $foo = first { defined($_) } @list    # first defined value in @list
      $foo = first { $_ > $value } @list    # first value in @list which
                                            # is greater than $value
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { defined($a) ? $a : wanted($b) ? $b : undef } undef, @list
  
  for example wanted() could be defined() which would return the first
  defined value in @list
  
  =item max LIST
  
  Returns the entry in the list with the highest numerical value. If the
  list is empty then C<undef> is returned.
  
      $foo = max 1..10                # 10
      $foo = max 3,9,12               # 12
      $foo = max @bar, @baz           # whatever
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { $a > $b ? $a : $b } 1..10
  
  =item maxstr LIST
  
  Similar to C<max>, but treats all the entries in the list as strings
  and returns the highest string as defined by the C<gt> operator.
  If the list is empty then C<undef> is returned.
  
      $foo = maxstr 'A'..'Z'          # 'Z'
      $foo = maxstr "hello","world"   # "world"
      $foo = maxstr @bar, @baz        # whatever
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { $a gt $b ? $a : $b } 'A'..'Z'
  
  =item min LIST
  
  Similar to C<max> but returns the entry in the list with the lowest
  numerical value. If the list is empty then C<undef> is returned.
  
      $foo = min 1..10                # 1
      $foo = min 3,9,12               # 3
      $foo = min @bar, @baz           # whatever
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { $a < $b ? $a : $b } 1..10
  
  =item minstr LIST
  
  Similar to C<min>, but treats all the entries in the list as strings
  and returns the lowest string as defined by the C<lt> operator.
  If the list is empty then C<undef> is returned.
  
      $foo = minstr 'A'..'Z'          # 'A'
      $foo = minstr "hello","world"   # "hello"
      $foo = minstr @bar, @baz        # whatever
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { $a lt $b ? $a : $b } 'A'..'Z'
  
  =item reduce BLOCK LIST
  
  Reduces LIST by calling BLOCK, in a scalar context, multiple times,
  setting C<$a> and C<$b> each time. The first call will be with C<$a>
  and C<$b> set to the first two elements of the list, subsequent
  calls will be done by setting C<$a> to the result of the previous
  call and C<$b> to the next element in the list.
  
  Returns the result of the last call to BLOCK. If LIST is empty then
  C<undef> is returned. If LIST only contains one element then that
  element is returned and BLOCK is not executed.
  
      $foo = reduce { $a < $b ? $a : $b } 1..10       # min
      $foo = reduce { $a lt $b ? $a : $b } 'aa'..'zz' # minstr
      $foo = reduce { $a + $b } 1 .. 10               # sum
      $foo = reduce { $a . $b } @bar                  # concat
  
  If your algorithm requires that C<reduce> produce an identity value, then
  make sure that you always pass that identity value as the first argument to prevent
  C<undef> being returned
  
    $foo = reduce { $a + $b } 0, @values;             # sum with 0 identity value
  
  =item shuffle LIST
  
  Returns the elements of LIST in a random order
  
      @cards = shuffle 0..51      # 0..51 in a random order
  
  =item sum LIST
  
  Returns the sum of all the elements in LIST. If LIST is empty then
  C<undef> is returned.
  
      $foo = sum 1..10                # 55
      $foo = sum 3,9,12               # 24
      $foo = sum @bar, @baz           # whatever
  
  This function could be implemented using C<reduce> like this
  
      $foo = reduce { $a + $b } 1..10
  
  If your algorithm requires that C<sum> produce an identity of 0, then
  make sure that you always pass C<0> as the first argument to prevent
  C<undef> being returned
  
    $foo = sum 0, @values;
  
  =back
  
  =head1 KNOWN BUGS
  
  With perl versions prior to 5.005 there are some cases where reduce
  will return an incorrect result. This will show up as test 7 of
  reduce.t failing.
  
  =head1 SUGGESTED ADDITIONS
  
  The following are additions that have been requested, but I have been reluctant
  to add due to them being very simple to implement in perl
  
    # One argument is true
  
    sub any { $_ && return 1 for @_; 0 }
  
    # All arguments are true
  
    sub all { $_ || return 0 for @_; 1 }
  
    # All arguments are false
  
    sub none { $_ && return 0 for @_; 1 }
  
    # One argument is false
  
    sub notall { $_ || return 1 for @_; 0 }
  
    # How many elements are true
  
    sub true { scalar grep { $_ } @_ }
  
    # How many elements are false
  
    sub false { scalar grep { !$_ } @_ }
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
5.10_LIST_UTIL

$fatpacked{"5.10/List/Util/PP.pm"} = <<'5.10_LIST_UTIL_PP';
  # List::Util::PP.pm
  #
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package List::Util::PP;
  
  use strict;
  use warnings;
  use vars qw(@ISA @EXPORT $VERSION $a $b);
  require Exporter;
  
  @ISA     = qw(Exporter);
  @EXPORT  = qw(first min max minstr maxstr reduce sum shuffle);
  $VERSION = "1.23";
  $VERSION = eval $VERSION;
  
  sub reduce (&@) {
    my $code = shift;
    require Scalar::Util;
    my $type = Scalar::Util::reftype($code);
    unless($type and $type eq 'CODE') {
      require Carp;
      Carp::croak("Not a subroutine reference");
    }
    no strict 'refs';
  
    return shift unless @_ > 1;
  
    use vars qw($a $b);
  
    my $caller = caller;
    local(*{$caller."::a"}) = \my $a;
    local(*{$caller."::b"}) = \my $b;
  
    $a = shift;
    foreach (@_) {
      $b = $_;
      $a = &{$code}();
    }
  
    $a;
  }
  
  sub first (&@) {
    my $code = shift;
    require Scalar::Util;
    my $type = Scalar::Util::reftype($code);
    unless($type and $type eq 'CODE') {
      require Carp;
      Carp::croak("Not a subroutine reference");
    }
  
    foreach (@_) {
      return $_ if &{$code}();
    }
  
    undef;
  }
  
  
  sub sum (@) { reduce { $a + $b } @_ }
  
  sub min (@) { reduce { $a < $b ? $a : $b } @_ }
  
  sub max (@) { reduce { $a > $b ? $a : $b } @_ }
  
  sub minstr (@) { reduce { $a lt $b ? $a : $b } @_ }
  
  sub maxstr (@) { reduce { $a gt $b ? $a : $b } @_ }
  
  sub shuffle (@) {
    my @a=\(@_);
    my $n;
    my $i=@_;
    map {
      $n = rand($i--);
      (${$a[$n]}, $a[$n] = $a[$i])[0];
    } @_;
  }
  
  1;
5.10_LIST_UTIL_PP

$fatpacked{"5.10/List/Util/XS.pm"} = <<'5.10_LIST_UTIL_XS';
  package List::Util::XS;
  use strict;
  use vars qw($VERSION);
  use List::Util;
  
  $VERSION = "1.23";           # FIXUP
  $VERSION = eval $VERSION;    # FIXUP
  
  sub _VERSION { # FIXUP
    require Carp;
    Carp::croak("You need to install Scalar-List-Utils with a C compiler to ensure the XS is compiled")
      if defined $_[1];
    $VERSION;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  List::Util::XS - Indicate if List::Util was compiled with a C compiler
  
  =head1 SYNOPSIS
  
      use List::Util::XS 1.20;
  
  =head1 DESCRIPTION
  
  C<List::Util::XS> can be used as a dependency to ensure List::Util was
  installed using a C compiler and that the XS version is installed.
  
  During installation C<$List::Util::XS::VERSION> will be set to
  C<undef> if the XS was not compiled.
  
  =head1 SEE ALSO
  
  L<Scalar::Util>, L<List::Util>, L<List::MoreUtils>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
5.10_LIST_UTIL_XS

$fatpacked{"5.10/Module/Pluggable.pm"} = <<'5.10_MODULE_PLUGGABLE';
  package Module::Pluggable;
  
  use strict;
  use vars qw($VERSION);
  use Module::Pluggable::Object;
  
  # ObQuote:
  # Bob Porter: Looks like you've been missing a lot of work lately. 
  # Peter Gibbons: I wouldn't say I've been missing it, Bob! 
  
  
  $VERSION = '3.9';
  
  sub import {
      my $class        = shift;
      my %opts         = @_;
  
      my ($pkg, $file) = caller; 
      # the default name for the method is 'plugins'
      my $sub          = $opts{'sub_name'}  || 'plugins';
      # get our package 
      my ($package)    = $opts{'package'} || $pkg;
      $opts{filename}  = $file;
      $opts{package}   = $package;
  
  
      my $finder       = Module::Pluggable::Object->new(%opts);
      my $subroutine   = sub { my $self = shift; return $finder->plugins(@_) };
  
      my $searchsub = sub {
                my $self = shift;
                my ($action,@paths) = @_;
  
                $finder->{'search_path'} = ["${package}::Plugin"] if ($action eq 'add'  and not   $finder->{'search_path'} );
                push @{$finder->{'search_path'}}, @paths      if ($action eq 'add');
                $finder->{'search_path'}       = \@paths      if ($action eq 'new');
                return $finder->{'search_path'};
      };
  
  
      my $onlysub = sub {
          my ($self, $only) = @_;
  
          if (defined $only) {
              $finder->{'only'} = $only;
          };
          
          return $finder->{'only'};
      };
  
      my $exceptsub = sub {
          my ($self, $except) = @_;
  
          if (defined $except) {
              $finder->{'except'} = $except;
          };
          
          return $finder->{'except'};
      };
  
  
      no strict 'refs';
      no warnings qw(redefine prototype);
      
      *{"$package\::$sub"}        = $subroutine;
      *{"$package\::search_path"} = $searchsub;
      *{"$package\::only"}        = $onlysub;
      *{"$package\::except"}      = $exceptsub;
  
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  Module::Pluggable - automatically give your module the ability to have plugins
  
  =head1 SYNOPSIS
  
  
  Simple use Module::Pluggable -
  
      package MyClass;
      use Module::Pluggable;
      
  
  and then later ...
  
      use MyClass;
      my $mc = MyClass->new();
      # returns the names of all plugins installed under MyClass::Plugin::*
      my @plugins = $mc->plugins(); 
  
  =head1 EXAMPLE
  
  Why would you want to do this? Say you have something that wants to pass an
  object to a number of different plugins in turn. For example you may 
  want to extract meta-data from every email you get sent and do something
  with it. Plugins make sense here because then you can keep adding new 
  meta data parsers and all the logic and docs for each one will be 
  self contained and new handlers are easy to add without changing the 
  core code. For that, you might do something like ...
  
      package Email::Examiner;
  
      use strict;
      use Email::Simple;
      use Module::Pluggable require => 1;
  
      sub handle_email {
          my $self  = shift;
          my $email = shift;
  
          foreach my $plugin ($self->plugins) {
              $plugin->examine($email);
          }
  
          return 1;
      }
  
  
  
  .. and all the plugins will get a chance in turn to look at it.
  
  This can be trivally extended so that plugins could save the email
  somewhere and then no other plugin should try and do that. 
  Simply have it so that the C<examine> method returns C<1> if 
  it has saved the email somewhere. You might also wnat to be paranoid
  and check to see if the plugin has an C<examine> method.
  
          foreach my $plugin ($self->plugins) {
              next unless $plugin->can('examine');
              last if     $plugin->examine($email);
          }
  
  
  And so on. The sky's the limit.
  
  
  =head1 DESCRIPTION
  
  Provides a simple but, hopefully, extensible way of having 'plugins' for 
  your module. Obviously this isn't going to be the be all and end all of
  solutions but it works for me.
  
  Essentially all it does is export a method into your namespace that 
  looks through a search path for .pm files and turn those into class names. 
  
  Optionally it instantiates those classes for you.
  
  =head1 ADVANCED USAGE
  
      
  Alternatively, if you don't want to use 'plugins' as the method ...
      
      package MyClass;
      use Module::Pluggable sub_name => 'foo';
  
  
  and then later ...
  
      my @plugins = $mc->foo();
  
  
  Or if you want to look in another namespace
  
      package MyClass;
      use Module::Pluggable search_path => ['Acme::MyClass::Plugin', 'MyClass::Extend'];
  
  or directory 
  
      use Module::Pluggable search_dirs => ['mylibs/Foo'];
  
  
  Or if you want to instantiate each plugin rather than just return the name
  
      package MyClass;
      use Module::Pluggable instantiate => 'new';
  
  and then
  
      # whatever is passed to 'plugins' will be passed 
      # to 'new' for each plugin 
      my @plugins = $mc->plugins(@options); 
  
  
  alternatively you can just require the module without instantiating it
  
      package MyClass;
      use Module::Pluggable require => 1;
  
  since requiring automatically searches inner packages, which may not be desirable, you can turn this off
  
  
      package MyClass;
      use Module::Pluggable require => 1, inner => 0;
  
  
  You can limit the plugins loaded using the except option, either as a string,
  array ref or regex
  
      package MyClass;
      use Module::Pluggable except => 'MyClass::Plugin::Foo';
  
  or
  
      package MyClass;
      use Module::Pluggable except => ['MyClass::Plugin::Foo', 'MyClass::Plugin::Bar'];
  
  or
  
      package MyClass;
      use Module::Pluggable except => qr/^MyClass::Plugin::(Foo|Bar)$/;
  
  
  and similarly for only which will only load plugins which match.
  
  Remember you can use the module more than once
  
      package MyClass;
      use Module::Pluggable search_path => 'MyClass::Filters' sub_name => 'filters';
      use Module::Pluggable search_path => 'MyClass::Plugins' sub_name => 'plugins';
  
  and then later ...
  
      my @filters = $self->filters;
      my @plugins = $self->plugins;
  
  =head1 INNER PACKAGES
  
  If you have, for example, a file B<lib/Something/Plugin/Foo.pm> that
  contains package definitions for both C<Something::Plugin::Foo> and 
  C<Something::Plugin::Bar> then as long as you either have either 
  the B<require> or B<instantiate> option set then we'll also find 
  C<Something::Plugin::Bar>. Nifty!
  
  =head1 OPTIONS
  
  You can pass a hash of options when importing this module.
  
  The options can be ...
  
  =head2 sub_name
  
  The name of the subroutine to create in your namespace. 
  
  By default this is 'plugins'
  
  =head2 search_path
  
  An array ref of namespaces to look in. 
  
  =head2 search_dirs 
  
  An array ref of directorys to look in before @INC.
  
  =head2 instantiate
  
  Call this method on the class. In general this will probably be 'new'
  but it can be whatever you want. Whatever arguments are passed to 'plugins' 
  will be passed to the method.
  
  The default is 'undef' i.e just return the class name.
  
  =head2 require
  
  Just require the class, don't instantiate (overrides 'instantiate');
  
  =head2 inner
  
  If set to 0 will B<not> search inner packages. 
  If set to 1 will override C<require>.
  
  =head2 only
  
  Takes a string, array ref or regex describing the names of the only plugins to 
  return. Whilst this may seem perverse ... well, it is. But it also 
  makes sense. Trust me.
  
  =head2 except
  
  Similar to C<only> it takes a description of plugins to exclude 
  from returning. This is slightly less perverse.
  
  =head2 package
  
  This is for use by extension modules which build on C<Module::Pluggable>:
  passing a C<package> option allows you to place the plugin method in a
  different package other than your own.
  
  =head2 file_regex
  
  By default C<Module::Pluggable> only looks for I<.pm> files.
  
  By supplying a new C<file_regex> then you can change this behaviour e.g
  
      file_regex => qr/\.plugin$/
  
  =head2 include_editor_junk
  
  By default C<Module::Pluggable> ignores files that look like they were
  left behind by editors. Currently this means files ending in F<~> (~),
  the extensions F<.swp> or F<.swo>, or files beginning with F<.#>.
  
  Setting C<include_editor_junk> changes C<Module::Pluggable> so it does
  not ignore any files it finds.
  
  
  =head1 METHODs
  
  =head2 search_path
  
  The method C<search_path> is exported into you namespace as well. 
  You can call that at any time to change or replace the 
  search_path.
  
      $self->search_path( add => "New::Path" ); # add
      $self->search_path( new => "New::Path" ); # replace
  
  
  
  =head1 FUTURE PLANS
  
  This does everything I need and I can't really think of any other 
  features I want to add. Famous last words of course
  
  Recently tried fixed to find inner packages and to make it 
  'just work' with PAR but there are still some issues.
  
  
  However suggestions (and patches) are welcome.
  
  =head1 AUTHOR
  
  Simon Wistow <simon@thegestalt.org>
  
  =head1 COPYING
  
  Copyright, 2006 Simon Wistow
  
  Distributed under the same terms as Perl itself.
  
  =head1 BUGS
  
  None known.
  
  =head1 SEE ALSO
  
  L<File::Spec>, L<File::Find>, L<File::Basename>, L<Class::Factory::Util>, L<Module::Pluggable::Ordered>
  
  =cut 
  
  
5.10_MODULE_PLUGGABLE

$fatpacked{"5.10/Module/Pluggable/Object.pm"} = <<'5.10_MODULE_PLUGGABLE_OBJECT';
  package Module::Pluggable::Object;
  
  use strict;
  use File::Find ();
  use File::Basename;
  use File::Spec::Functions qw(splitdir catdir curdir catfile abs2rel);
  use Carp qw(croak carp);
  use Devel::InnerPackage;
  use vars qw($VERSION);
  
  $VERSION = '3.9';
  
  
  sub new {
      my $class = shift;
      my %opts  = @_;
  
      return bless \%opts, $class;
  
  }
  
  ### Eugggh, this code smells 
  ### This is what happens when you keep adding patches
  ### *sigh*
  
  
  sub plugins {
          my $self = shift;
  
          # override 'require'
          $self->{'require'} = 1 if $self->{'inner'};
  
          my $filename   = $self->{'filename'};
          my $pkg        = $self->{'package'};
  
          # Get the exception params instantiated
          $self->_setup_exceptions;
  
          # automatically turn a scalar search path or namespace into a arrayref
          for (qw(search_path search_dirs)) {
              $self->{$_} = [ $self->{$_} ] if exists $self->{$_} && !ref($self->{$_});
          }
  
          # default search path is '<Module>::<Name>::Plugin'
          $self->{'search_path'} = ["${pkg}::Plugin"] unless $self->{'search_path'}; 
  
  
          #my %opts = %$self;
  
  
          # check to see if we're running under test
          my @SEARCHDIR = exists $INC{"blib.pm"} && defined $filename && $filename =~ m!(^|/)blib/! ? grep {/blib/} @INC : @INC;
  
          # add any search_dir params
          unshift @SEARCHDIR, @{$self->{'search_dirs'}} if defined $self->{'search_dirs'};
  
  
          my @plugins = $self->search_directories(@SEARCHDIR);
          push(@plugins, $self->handle_innerpackages($_)) for @{$self->{'search_path'}};
  
          # push @plugins, map { print STDERR "$_\n"; $_->require } list_packages($_) for (@{$self->{'search_path'}});
          
          # return blank unless we've found anything
          return () unless @plugins;
  
  
  
          # remove duplicates
          # probably not necessary but hey ho
          my %plugins;
          for(@plugins) {
              next unless $self->_is_legit($_);
              $plugins{$_} = 1;
          }
  
          # are we instantiating or requring?
          if (defined $self->{'instantiate'}) {
              my $method = $self->{'instantiate'};
              return map { ($_->can($method)) ? $_->$method(@_) : () } keys %plugins;
          } else { 
              # no? just return the names
              return keys %plugins;
          }
  
  
  }
  
  sub _setup_exceptions {
      my $self = shift;
  
      my %only;   
      my %except; 
      my $only;
      my $except;
  
      if (defined $self->{'only'}) {
          if (ref($self->{'only'}) eq 'ARRAY') {
              %only   = map { $_ => 1 } @{$self->{'only'}};
          } elsif (ref($self->{'only'}) eq 'Regexp') {
              $only = $self->{'only'}
          } elsif (ref($self->{'only'}) eq '') {
              $only{$self->{'only'}} = 1;
          }
      }
          
  
      if (defined $self->{'except'}) {
          if (ref($self->{'except'}) eq 'ARRAY') {
              %except   = map { $_ => 1 } @{$self->{'except'}};
          } elsif (ref($self->{'except'}) eq 'Regexp') {
              $except = $self->{'except'}
          } elsif (ref($self->{'except'}) eq '') {
              $except{$self->{'except'}} = 1;
          }
      }
      $self->{_exceptions}->{only_hash}   = \%only;
      $self->{_exceptions}->{only}        = $only;
      $self->{_exceptions}->{except_hash} = \%except;
      $self->{_exceptions}->{except}      = $except;
          
  }
  
  sub _is_legit {
      my $self   = shift;
      my $plugin = shift;
      my %only   = %{$self->{_exceptions}->{only_hash}||{}};
      my %except = %{$self->{_exceptions}->{except_hash}||{}};
      my $only   = $self->{_exceptions}->{only};
      my $except = $self->{_exceptions}->{except};
  
      return 0 if     (keys %only   && !$only{$plugin}     );
      return 0 unless (!defined $only || $plugin =~ m!$only!     );
  
      return 0 if     (keys %except &&  $except{$plugin}   );
      return 0 if     (defined $except &&  $plugin =~ m!$except! );
  
      return 1;
  }
  
  sub search_directories {
      my $self      = shift;
      my @SEARCHDIR = @_;
  
      my @plugins;
      # go through our @INC
      foreach my $dir (@SEARCHDIR) {
          push @plugins, $self->search_paths($dir);
      }
      return @plugins;
  }
  
  
  sub search_paths {
      my $self = shift;
      my $dir  = shift;
      my @plugins;
  
      my $file_regex = $self->{'file_regex'} || qr/\.pm$/;
  
  
      # and each directory in our search path
      foreach my $searchpath (@{$self->{'search_path'}}) {
          # create the search directory in a cross platform goodness way
          my $sp = catdir($dir, (split /::/, $searchpath));
  
          # if it doesn't exist or it's not a dir then skip it
          next unless ( -e $sp && -d _ ); # Use the cached stat the second time
  
          my @files = $self->find_files($sp);
  
          # foreach one we've found 
          foreach my $file (@files) {
              # untaint the file; accept .pm only
              next unless ($file) = ($file =~ /(.*$file_regex)$/); 
              # parse the file to get the name
              my ($name, $directory, $suffix) = fileparse($file, $file_regex);
  
              next if (!$self->{include_editor_junk} && $self->_is_editor_junk($name));
  
              $directory = abs2rel($directory, $sp);
  
              # If we have a mixed-case package name, assume case has been preserved
              # correctly.  Otherwise, root through the file to locate the case-preserved
              # version of the package name.
              my @pkg_dirs = ();
              if ( $name eq lc($name) || $name eq uc($name) ) {
                  my $pkg_file = catfile($sp, $directory, "$name$suffix");
                  open PKGFILE, "<$pkg_file" or die "search_paths: Can't open $pkg_file: $!";
                  my $in_pod = 0;
                  while ( my $line = <PKGFILE> ) {
                      $in_pod = 1 if $line =~ m/^=\w/;
                      $in_pod = 0 if $line =~ /^=cut/;
                      next if ($in_pod || $line =~ /^=cut/);  # skip pod text
                      next if $line =~ /^\s*#/;               # and comments
                      if ( $line =~ m/^\s*package\s+(.*::)?($name)\s*;/i ) {
                          @pkg_dirs = split /::/, $1;
                          $name = $2;
                          last;
                      }
                  }
                  close PKGFILE;
              }
  
              # then create the class name in a cross platform way
              $directory =~ s/^[a-z]://i if($^O =~ /MSWin32|dos/);       # remove volume
              my @dirs = ();
              if ($directory) {
                  ($directory) = ($directory =~ /(.*)/);
                  @dirs = grep(length($_), splitdir($directory)) 
                      unless $directory eq curdir();
                  for my $d (reverse @dirs) {
                      my $pkg_dir = pop @pkg_dirs; 
                      last unless defined $pkg_dir;
                      $d =~ s/\Q$pkg_dir\E/$pkg_dir/i;  # Correct case
                  }
              } else {
                  $directory = "";
              }
              my $plugin = join '::', $searchpath, @dirs, $name;
  
              next unless $plugin =~ m!(?:[a-z\d]+)[a-z\d]!i;
  
              my $err = $self->handle_finding_plugin($plugin);
              carp "Couldn't require $plugin : $err" if $err;
               
              push @plugins, $plugin;
          }
  
          # now add stuff that may have been in package
          # NOTE we should probably use all the stuff we've been given already
          # but then we can't unload it :(
          push @plugins, $self->handle_innerpackages($searchpath);
      } # foreach $searchpath
  
      return @plugins;
  }
  
  sub _is_editor_junk {
      my $self = shift;
      my $name = shift;
  
      # Emacs (and other Unix-y editors) leave temp files ending in a
      # tilde as a backup.
      return 1 if $name =~ /~$/;
      # Emacs makes these files while a buffer is edited but not yet
      # saved.
      return 1 if $name =~ /^\.#/;
      # Vim can leave these files behind if it crashes.
      return 1 if $name =~ /\.sw[po]$/;
  
      return 0;
  }
  
  sub handle_finding_plugin {
      my $self   = shift;
      my $plugin = shift;
  
      return unless (defined $self->{'instantiate'} || $self->{'require'}); 
      return unless $self->_is_legit($plugin);
      $self->_require($plugin);
  }
  
  sub find_files {
      my $self         = shift;
      my $search_path  = shift;
      my $file_regex   = $self->{'file_regex'} || qr/\.pm$/;
  
  
      # find all the .pm files in it
      # this isn't perfect and won't find multiple plugins per file
      #my $cwd = Cwd::getcwd;
      my @files = ();
      { # for the benefit of perl 5.6.1's Find, localize topic
          local $_;
          File::Find::find( { no_chdir => 1, 
                             wanted => sub { 
                               # Inlined from File::Find::Rule C< name => '*.pm' >
                               return unless $File::Find::name =~ /$file_regex/;
                               (my $path = $File::Find::name) =~ s#^\\./##;
                               push @files, $path;
                             }
                        }, $search_path );
      }
      #chdir $cwd;
      return @files;
  
  }
  
  sub handle_innerpackages {
      my $self = shift;
      return () if (exists $self->{inner} && !$self->{inner});
  
      my $path = shift;
      my @plugins;
  
      foreach my $plugin (Devel::InnerPackage::list_packages($path)) {
          my $err = $self->handle_finding_plugin($plugin);
          #next if $err;
          #next unless $INC{$plugin};
          push @plugins, $plugin;
      }
      return @plugins;
  
  }
  
  
  sub _require {
      my $self = shift;
      my $pack = shift;
      local $@;
      eval "CORE::require $pack";
      return $@;
  }
  
  
  1;
  
  =pod
  
  =head1 NAME
  
  Module::Pluggable::Object - automatically give your module the ability to have plugins
  
  =head1 SYNOPSIS
  
  
  Simple use Module::Pluggable -
  
      package MyClass;
      use Module::Pluggable::Object;
      
      my $finder = Module::Pluggable::Object->new(%opts);
      print "My plugins are: ".join(", ", $finder->plugins)."\n";
  
  =head1 DESCRIPTION
  
  Provides a simple but, hopefully, extensible way of having 'plugins' for 
  your module. Obviously this isn't going to be the be all and end all of
  solutions but it works for me.
  
  Essentially all it does is export a method into your namespace that 
  looks through a search path for .pm files and turn those into class names. 
  
  Optionally it instantiates those classes for you.
  
  This object is wrapped by C<Module::Pluggable>. If you want to do something
  odd or add non-general special features you're probably best to wrap this
  and produce your own subclass.
  
  =head1 OPTIONS
  
  See the C<Module::Pluggable> docs.
  
  =head1 AUTHOR
  
  Simon Wistow <simon@thegestalt.org>
  
  =head1 COPYING
  
  Copyright, 2006 Simon Wistow
  
  Distributed under the same terms as Perl itself.
  
  =head1 BUGS
  
  None known.
  
  =head1 SEE ALSO
  
  L<Module::Pluggable>
  
  =cut 
  
5.10_MODULE_PLUGGABLE_OBJECT

$fatpacked{"5.10/Safe.pm"} = <<'5.10_SAFE';
  package Safe;
  
  use 5.003_11;
  use strict;
  use Scalar::Util qw(reftype);
  
  $Safe::VERSION = "2.27";
  
  # *** Don't declare any lexicals above this point ***
  #
  # This function should return a closure which contains an eval that can't
  # see any lexicals in scope (apart from __ExPr__ which is unavoidable)
  
  sub lexless_anon_sub {
                   # $_[0] is package;
                   # $_[1] is strict flag;
      my $__ExPr__ = $_[2];   # must be a lexical to create the closure that
                              # can be used to pass the value into the safe
                              # world
  
      # Create anon sub ref in root of compartment.
      # Uses a closure (on $__ExPr__) to pass in the code to be executed.
      # (eval on one line to keep line numbers as expected by caller)
      eval sprintf
      'package %s; %s strict; sub { @_=(); eval q[my $__ExPr__;] . $__ExPr__; }',
                  $_[0], $_[1] ? 'use' : 'no';
  }
  
  use Carp;
  BEGIN { eval q{
      use Carp::Heavy;
  } }
  
  use B ();
  BEGIN {
      no strict 'refs';
      if (defined &B::sub_generation) {
          *sub_generation = \&B::sub_generation;
      }
      else {
          # fake sub generation changing for perls < 5.8.9
          my $sg; *sub_generation = sub { ++$sg };
      }
  }
  
  use Opcode 1.01, qw(
      opset opset_to_ops opmask_add
      empty_opset full_opset invert_opset verify_opset
      opdesc opcodes opmask define_optag opset_to_hex
  );
  
  *ops_to_opset = \&opset;   # Temporary alias for old Penguins
  
  # Regular expressions and other unicode-aware code may need to call
  # utf8->SWASHNEW (via perl's utf8.c).  That will fail unless we share the
  # SWASHNEW method.
  # Sadly we can't just add utf8::SWASHNEW to $default_share because perl's
  # utf8.c code does a fetchmethod on SWASHNEW to check if utf8.pm is loaded,
  # and sharing makes it look like the method exists.
  # The simplest and most robust fix is to ensure the utf8 module is loaded when
  # Safe is loaded. Then we can add utf8::SWASHNEW to $default_share.
  require utf8;
  # we must ensure that utf8_heavy.pl, where SWASHNEW is defined, is loaded
  # but without depending on knowledge of that implementation detail.
  # This code (//i on a unicode string) ensures utf8 is fully loaded
  # and also loads the ToFold SWASH.
  # (Swashes are cached internally by perl in PL_utf8_* variables
  # independent of being inside/outside of Safe. So once loaded they can be)
  do { my $a = pack('U',0xC4); my $b = chr 0xE4; utf8::upgrade $b; $a =~ /$b/i };
  # now we can safely include utf8::SWASHNEW in $default_share defined below.
  
  my $default_root  = 0;
  # share *_ and functions defined in universal.c
  # Don't share stuff like *UNIVERSAL:: otherwise code from the
  # compartment can 0wn functions in UNIVERSAL
  my $default_share = [qw[
      *_
      &PerlIO::get_layers
      &UNIVERSAL::isa
      &UNIVERSAL::can
      &UNIVERSAL::VERSION
      &utf8::is_utf8
      &utf8::valid
      &utf8::encode
      &utf8::decode
      &utf8::upgrade
      &utf8::downgrade
      &utf8::native_to_unicode
      &utf8::unicode_to_native
      &utf8::SWASHNEW
      $version::VERSION
      $version::CLASS
      $version::STRICT
      $version::LAX
      @version::ISA
  ], ($] < 5.010 && qw[
      &utf8::SWASHGET
  ]), ($] >= 5.008001 && qw[
      &Regexp::DESTROY
  ]), ($] >= 5.010 && qw[
      &re::is_regexp
      &re::regname
      &re::regnames
      &re::regnames_count
      &Tie::Hash::NamedCapture::FETCH
      &Tie::Hash::NamedCapture::STORE
      &Tie::Hash::NamedCapture::DELETE
      &Tie::Hash::NamedCapture::CLEAR
      &Tie::Hash::NamedCapture::EXISTS
      &Tie::Hash::NamedCapture::FIRSTKEY
      &Tie::Hash::NamedCapture::NEXTKEY
      &Tie::Hash::NamedCapture::SCALAR
      &Tie::Hash::NamedCapture::flags
      &UNIVERSAL::DOES
      &version::()
      &version::new
      &version::(""
      &version::stringify
      &version::(0+
      &version::numify
      &version::normal
      &version::(cmp
      &version::(<=>
      &version::vcmp
      &version::(bool
      &version::boolean
      &version::(nomethod
      &version::noop
      &version::is_alpha
      &version::qv
      &version::vxs::declare
      &version::vxs::qv
      &version::vxs::_VERSION
      &version::vxs::stringify
      &version::vxs::new
      &version::vxs::parse
  ]), ($] >= 5.011 && qw[
      &re::regexp_pattern
  ])];
  
  sub new {
      my($class, $root, $mask) = @_;
      my $obj = {};
      bless $obj, $class;
  
      if (defined($root)) {
          croak "Can't use \"$root\" as root name"
              if $root =~ /^main\b/ or $root !~ /^\w[:\w]*$/;
          $obj->{Root}  = $root;
          $obj->{Erase} = 0;
      }
      else {
          $obj->{Root}  = "Safe::Root".$default_root++;
          $obj->{Erase} = 1;
      }
  
      # use permit/deny methods instead till interface issues resolved
      # XXX perhaps new Safe 'Root', mask => $mask, foo => bar, ...;
      croak "Mask parameter to new no longer supported" if defined $mask;
      $obj->permit_only(':default');
  
      # We must share $_ and @_ with the compartment or else ops such
      # as split, length and so on won't default to $_ properly, nor
      # will passing argument to subroutines work (via @_). In fact,
      # for reasons I don't completely understand, we need to share
      # the whole glob *_ rather than $_ and @_ separately, otherwise
      # @_ in non default packages within the compartment don't work.
      $obj->share_from('main', $default_share);
  
      Opcode::_safe_pkg_prep($obj->{Root}) if($Opcode::VERSION > 1.04);
  
      return $obj;
  }
  
  sub DESTROY {
      my $obj = shift;
      $obj->erase('DESTROY') if $obj->{Erase};
  }
  
  sub erase {
      my ($obj, $action) = @_;
      my $pkg = $obj->root();
      my ($stem, $leaf);
  
      no strict 'refs';
      $pkg = "main::$pkg\::";     # expand to full symbol table name
      ($stem, $leaf) = $pkg =~ m/(.*::)(\w+::)$/;
  
      # The 'my $foo' is needed! Without it you get an
      # 'Attempt to free unreferenced scalar' warning!
      my $stem_symtab = *{$stem}{HASH};
  
      #warn "erase($pkg) stem=$stem, leaf=$leaf";
      #warn " stem_symtab hash ".scalar(%$stem_symtab)."\n";
      # ", join(', ', %$stem_symtab),"\n";
  
  #    delete $stem_symtab->{$leaf};
  
      my $leaf_glob   = $stem_symtab->{$leaf};
      my $leaf_symtab = *{$leaf_glob}{HASH};
  #    warn " leaf_symtab ", join(', ', %$leaf_symtab),"\n";
      %$leaf_symtab = ();
      #delete $leaf_symtab->{'__ANON__'};
      #delete $leaf_symtab->{'foo'};
      #delete $leaf_symtab->{'main::'};
  #    my $foo = undef ${"$stem\::"}{"$leaf\::"};
  
      if ($action and $action eq 'DESTROY') {
          delete $stem_symtab->{$leaf};
      } else {
          $obj->share_from('main', $default_share);
      }
      1;
  }
  
  
  sub reinit {
      my $obj= shift;
      $obj->erase;
      $obj->share_redo;
  }
  
  sub root {
      my $obj = shift;
      croak("Safe root method now read-only") if @_;
      return $obj->{Root};
  }
  
  
  sub mask {
      my $obj = shift;
      return $obj->{Mask} unless @_;
      $obj->deny_only(@_);
  }
  
  # v1 compatibility methods
  sub trap   { shift->deny(@_)   }
  sub untrap { shift->permit(@_) }
  
  sub deny {
      my $obj = shift;
      $obj->{Mask} |= opset(@_);
  }
  sub deny_only {
      my $obj = shift;
      $obj->{Mask} = opset(@_);
  }
  
  sub permit {
      my $obj = shift;
      # XXX needs testing
      $obj->{Mask} &= invert_opset opset(@_);
  }
  sub permit_only {
      my $obj = shift;
      $obj->{Mask} = invert_opset opset(@_);
  }
  
  
  sub dump_mask {
      my $obj = shift;
      print opset_to_hex($obj->{Mask}),"\n";
  }
  
  
  sub share {
      my($obj, @vars) = @_;
      $obj->share_from(scalar(caller), \@vars);
  }
  
  
  sub share_from {
      my $obj = shift;
      my $pkg = shift;
      my $vars = shift;
      my $no_record = shift || 0;
      my $root = $obj->root();
      croak("vars not an array ref") unless ref $vars eq 'ARRAY';
      no strict 'refs';
      # Check that 'from' package actually exists
      croak("Package \"$pkg\" does not exist")
          unless keys %{"$pkg\::"};
      my $arg;
      foreach $arg (@$vars) {
          # catch some $safe->share($var) errors:
          my ($var, $type);
          $type = $1 if ($var = $arg) =~ s/^(\W)//;
          # warn "share_from $pkg $type $var";
          for (1..2) { # assign twice to avoid any 'used once' warnings
              *{$root."::$var"} = (!$type)   ? \&{$pkg."::$var"}
                            : ($type eq '&') ? \&{$pkg."::$var"}
                            : ($type eq '$') ? \${$pkg."::$var"}
                            : ($type eq '@') ? \@{$pkg."::$var"}
                            : ($type eq '%') ? \%{$pkg."::$var"}
                            : ($type eq '*') ?  *{$pkg."::$var"}
                            : croak(qq(Can't share "$type$var" of unknown type));
          }
      }
      $obj->share_record($pkg, $vars) unless $no_record or !$vars;
  }
  
  
  sub share_record {
      my $obj = shift;
      my $pkg = shift;
      my $vars = shift;
      my $shares = \%{$obj->{Shares} ||= {}};
      # Record shares using keys of $obj->{Shares}. See reinit.
      @{$shares}{@$vars} = ($pkg) x @$vars if @$vars;
  }
  
  
  sub share_redo {
      my $obj = shift;
      my $shares = \%{$obj->{Shares} ||= {}};
      my($var, $pkg);
      while(($var, $pkg) = each %$shares) {
          # warn "share_redo $pkg\:: $var";
          $obj->share_from($pkg,  [ $var ], 1);
      }
  }
  
  
  sub share_forget {
      delete shift->{Shares};
  }
  
  
  sub varglob {
      my ($obj, $var) = @_;
      no strict 'refs';
      return *{$obj->root()."::$var"};
  }
  
  sub _clean_stash {
      my ($root, $saved_refs) = @_;
      $saved_refs ||= [];
      no strict 'refs';
      foreach my $hook (qw(DESTROY AUTOLOAD), grep /^\(/, keys %$root) {
          push @$saved_refs, \*{$root.$hook};
          delete ${$root}{$hook};
      }
  
      for (grep /::$/, keys %$root) {
          next if \%{$root.$_} eq \%$root;
          _clean_stash($root.$_, $saved_refs);
      }
  }
  
  sub reval {
      my ($obj, $expr, $strict) = @_;
      my $root = $obj->{Root};
  
      my $evalsub = lexless_anon_sub($root, $strict, $expr);
      # propagate context
      my $sg = sub_generation();
      my @subret = (wantarray)
                 ?        Opcode::_safe_call_sv($root, $obj->{Mask}, $evalsub)
                 : scalar Opcode::_safe_call_sv($root, $obj->{Mask}, $evalsub);
      _clean_stash($root.'::') if $sg != sub_generation();
      $obj->wrap_code_refs_within(@subret);
      return (wantarray) ? @subret : $subret[0];
  }
  
  
  sub wrap_code_refs_within {
      my $obj = shift;
  
      $obj->_find_code_refs('wrap_code_ref', @_);
  }
  
  
  sub _find_code_refs {
      my $obj = shift;
      my $visitor = shift;
  
      for my $item (@_) {
          my $reftype = $item && reftype $item
              or next;
          if ($reftype eq 'ARRAY') {
              $obj->_find_code_refs($visitor, @$item);
          }
          elsif ($reftype eq 'HASH') {
              $obj->_find_code_refs($visitor, values %$item);
          }
          # XXX GLOBs?
          elsif ($reftype eq 'CODE') {
              $item = $obj->$visitor($item);
          }
      }
  }
  
  
  sub wrap_code_ref {
      my ($obj, $sub) = @_;
  
      # wrap code ref $sub with _safe_call_sv so that, when called, the
      # execution will happen with the compartment fully 'in effect'.
  
      croak "Not a CODE reference"
          if reftype $sub ne 'CODE';
  
      my $ret = sub {
          my @args = @_; # lexical to close over
          my $sub_with_args = sub { $sub->(@args) };
  
          my @subret;
          my $error;
          do {
              local $@;  # needed due to perl_call_sv(sv, G_EVAL|G_KEEPERR)
              my $sg = sub_generation();
              @subret = (wantarray)
                  ?        Opcode::_safe_call_sv($obj->{Root}, $obj->{Mask}, $sub_with_args)
                  : scalar Opcode::_safe_call_sv($obj->{Root}, $obj->{Mask}, $sub_with_args);
              $error = $@;
              _clean_stash($obj->{Root}.'::') if $sg != sub_generation();
          };
          if ($error) { # rethrow exception
              $error =~ s/\t\(in cleanup\) //; # prefix added by G_KEEPERR
              die $error;
          }
          return (wantarray) ? @subret : $subret[0];
      };
  
      return $ret;
  }
  
  
  sub rdo {
      my ($obj, $file) = @_;
      my $root = $obj->{Root};
  
      my $sg = sub_generation();
      my $evalsub = eval
              sprintf('package %s; sub { @_ = (); do $file }', $root);
      my @subret = (wantarray)
                 ?        Opcode::_safe_call_sv($root, $obj->{Mask}, $evalsub)
                 : scalar Opcode::_safe_call_sv($root, $obj->{Mask}, $evalsub);
      _clean_stash($root.'::') if $sg != sub_generation();
      $obj->wrap_code_refs_within(@subret);
      return (wantarray) ? @subret : $subret[0];
  }
  
  
  1;
  
  __END__
  
  =head1 NAME
  
  Safe - Compile and execute code in restricted compartments
  
  =head1 SYNOPSIS
  
    use Safe;
  
    $compartment = new Safe;
  
    $compartment->permit(qw(time sort :browse));
  
    $result = $compartment->reval($unsafe_code);
  
  =head1 DESCRIPTION
  
  The Safe extension module allows the creation of compartments
  in which perl code can be evaluated. Each compartment has
  
  =over 8
  
  =item a new namespace
  
  The "root" of the namespace (i.e. "main::") is changed to a
  different package and code evaluated in the compartment cannot
  refer to variables outside this namespace, even with run-time
  glob lookups and other tricks.
  
  Code which is compiled outside the compartment can choose to place
  variables into (or I<share> variables with) the compartment's namespace
  and only that data will be visible to code evaluated in the
  compartment.
  
  By default, the only variables shared with compartments are the
  "underscore" variables $_ and @_ (and, technically, the less frequently
  used %_, the _ filehandle and so on). This is because otherwise perl
  operators which default to $_ will not work and neither will the
  assignment of arguments to @_ on subroutine entry.
  
  =item an operator mask
  
  Each compartment has an associated "operator mask". Recall that
  perl code is compiled into an internal format before execution.
  Evaluating perl code (e.g. via "eval" or "do 'file'") causes
  the code to be compiled into an internal format and then,
  provided there was no error in the compilation, executed.
  Code evaluated in a compartment compiles subject to the
  compartment's operator mask. Attempting to evaluate code in a
  compartment which contains a masked operator will cause the
  compilation to fail with an error. The code will not be executed.
  
  The default operator mask for a newly created compartment is
  the ':default' optag.
  
  It is important that you read the L<Opcode> module documentation
  for more information, especially for detailed definitions of opnames,
  optags and opsets.
  
  Since it is only at the compilation stage that the operator mask
  applies, controlled access to potentially unsafe operations can
  be achieved by having a handle to a wrapper subroutine (written
  outside the compartment) placed into the compartment. For example,
  
      $cpt = new Safe;
      sub wrapper {
          # vet arguments and perform potentially unsafe operations
      }
      $cpt->share('&wrapper');
  
  =back
  
  
  =head1 WARNING
  
  The authors make B<no warranty>, implied or otherwise, about the
  suitability of this software for safety or security purposes.
  
  The authors shall not in any case be liable for special, incidental,
  consequential, indirect or other similar damages arising from the use
  of this software.
  
  Your mileage will vary. If in any doubt B<do not use it>.
  
  
  =head1 METHODS
  
  To create a new compartment, use
  
      $cpt = new Safe;
  
  Optional argument is (NAMESPACE), where NAMESPACE is the root namespace
  to use for the compartment (defaults to "Safe::Root0", incremented for
  each new compartment).
  
  Note that version 1.00 of the Safe module supported a second optional
  parameter, MASK.  That functionality has been withdrawn pending deeper
  consideration. Use the permit and deny methods described below.
  
  The following methods can then be used on the compartment
  object returned by the above constructor. The object argument
  is implicit in each case.
  
  
  =head2 permit (OP, ...)
  
  Permit the listed operators to be used when compiling code in the
  compartment (in I<addition> to any operators already permitted).
  
  You can list opcodes by names, or use a tag name; see
  L<Opcode/"Predefined Opcode Tags">.
  
  =head2 permit_only (OP, ...)
  
  Permit I<only> the listed operators to be used when compiling code in
  the compartment (I<no> other operators are permitted).
  
  =head2 deny (OP, ...)
  
  Deny the listed operators from being used when compiling code in the
  compartment (other operators may still be permitted).
  
  =head2 deny_only (OP, ...)
  
  Deny I<only> the listed operators from being used when compiling code
  in the compartment (I<all> other operators will be permitted, so you probably
  don't want to use this method).
  
  =head2 trap (OP, ...)
  
  =head2 untrap (OP, ...)
  
  The trap and untrap methods are synonyms for deny and permit
  respectfully.
  
  =head2 share (NAME, ...)
  
  This shares the variable(s) in the argument list with the compartment.
  This is almost identical to exporting variables using the L<Exporter>
  module.
  
  Each NAME must be the B<name> of a non-lexical variable, typically
  with the leading type identifier included. A bareword is treated as a
  function name.
  
  Examples of legal names are '$foo' for a scalar, '@foo' for an
  array, '%foo' for a hash, '&foo' or 'foo' for a subroutine and '*foo'
  for a glob (i.e.  all symbol table entries associated with "foo",
  including scalar, array, hash, sub and filehandle).
  
  Each NAME is assumed to be in the calling package. See share_from
  for an alternative method (which C<share> uses).
  
  =head2 share_from (PACKAGE, ARRAYREF)
  
  This method is similar to share() but allows you to explicitly name the
  package that symbols should be shared from. The symbol names (including
  type characters) are supplied as an array reference.
  
      $safe->share_from('main', [ '$foo', '%bar', 'func' ]);
  
  Names can include package names, which are relative to the specified PACKAGE.
  So these two calls have the same effect:
  
      $safe->share_from('Scalar::Util', [ 'reftype' ]);
      $safe->share_from('main', [ 'Scalar::Util::reftype' ]);
  
  =head2 varglob (VARNAME)
  
  This returns a glob reference for the symbol table entry of VARNAME in
  the package of the compartment. VARNAME must be the B<name> of a
  variable without any leading type marker. For example:
  
      ${$cpt->varglob('foo')} = "Hello world";
  
  has the same effect as:
  
      $cpt = new Safe 'Root';
      $Root::foo = "Hello world";
  
  but avoids the need to know $cpt's package name.
  
  
  =head2 reval (STRING, STRICT)
  
  This evaluates STRING as perl code inside the compartment.
  
  The code can only see the compartment's namespace (as returned by the
  B<root> method). The compartment's root package appears to be the
  C<main::> package to the code inside the compartment.
  
  Any attempt by the code in STRING to use an operator which is not permitted
  by the compartment will cause an error (at run-time of the main program
  but at compile-time for the code in STRING).  The error is of the form
  "'%s' trapped by operation mask...".
  
  If an operation is trapped in this way, then the code in STRING will
  not be executed. If such a trapped operation occurs or any other
  compile-time or return error, then $@ is set to the error message, just
  as with an eval().
  
  If there is no error, then the method returns the value of the last
  expression evaluated, or a return statement may be used, just as with
  subroutines and B<eval()>. The context (list or scalar) is determined
  by the caller as usual.
  
  If the return value of reval() is (or contains) any code reference,
  those code references are wrapped to be themselves executed always
  in the compartment. See L</wrap_code_refs_within>.
  
  The formerly undocumented STRICT argument sets strictness: if true
  'use strict;' is used, otherwise it uses 'no strict;'. B<Note>: if
  STRICT is omitted 'no strict;' is the default.
  
  Some points to note:
  
  If the entereval op is permitted then the code can use eval "..." to
  'hide' code which might use denied ops. This is not a major problem
  since when the code tries to execute the eval it will fail because the
  opmask is still in effect. However this technique would allow clever,
  and possibly harmful, code to 'probe' the boundaries of what is
  possible.
  
  Any string eval which is executed by code executing in a compartment,
  or by code called from code executing in a compartment, will be eval'd
  in the namespace of the compartment. This is potentially a serious
  problem.
  
  Consider a function foo() in package pkg compiled outside a compartment
  but shared with it. Assume the compartment has a root package called
  'Root'. If foo() contains an eval statement like eval '$foo = 1' then,
  normally, $pkg::foo will be set to 1.  If foo() is called from the
  compartment (by whatever means) then instead of setting $pkg::foo, the
  eval will actually set $Root::pkg::foo.
  
  This can easily be demonstrated by using a module, such as the Socket
  module, which uses eval "..." as part of an AUTOLOAD function. You can
  'use' the module outside the compartment and share an (autoloaded)
  function with the compartment. If an autoload is triggered by code in
  the compartment, or by any code anywhere that is called by any means
  from the compartment, then the eval in the Socket module's AUTOLOAD
  function happens in the namespace of the compartment. Any variables
  created or used by the eval'd code are now under the control of
  the code in the compartment.
  
  A similar effect applies to I<all> runtime symbol lookups in code
  called from a compartment but not compiled within it.
  
  =head2 rdo (FILENAME)
  
  This evaluates the contents of file FILENAME inside the compartment.
  See above documentation on the B<reval> method for further details.
  
  =head2 root (NAMESPACE)
  
  This method returns the name of the package that is the root of the
  compartment's namespace.
  
  Note that this behaviour differs from version 1.00 of the Safe module
  where the root module could be used to change the namespace. That
  functionality has been withdrawn pending deeper consideration.
  
  =head2 mask (MASK)
  
  This is a get-or-set method for the compartment's operator mask.
  
  With no MASK argument present, it returns the current operator mask of
  the compartment.
  
  With the MASK argument present, it sets the operator mask for the
  compartment (equivalent to calling the deny_only method).
  
  =head2 wrap_code_ref (CODEREF)
  
  Returns a reference to an anonymous subroutine that, when executed, will call
  CODEREF with the Safe compartment 'in effect'.  In other words, with the
  package namespace adjusted and the opmask enabled.
  
  Note that the opmask doesn't affect the already compiled code, it only affects
  any I<further> compilation that the already compiled code may try to perform.
  
  This is particularly useful when applied to code references returned from reval().
  
  (It also provides a kind of workaround for RT#60374: "Safe.pm sort {} bug with
  -Dusethreads". See L<http://rt.perl.org/rt3//Public/Bug/Display.html?id=60374>
  for I<much> more detail.)
  
  =head2 wrap_code_refs_within (...)
  
  Wraps any CODE references found within the arguments by replacing each with the
  result of calling L</wrap_code_ref> on the CODE reference. Any ARRAY or HASH
  references in the arguments are inspected recursively.
  
  Returns nothing.
  
  =head1 RISKS
  
  This section is just an outline of some of the things code in a compartment
  might do (intentionally or unintentionally) which can have an effect outside
  the compartment.
  
  =over 8
  
  =item Memory
  
  Consuming all (or nearly all) available memory.
  
  =item CPU
  
  Causing infinite loops etc.
  
  =item Snooping
  
  Copying private information out of your system. Even something as
  simple as your user name is of value to others. Much useful information
  could be gleaned from your environment variables for example.
  
  =item Signals
  
  Causing signals (especially SIGFPE and SIGALARM) to affect your process.
  
  Setting up a signal handler will need to be carefully considered
  and controlled.  What mask is in effect when a signal handler
  gets called?  If a user can get an imported function to get an
  exception and call the user's signal handler, does that user's
  restricted mask get re-instated before the handler is called?
  Does an imported handler get called with its original mask or
  the user's one?
  
  =item State Changes
  
  Ops such as chdir obviously effect the process as a whole and not just
  the code in the compartment. Ops such as rand and srand have a similar
  but more subtle effect.
  
  =back
  
  =head1 AUTHOR
  
  Originally designed and implemented by Malcolm Beattie.
  
  Reworked to use the Opcode module and other changes added by Tim Bunce.
  
  Currently maintained by the Perl 5 Porters, <perl5-porters@perl.org>.
  
  =cut
  
5.10_SAFE

$fatpacked{"5.10/Scalar/Util.pm"} = <<'5.10_SCALAR_UTIL';
  # Scalar::Util.pm
  #
  # Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  package Scalar::Util;
  
  use strict;
  use vars qw(@ISA @EXPORT_OK $VERSION @EXPORT_FAIL);
  require Exporter;
  require List::Util; # List::Util loads the XS
  
  @ISA       = qw(Exporter);
  @EXPORT_OK = qw(blessed dualvar reftype weaken isweak tainted readonly openhandle refaddr isvstring looks_like_number set_prototype);
  $VERSION    = "1.23";
  $VERSION   = eval $VERSION;
  
  unless (defined &dualvar) {
    # Load Pure Perl version if XS not loaded
    require Scalar::Util::PP;
    Scalar::Util::PP->import;
    push @EXPORT_FAIL, qw(weaken isweak dualvar isvstring set_prototype);
  }
  
  sub export_fail {
    if (grep { /dualvar/ } @EXPORT_FAIL) { # no XS loaded
      my $pat = join("|", @EXPORT_FAIL);
      if (my ($err) = grep { /^($pat)$/ } @_ ) {
        require Carp;
        Carp::croak("$err is only available with the XS version of Scalar::Util");
      }
    }
  
    if (grep { /^(weaken|isweak)$/ } @_ ) {
      require Carp;
      Carp::croak("Weak references are not implemented in the version of perl");
    }
  
    if (grep { /^(isvstring)$/ } @_ ) {
      require Carp;
      Carp::croak("Vstrings are not implemented in the version of perl");
    }
  
    @_;
  }
  
  sub openhandle ($) {
    my $fh = shift;
    my $rt = reftype($fh) || '';
  
    return defined(fileno($fh)) ? $fh : undef
      if $rt eq 'IO';
  
    if (reftype(\$fh) eq 'GLOB') { # handle  openhandle(*DATA)
      $fh = \(my $tmp=$fh);
    }
    elsif ($rt ne 'GLOB') {
      return undef;
    }
  
    (tied(*$fh) or defined(fileno($fh)))
      ? $fh : undef;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Scalar::Util - A selection of general-utility scalar subroutines
  
  =head1 SYNOPSIS
  
      use Scalar::Util qw(blessed dualvar isweak readonly refaddr reftype tainted
                          weaken isvstring looks_like_number set_prototype);
                          # and other useful utils appearing below
  
  =head1 DESCRIPTION
  
  C<Scalar::Util> contains a selection of subroutines that people have
  expressed would be nice to have in the perl core, but the usage would
  not really be high enough to warrant the use of a keyword, and the size
  so small such that being individual extensions would be wasteful.
  
  By default C<Scalar::Util> does not export any subroutines. The
  subroutines defined are
  
  =over 4
  
  =item blessed EXPR
  
  If EXPR evaluates to a blessed reference the name of the package
  that it is blessed into is returned. Otherwise C<undef> is returned.
  
     $scalar = "foo";
     $class  = blessed $scalar;           # undef
  
     $ref    = [];
     $class  = blessed $ref;              # undef
  
     $obj    = bless [], "Foo";
     $class  = blessed $obj;              # "Foo"
  
  =item dualvar NUM, STRING
  
  Returns a scalar that has the value NUM in a numeric context and the
  value STRING in a string context.
  
      $foo = dualvar 10, "Hello";
      $num = $foo + 2;                    # 12
      $str = $foo . " world";             # Hello world
  
  =item isvstring EXPR
  
  If EXPR is a scalar which was coded as a vstring the result is true.
  
      $vs   = v49.46.48;
      $fmt  = isvstring($vs) ? "%vd" : "%s"; #true
      printf($fmt,$vs);
  
  =item isweak EXPR
  
  If EXPR is a scalar which is a weak reference the result is true.
  
      $ref  = \$foo;
      $weak = isweak($ref);               # false
      weaken($ref);
      $weak = isweak($ref);               # true
  
  B<NOTE>: Copying a weak reference creates a normal, strong, reference.
  
      $copy = $ref;
      $weak = isweak($copy);              # false
  
  =item looks_like_number EXPR
  
  Returns true if perl thinks EXPR is a number. See
  L<perlapi/looks_like_number>.
  
  =item openhandle FH
  
  Returns FH if FH may be used as a filehandle and is open, or FH is a tied
  handle. Otherwise C<undef> is returned.
  
      $fh = openhandle(*STDIN);		# \*STDIN
      $fh = openhandle(\*STDIN);		# \*STDIN
      $fh = openhandle(*NOTOPEN);		# undef
      $fh = openhandle("scalar");		# undef
      
  =item readonly SCALAR
  
  Returns true if SCALAR is readonly.
  
      sub foo { readonly($_[0]) }
  
      $readonly = foo($bar);              # false
      $readonly = foo(0);                 # true
  
  =item refaddr EXPR
  
  If EXPR evaluates to a reference the internal memory address of
  the referenced value is returned. Otherwise C<undef> is returned.
  
      $addr = refaddr "string";           # undef
      $addr = refaddr \$var;              # eg 12345678
      $addr = refaddr [];                 # eg 23456784
  
      $obj  = bless {}, "Foo";
      $addr = refaddr $obj;               # eg 88123488
  
  =item reftype EXPR
  
  If EXPR evaluates to a reference the type of the variable referenced
  is returned. Otherwise C<undef> is returned.
  
      $type = reftype "string";           # undef
      $type = reftype \$var;              # SCALAR
      $type = reftype [];                 # ARRAY
  
      $obj  = bless {}, "Foo";
      $type = reftype $obj;               # HASH
  
  =item set_prototype CODEREF, PROTOTYPE
  
  Sets the prototype of the given function, or deletes it if PROTOTYPE is
  undef. Returns the CODEREF.
  
      set_prototype \&foo, '$$';
  
  =item tainted EXPR
  
  Return true if the result of EXPR is tainted
  
      $taint = tainted("constant");       # false
      $taint = tainted($ENV{PWD});        # true if running under -T
  
  =item weaken REF
  
  REF will be turned into a weak reference. This means that it will not
  hold a reference count on the object it references. Also when the reference
  count on that object reaches zero, REF will be set to undef.
  
  This is useful for keeping copies of references , but you don't want to
  prevent the object being DESTROY-ed at its usual time.
  
      {
        my $var;
        $ref = \$var;
        weaken($ref);                     # Make $ref a weak reference
      }
      # $ref is now undef
  
  Note that if you take a copy of a scalar with a weakened reference,
  the copy will be a strong reference.
  
      my $var;
      my $foo = \$var;
      weaken($foo);                       # Make $foo a weak reference
      my $bar = $foo;                     # $bar is now a strong reference
  
  This may be less obvious in other situations, such as C<grep()>, for instance
  when grepping through a list of weakened references to objects that may have
  been destroyed already:
  
      @object = grep { defined } @object;
  
  This will indeed remove all references to destroyed objects, but the remaining
  references to objects will be strong, causing the remaining objects to never
  be destroyed because there is now always a strong reference to them in the
  @object array.
  
  =back
  
  =head1 DIAGNOSTICS
  
  Module use may give one of the following errors during import.
  
  =over
  
  =item Weak references are not implemented in the version of perl
  
  The version of perl that you are using does not implement weak references, to use
  C<isweak> or C<weaken> you will need to use a newer release of perl.
  
  =item Vstrings are not implemented in the version of perl
  
  The version of perl that you are using does not implement Vstrings, to use
  C<isvstring> you will need to use a newer release of perl.
  
  =item C<NAME> is only available with the XS version of Scalar::Util
  
  C<Scalar::Util> contains both perl and C implementations of many of its functions
  so that those without access to a C compiler may still use it. However some of the functions
  are only available when a C compiler was available to compile the XS version of the extension.
  
  At present that list is: weaken, isweak, dualvar, isvstring, set_prototype
  
  =back
  
  =head1 KNOWN BUGS
  
  There is a bug in perl5.6.0 with UV's that are >= 1<<31. This will
  show up as tests 8 and 9 of dualvar.t failing
  
  =head1 SEE ALSO
  
  L<List::Util>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1997-2007 Graham Barr <gbarr@pobox.com>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  Except weaken and isweak which are
  
  Copyright (c) 1999 Tuomas J. Lukka <lukka@iki.fi>. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as perl itself.
  
  =cut
5.10_SCALAR_UTIL

$fatpacked{"5.10/Scalar/Util/PP.pm"} = <<'5.10_SCALAR_UTIL_PP';
  # Scalar::Util::PP.pm
  #
  # Copyright (c) 1997-2009 Graham Barr <gbarr@pobox.com>. All rights reserved.
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  #
  # This module is normally only loaded if the XS module is not available
  
  package Scalar::Util::PP;
  
  use strict;
  use warnings;
  use vars qw(@ISA @EXPORT $VERSION $recurse);
  require Exporter;
  use B qw(svref_2object);
  
  @ISA     = qw(Exporter);
  @EXPORT  = qw(blessed reftype tainted readonly refaddr looks_like_number);
  $VERSION = "1.23";
  $VERSION = eval $VERSION;
  
  sub blessed ($) {
    return undef unless length(ref($_[0]));
    my $b = svref_2object($_[0]);
    return undef unless $b->isa('B::PVMG');
    my $s = $b->SvSTASH;
    return $s->isa('B::HV') ? $s->NAME : undef;
  }
  
  sub refaddr($) {
    return undef unless length(ref($_[0]));
  
    my $addr;
    if(defined(my $pkg = blessed($_[0]))) {
      $addr .= bless $_[0], 'Scalar::Util::Fake';
      bless $_[0], $pkg;
    }
    else {
      $addr .= $_[0]
    }
  
    $addr =~ /0x(\w+)/;
    local $^W;
    no warnings 'portable';
    hex($1);
  }
  
  {
    my %tmap = qw(
      B::NULL   SCALAR
  
      B::HV     HASH
      B::AV     ARRAY
      B::CV     CODE
      B::IO     IO
      B::GV     GLOB
      B::REGEXP REGEXP
    );
  
    sub reftype ($) {
      my $r = shift;
  
      return undef unless length(ref($r));
  
      my $t = ref(svref_2object($r));
  
      return
          exists $tmap{$t} ? $tmap{$t}
        : length(ref($$r)) ? 'REF'
        :                    'SCALAR';
    }
  }
  
  sub tainted {
    local($@, $SIG{__DIE__}, $SIG{__WARN__});
    local $^W = 0;
    no warnings;
    eval { kill 0 * $_[0] };
    $@ =~ /^Insecure/;
  }
  
  sub readonly {
    return 0 if tied($_[0]) || (ref(\($_[0])) ne "SCALAR");
  
    local($@, $SIG{__DIE__}, $SIG{__WARN__});
    my $tmp = $_[0];
  
    !eval { $_[0] = $tmp; 1 };
  }
  
  sub looks_like_number {
    local $_ = shift;
  
    # checks from perlfaq4
    return 0 if !defined($_);
    if (ref($_)) {
      require overload;
      return overload::Overloaded($_) ? defined(0 + $_) : 0;
    }
    return 1 if (/^[+-]?[0-9]+$/); # is a +/- integer
    return 1 if (/^([+-]?)(?=[0-9]|\.[0-9])[0-9]*(\.[0-9]*)?([Ee]([+-]?[0-9]+))?$/); # a C float
    return 1 if ($] >= 5.008 and /^(Inf(inity)?|NaN)$/i) or ($] >= 5.006001 and /^Inf$/i);
  
    0;
  }
  
  
  1;
5.10_SCALAR_UTIL_PP

$fatpacked{"App/Cmd.pm"} = <<'APP_CMD';
  use strict;
  use warnings;
  use 5.006;
  
  package App::Cmd;
  BEGIN {
    $App::Cmd::VERSION = '0.310';
  }
  use App::Cmd::ArgProcessor;
  BEGIN { our @ISA = 'App::Cmd::ArgProcessor' };
  # ABSTRACT: write command line apps with less suffering
  
  use File::Basename ();
  use Module::Pluggable::Object ();
  use Text::Abbrev ();
  use Class::Load ();
  
  use Sub::Exporter -setup => {
    collectors => {
      -command => \'_setup_command',
      -run     => sub {
        warn "using -run to run your command is deprecated\n";
        $_[1]->{class}->run; 1
      },
    },
  };
  
  sub _setup_command {
    my ($self, $val, $data) = @_;
    my $into = $data->{into};
  
    Carp::confess "App::Cmd -command setup requested for already-setup class"
      if $into->isa('App::Cmd::Command');
  
    {
      my $base = $self->_default_command_base;
      Class::Load::load_class($base);
      no strict 'refs';
      push @{"$into\::ISA"}, $base;
    }
  
    $self->_register_command($into);
  
    for my $plugin ($self->_plugin_plugins) {
      $plugin->import_from_plugin({ into => $into });
    }
  
    1;
  }
  
  sub _plugin_plugins { return }
  
  
  sub new {
    my ($class, $arg) = @_;
  
    my $arg0 = $0;
    my $base = File::Basename::basename $arg0;
  
    my $self = {
      command   => $class->_command($arg),
      arg0      => $base,
      full_arg0 => $arg0,
    };
  
    bless $self => $class;
  }
  
  # effectively, returns the command-to-plugin mapping guts of a Cmd
  # if called on a class or on a Cmd with no mapping, construct a new hashref
  # suitable for use as the object's mapping
  sub _command {
    my ($self, $arg) = @_;
    return $self->{command} if ref $self and $self->{command};
  
    # TODO _default_command_base can be wrong if people are not using
    # ::Setup and have no ::Command :(
    #
    #  my $want_isa = $self->_default_command_base;
    # -- kentnl, 2010-12
     my $want_isa = 'App::Cmd::Command';
  
    my %plugin;
    for my $plugin ($self->_plugins) {
      Class::Load::load_class($plugin);
  
      die "$plugin is not a " . $want_isa
        unless $plugin->isa($want_isa);
  
      next unless $plugin->can("command_names");
  
      foreach my $command (map { lc } $plugin->command_names) {
        die "two plugins for command $command: $plugin and $plugin{$command}\n"
          if exists $plugin{$command};
  
        $plugin{$command} = $plugin;
      }
    }
  
    $self->_load_default_plugin($_, $arg, \%plugin) for qw(commands help);
  
    if ($self->allow_any_unambiguous_abbrev) {
      # add abbreviations to list of authorized commands
      my %abbrev = Text::Abbrev::abbrev( keys %plugin );
      @plugin{ keys %abbrev } = @plugin{ values %abbrev };
    }
  
    return \%plugin;
  }
  
  # ->_plugins won't be called more than once on any given App::Cmd, but since
  # finding plugins can be a bit expensive, we'll do a lousy cache here.
  # -- rjbs, 2007-10-09
  my %plugins_for;
  sub _plugins {
    my ($self) = @_;
    my $class = ref $self || $self;
  
    return @{ $plugins_for{$class} } if $plugins_for{$class};
  
    my $finder = Module::Pluggable::Object->new(
      search_path => $self->plugin_search_path,
      $self->_module_pluggable_options,
    );
  
    my @plugins = $finder->plugins;
    $plugins_for{$class} = \@plugins;
  
    return @plugins;
  }
  
  sub _register_command {
    my ($self, $cmd_class) = @_;
    $self->_plugins;
  
    my $class = ref $self || $self;
    push @{ $plugins_for{ $class } }, $cmd_class
      unless grep { $_ eq $cmd_class } @{ $plugins_for{ $class } };
  }
  
  sub _module_pluggable_options {
    # my ($self) = @_; # no point in creating these ops, just to toss $self
    return;
  }
  
  # load one of the stock plugins, unless requested to squash; unlike normal
  # plugin loading, command-to-plugin mapping conflicts are silently ignored
  sub _load_default_plugin {
    my ($self, $plugin_name, $arg, $plugin_href) = @_;
    unless ($arg->{"no_$plugin_name\_plugin"}) {
      my $plugin = "App::Cmd::Command::$plugin_name";
      Class::Load::load_class($plugin);
      for my $command (map { lc } $plugin->command_names) {
        $plugin_href->{$command} ||= $plugin;
      }
    }
  }
  
  
  sub run {
    my ($self) = @_;
  
    # We should probably use Class::Default.
    $self = $self->new unless ref $self;
  
    # prepare the command we're going to run...
    my ($cmd, $opt, @args) = $self->prepare_command(@ARGV);
  
    # ...and then run it
    $self->execute_command($cmd, $opt, @args);
  }
  
  
  sub arg0      { $_[0]->{arg0} }
  sub full_arg0 { $_[0]->{full_arg0} }
  
  
  sub prepare_command {
    my ($self, @args) = @_;
  
    # figure out first-level dispatch
    my ($command, $opt, @sub_args) = $self->get_command(@args);
  
    # set up the global options (which we just determined)
    $self->set_global_options($opt);
  
    # find its plugin or else call default plugin (default default is help)
    if ($command) {
      $self->_prepare_command($command, $opt, @sub_args);
    } else {
      $self->_prepare_default_command($opt, @sub_args);
    }
  }
  
  sub _prepare_command {
    my ($self, $command, $opt, @args) = @_;
    if (my $plugin = $self->plugin_for($command)) {
      return $plugin->prepare($self, @args);
    } else {
      return $self->_bad_command($command, $opt, @args);
    }
  }
  
  sub _prepare_default_command {
    my ($self, $opt, @sub_args) = @_;
    $self->_prepare_command($self->default_command, $opt, @sub_args);
  }
  
  sub _bad_command {
    my ($self, $command, $opt, @args) = @_;
    print "Unrecognized command: $command.\n\nUsage:\n" if defined($command);
  
    # This should be class data so that, in Bizarro World, two App::Cmds will not
    # conflict.
    our $_bad++;
    $self->prepare_command("commands");
  }
  
  END { exit 1 if our $_bad };
  
  
  sub default_command { "help" }
  
  
  sub execute_command {
    my ($self, $cmd, $opt, @args) = @_;
  
    local our $active_cmd = $cmd;
  
    $cmd->validate_args($opt, \@args);
    $cmd->execute($opt, \@args);
  }
  
  
  sub _default_command_base {
    my ($self) = @_;
    my $class = ref $self || $self;
    return "$class\::Command";
  }
  
  sub _default_plugin_base {
    my ($self) = @_;
    my $class = ref $self || $self;
    return "$class\::Plugin";
  }
  
  sub plugin_search_path {
    my ($self) = @_;
  
    my $dcb = $self->_default_command_base;
    my $ccb = $dcb eq 'App::Cmd::Command'
            ? $self->App::Cmd::_default_command_base
            : $self->_default_command_base;
  
    my @default = ($ccb, $self->_default_plugin_base);
  
    if (ref $self) {
      return $self->{plugin_search_path} ||= \@default;
    } else {
      return \@default;
    }
  }
  
  
  sub allow_any_unambiguous_abbrev { return 0 }
  
  
  sub global_options {
  	my $self = shift;
  	return $self->{global_options} ||= {} if ref $self;
    return {};
  }
  
  
  sub set_global_options {
    my ($self, $opt) = @_;
    return $self->{global_options} = $opt;
  }
  
  
  sub command_names {
    my ($self) = @_;
    keys %{ $self->_command };
  }
  
  
  sub command_plugins {
    my ($self) = @_;
    my %seen = map {; $_ => 1 } values %{ $self->_command };
    keys %seen;
  }
  
  
  sub plugin_for {
    my ($self, $command) = @_;
    return unless exists $self->_command->{ $command };
  
    return $self->_command->{ $command };
  }
  
  
  sub get_command {
    my ($self, @args) = @_;
  
    my ($opt, $args, %fields)
      = $self->_process_args(\@args, $self->_global_option_processing_params);
  
    my ($command, $rest) = $self->_cmd_from_args($args);
  
    $self->{usage} = $fields{usage};
  
    return ($command, $opt, @$rest);
  }
  
  sub _cmd_from_args {
    my ($self, $args) = @_;
  
    my $command = shift @$args;
    return ($command, $args);
  }
  
  sub _global_option_processing_params {
    my ($self, @args) = @_;
  
    return (
      $self->usage_desc(@args),
      $self->global_opt_spec(@args),
      { getopt_conf => [qw/pass_through/] },
    );
  }
  
  
  sub usage { $_[0]{usage} };
  
  
  sub usage_desc {
    # my ($self) = @_; # no point in creating these ops, just to toss $self
    return "%c %o <command>";
  }
  
  
  sub global_opt_spec {
    # my ($self) = @_; # no point in creating these ops, just to toss $self
    return;
  }
  
  
  sub usage_error {
    my ($self, $error) = @_;
    die "Error: $error\nUsage: " . $self->_usage_text;
  }
  
  sub _usage_text {
    my ($self) = @_;
    my $text = $self->usage->text;
    $text =~ s/\A(\s+)/!/;
    return $text;
  }
  
  
  1;
  
  __END__
  =pod
  
  =head1 NAME
  
  App::Cmd - write command line apps with less suffering
  
  =head1 VERSION
  
  version 0.310
  
  =head1 SYNOPSIS
  
  in F<yourcmd>:
  
    use YourApp;
    YourApp->run;
  
  in F<YourApp.pm>:
  
    package YourApp;
    use App::Cmd::Setup -app;
    1;
  
  in F<YourApp/Command/blort.pm>:
  
    package YourApp::Command::blort;
    use YourApp -command;
    use strict; use warnings;
  
    sub opt_spec {
      return (
        [ "blortex|X",  "use the blortex algorithm" ],
        [ "recheck|r",  "recheck all results"       ],
      );
    }
  
    sub validate_args {
      my ($self, $opt, $args) = @_;
  
      # no args allowed but options!
      $self->usage_error("No args allowed") if @$args;
    }
  
    sub execute {
      my ($self, $opt, $args) = @_;
  
      my $result = $opt->{blortex} ? blortex() : blort();
  
      recheck($result) if $opt->{recheck};
  
      print $result;
    }
  
  and, finally, at the command line:
  
    knight!rjbs$ yourcmd blort --recheck
  
    All blorts successful.
  
  =head1 DESCRIPTION
  
  App::Cmd is intended to make it easy to write complex command-line applications
  without having to think about most of the annoying things usually involved.
  
  For information on how to start using App::Cmd, see L<App::Cmd::Tutorial>.
  
  =head1 METHODS
  
  =head2 new
  
    my $cmd = App::Cmd->new(\%arg);
  
  This method returns a new App::Cmd object.  During initialization, command
  plugins will be loaded.
  
  Valid arguments are:
  
    no_commands_plugin - if true, the command list plugin is not added
  
    no_help_plugin     - if true, the help plugin is not added
  
    plugin_search_path - The path to search for commands in. Defaults to
                         results of plugin_search_path method
  
  If C<no_commands_plugin> is not given, App::Cmd::Command::commands will be
  required, and it will be registered to handle all of its command names not
  handled by other plugins.
  
  If C<no_help_plugin> is not given, App::Cmd::Command::help will be required,
  and it will be registered to handle all of its command names not handled by
  other plugins. B<Note:> "help" is the default command, so if you do not load
  the default help plugin, you should provide our own or override the
  C<default_command> method.
  
  =head2 run
  
    $cmd->run;
  
  This method runs the application.  If called the class, it will instantiate a
  new App::Cmd object to run.
  
  It determines the requested command (generally by consuming the first
  command-line argument), finds the plugin to handle that command, parses the
  remaining arguments according to that plugin's rules, and runs the plugin.
  
  It passes the contents of the global argument array (C<@ARGV>) to
  L</C<prepare_command>>, but C<@ARGV> is not altered by running an App::Cmd.
  
  =head2 arg0
  
  =head2 full_arg0
  
    my $program_name = $app->arg0;
  
    my $full_program_name = $app->full_arg0;
  
  These methods return the name of the program invoked to run this application.
  This is determined by inspecting C<$0> when the App::Cmd object is
  instantiated, so it's probably correct, but doing weird things with App::Cmd
  could lead to weird values from these methods.
  
  If the program was run like this:
  
    knight!rjbs$ ~/bin/rpg dice 3d6
  
  Then the methods return:
  
    arg0      - rpg
    full_arg0 - /Users/rjbs/bin/rpg
  
  These values are captured when the App::Cmd object is created, so it is safe to
  assign to C<$0> later.
  
  =head2 prepare_command
  
    my ($cmd, $opt, @args) = $app->prepare_command(@ARGV);
  
  This method will load the plugin for the requested command, use its options to
  parse the command line arguments, and eventually return everything necessary to
  actually execute the command.
  
  =head2 default_command
  
  This method returns the name of the command to run if none is given on the
  command line.  The default default is "help"
  
  =head2 execute_command
  
    $app->execute_command($cmd, \%opt, @args);
  
  This method will invoke C<validate_args> and then C<run> on C<$cmd>.
  
  =head2 plugin_search_path
  
  This method returns the plugin_search_path as set.  The default implementation,
  if called on "YourApp::Cmd" will return "YourApp::Cmd::Command"
  
  This is a method because it's fun to override it with, for example:
  
    use constant plugin_search_path => __PACKAGE__;
  
  =head2 allow_any_unambiguous_abbrev
  
  If this method returns true (which, by default, it does I<not>), then any
  unambiguous abbreviation for a registered command name will be allowed as a
  means to use that command.  For example, given the following commands:
  
    reticulate
    reload
    rasterize
  
  Then the user could use C<ret> for C<reticulate> or C<ra> for C<rasterize> and
  so on.
  
  =head2 global_options
  
    if ($cmd->app->global_options->{verbose}) { ... }
  
  This method returns the running application's global options as a hashref.  If
  there are no options specified, an empty hashref is returend.
  
  =head2 set_global_options
  
    $app->set_global_options(\%opt);
  
  This method sets the global options.
  
  =head2 command_names
  
    my @names = $cmd->command_names;
  
  This returns the commands names which the App::Cmd object will handle.
  
  =head2 command_plugins
  
    my @plugins = $cmd->command_plugins;
  
  This method returns the package names of the plugins that implement the
  App::Cmd object's commands.
  
  =head2 plugin_for
  
    my $plugin = $cmd->plugin_for($command);
  
  This method returns the plugin (module) for the given command.  If no plugin
  implements the command, it returns false.
  
  =head2 get_command
  
    my ($command_name, $opt, @args) = $app->get_command(@args);
  
  Process arguments and into a command name and (optional) global options.
  
  =head2 usage
  
    print $self->app->usage->text;
  
  Returns the usage object for the global options.
  
  =head2 usage_desc
  
  The top level usage line. Looks something like
  
    "yourapp [options] <command>"
  
  =head2 global_opt_spec
  
  Returns an empty list. Can be overridden for pre-dispatch option processing.
  This is useful for flags like --verbose.
  
  =head2 usage_error
  
    $self->usage_error("Something's wrong!");
  
  Used to die with nice usage output, during C<validate_args>.
  
  =head1 TODO
  
  =over 4
  
  =item *
  
  publish and bring in Log::Speak (simple quiet/verbose output)
  
  =item *
  
  publish and use our internal enhanced describe_options
  
  =item *
  
  publish and use our improved simple input routines
  
  =back
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2010 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
APP_CMD

$fatpacked{"App/Cmd/ArgProcessor.pm"} = <<'APP_CMD_ARGPROCESSOR';
  use strict;
  use warnings;
  
  package App::Cmd::ArgProcessor;
  BEGIN {
    $App::Cmd::ArgProcessor::VERSION = '0.310';
  }
  # ABSTRACT: App::Cmd-specific wrapper for Getopt::Long::Descriptive
  
  sub _process_args {
    my ($class, $args, @params) = @_;
    local @ARGV = @$args;
  
    require Getopt::Long::Descriptive;
    Getopt::Long::Descriptive->VERSION(0.084);
  
    my ($opt, $usage) = Getopt::Long::Descriptive::describe_options(@params);
  
    return (
      $opt,
      [ @ARGV ], # whatever remained
      usage => $usage,
    );
  }
  
  1;
  
  __END__
  =pod
  
  =head1 NAME
  
  App::Cmd::ArgProcessor - App::Cmd-specific wrapper for Getopt::Long::Descriptive
  
  =head1 VERSION
  
  version 0.310
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2010 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
APP_CMD_ARGPROCESSOR

$fatpacked{"App/Cmd/Command.pm"} = <<'APP_CMD_COMMAND';
  use strict;
  use warnings;
  
  package App::Cmd::Command;
  BEGIN {
    $App::Cmd::Command::VERSION = '0.310';
  }
  use App::Cmd::ArgProcessor;
  BEGIN { our @ISA = 'App::Cmd::ArgProcessor' };
  
  # ABSTRACT: a base class for App::Cmd commands
  
  use Carp ();
  
  
  sub prepare {
    my ($class, $app, @args) = @_;
  
    my ($opt, $args, %fields)
      = $class->_process_args(\@args, $class->_option_processing_params($app));
  
    return (
      $class->new({ app => $app, %fields }),
      $opt,
      @$args,
    );
  }
  
  sub _option_processing_params {
    my ($class, @args) = @_;
  
    return (
      $class->usage_desc(@args),
      $class->opt_spec(@args),
    );
  }
  
  
  sub new {
    my ($class, $arg) = @_;
    bless $arg => $class;
  }
  
  
  sub execute {
    my $class = shift;
  
    if (my $run = $class->can('run')) {
      warn "App::Cmd::Command subclasses should implement ->execute not ->run"
        if $ENV{HARNESS_ACTIVE};
  
      return $class->$run(@_);
    }
  
    Carp::croak ref($class) . " does not implement mandatory method 'execute'\n";
  }
  
  
  sub app { $_[0]->{app}; }
  
  
  sub usage { $_[0]->{usage}; }
  
  
  sub command_names {
    # from UNIVERSAL::moniker
    (ref( $_[0] ) || $_[0]) =~ /([^:]+)$/;
    return lc $1;
  }
  
  
  sub usage_desc {
    my ($self) = @_;
  
    my ($command) = $self->command_names;
    return "%c $command %o"
  }
  
  
  sub opt_spec {
    return;
  }
  
  
  sub validate_args { }
  
  
  sub usage_error {
    my ( $self, $error ) = @_;
    die "Error: $error\nUsage: " . $self->_usage_text;
  }
  
  sub _usage_text {
    my ($self) = @_;
    local $@;
    join "\n", eval { $self->app->_usage_text }, eval { $self->usage->text };
  }
  
  
  # stolen from ExtUtils::MakeMaker
  sub abstract {
    my ($class) = @_;
    $class = ref $class if ref $class;
  
    my $result;
  
    (my $pm_file = $class) =~ s!::!/!g;
    $pm_file .= '.pm';
    $pm_file = $INC{$pm_file};
    open my $fh, "<", $pm_file or return "(unknown)";
  
    local $/ = "\n";
    my $inpod;
  
    while (local $_ = <$fh>) {
      $inpod = /^=cut/ ? !$inpod : $inpod || /^=(?!cut)/; # =cut toggles, it doesn't end :-/
  
      next unless $inpod;
      chomp;
      next unless /^(?:$class\s-\s)(.*)/;
      $result = $1;
      last;
    }
    return $result || "(unknown)";
  }
  
  
  sub description { '' }
  
  1;
  
  __END__
  =pod
  
  =head1 NAME
  
  App::Cmd::Command - a base class for App::Cmd commands
  
  =head1 VERSION
  
  version 0.310
  
  =head1 METHODS
  
  =head2 prepare
  
    my ($cmd, $opt, $args) = $class->prepare($app, @args);
  
  This method is the primary way in which App::Cmd::Command objects are built.
  Given the remaining command line arguments meant for the command, it returns
  the Command object, parsed options (as a hashref), and remaining arguments (as
  an arrayref).
  
  In the usage above, C<$app> is the App::Cmd object that is invoking the
  command.
  
  =head2 new
  
  This returns a new instance of the command plugin.  Probably only C<prepare>
  should use this.
  
  =head2 execute
  
  =head2 app
  
  This method returns the App::Cmd object into which this command is plugged.
  
  =head2 usage
  
  This method returns the usage object for this command.  (See
  L<Getopt::Long::Descriptive>).
  
  =head2 command_names
  
  This method returns a list of command names handled by this plugin.  If this
  method is not overridden by a App::Cmd::Command subclass, it will return the
  last part of the plugin's package name, converted to lowercase.
  
  For example, YourApp::Cmd::Command::Init will, by default, handle the command
  "init"
  
  =head2 usage_desc
  
  This method should be overridden to provide a usage string.  (This is the first
  argument passed to C<describe_options> from Getopt::Long::Descriptive.)
  
  If not overridden, it returns "%c COMMAND %o";  COMMAND is the first item in
  the result of the C<command_names> method.
  
  =head2 opt_spec
  
  This method should be overridden to provide option specifications.  (This is
  list of arguments passed to C<describe_options> from Getopt::Long::Descriptive,
  after the first.)
  
  If not overridden, it returns an empty list.
  
  =head2 validate_args
  
    $command_plugin->validate_args(\%opt, \@args);
  
  This method is passed a hashref of command line options (as processed by
  Getopt::Long::Descriptive) and an arrayref of leftover arguments.  It may throw
  an exception (preferably by calling C<usage_error>, below) if they are invalid,
  or it may do nothing to allow processing to continue.
  
  =head2 usage_error
  
    $self->usage_error("This command must not be run by root!");
  
  This method should be called to die with human-friendly usage output, during
  C<validate_args>.
  
  =head2 abstract
  
  This method returns a short description of the command's purpose.  If this
  method is not overridden, it will return the abstract from the module's POD.
  If it can't find the abstract, it will return the string "(unknown")
  
  =head2 description
  
  This method should be overridden to provide full option description. It
  is used by the help command.
  
  If not overridden, it returns an empty string.
  
  =for Pod::Coverage run
  
    $command_plugin->execute(\%opt, \@args);
  
  This method does whatever it is the command should do!  It is passed a hash
  reference of the parsed command-line options and an array reference of left
  over arguments.
  
  If no C<execute> method is defined, it will try to call C<run> -- but it will
  warn about this behavior during testing, to remind you to fix the method name!
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2010 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
APP_CMD_COMMAND

$fatpacked{"App/Cmd/Command/commands.pm"} = <<'APP_CMD_COMMAND_COMMANDS';
  use strict;
  use warnings;
  
  package App::Cmd::Command::commands;
  BEGIN {
    $App::Cmd::Command::commands::VERSION = '0.310';
  }
  use App::Cmd::Command;
  BEGIN { our @ISA = 'App::Cmd::Command' };
  
  # ABSTRACT: list the application's commands
  
  
  sub execute {
    my ($self) = @_;
  
    local $@;
    eval { print $self->app->_usage_text . "\n" };
  
    print "Available commands:\n\n";
  
    my @primary_commands =
      map { ($_->command_names)[0] } 
      $self->app->command_plugins;
  
    my @cmd_groups = $self->sort_commands(@primary_commands);
  
    my $fmt_width = 0;
    for (@primary_commands) { $fmt_width = length if length > $fmt_width }
    $fmt_width += 2; # pretty
  
    foreach my $cmd_set (@cmd_groups) {
      for my $command (@$cmd_set) {
        my $abstract = $self->app->plugin_for($command)->abstract;
        printf "%${fmt_width}s: %s\n", $command, $abstract;
      }
      print "\n";
    }
  }
  
  
  sub sort_commands {
    my ($self, @commands) = @_;
  
    my $float = qr/^(?:help|commands)$/;
  
    my @head = sort grep { $_ =~ $float } @commands;
    my @tail = sort grep { $_ !~ $float } @commands;
  
    return (\@head, \@tail);
  }
  
  sub description {
  "This command will list all of commands available and their abstracts.\n";
  }
  
  
  1;
  
  __END__
  =pod
  
  =head1 NAME
  
  App::Cmd::Command::commands - list the application's commands
  
  =head1 VERSION
  
  version 0.310
  
  =head1 DESCRIPTION
  
  This command plugin implements a "commands" command.  This command will list
  all of an App::Cmd's commands and their abstracts.
  
  =head1 METHODS
  
  =head2 execute
  
  This is the command's primary method and raison d'etre.  It prints the
  application's usage text (if any) followed by a sorted listing of the
  application's commands and their abstracts.
  
  The commands are printed in sorted groups (created by C<sort_commands>); each
  group is set off by blank lines.
  
  =head2 C<sort_commands>
  
    my @sorted = $cmd->sort_commands(@unsorted);
  
  This method orders the list of commands into sets which it returns as a list of
  arrayrefs.
  
  By default, the first group is for the "help" and "commands" commands, and all
  other commands are in the second group.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2010 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
APP_CMD_COMMAND_COMMANDS

$fatpacked{"App/Cmd/Command/help.pm"} = <<'APP_CMD_COMMAND_HELP';
  use strict;
  use warnings;
  
  package App::Cmd::Command::help;
  BEGIN {
    $App::Cmd::Command::help::VERSION = '0.310';
  }
  use App::Cmd::Command;
  BEGIN { our @ISA = 'App::Cmd::Command'; }
  
  # ABSTRACT: display a command's help screen
  
  
  sub command_names { qw/help --help -h -?/ }
  
  sub description {
  "This command will either list all of the application commands and their
  abstracts, or display the usage screen for a subcommand with its
  description.\n"
  }
  
  sub execute {
    my ($self, $opts, $args) = @_;
  
    if (!@$args) {
      my $usage = $self->app->usage->text;
      my $command = $0;
  
      # chars normally used to describe options
      my $opt_descriptor_chars = qr/[\[\]<>\(\)]/;
  
      if ($usage =~ /^(.+?) \s* (?: $opt_descriptor_chars | $ )/x) {
        # try to match subdispatchers too
        $command = $1;
      }
      
      # evil hack ;-)
      bless
        $self->app->{usage} = sub { return "$command help <command>\n" }
        => "Getopt::Long::Descriptive::Usage";
  
      $self->app->execute_command( $self->app->_prepare_command("commands") );
    } else {
      my ($cmd, $opt, $args) = $self->app->prepare_command(@$args);
  
      local $@;
      my $desc = $cmd->description;
      $desc = "\n$desc" if length $desc;
  
      my $ut = join "\n",
        eval { $cmd->usage->leader_text },
        $desc,
        eval { $cmd->usage->option_text };
  
      print $ut;
    }
  }
  
  1;
  
  __END__
  =pod
  
  =head1 NAME
  
  App::Cmd::Command::help - display a command's help screen
  
  =head1 VERSION
  
  version 0.310
  
  =head1 DESCRIPTION
  
  This command plugin implements a "help" command.  This command will either list
  all of an App::Cmd's commands and their abstracts, or display the usage screen
  for a subcommand with its description.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2010 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
APP_CMD_COMMAND_HELP

$fatpacked{"App/Cmd/Plugin.pm"} = <<'APP_CMD_PLUGIN';
  use strict;
  use warnings;
  package App::Cmd::Plugin;
  BEGIN {
    $App::Cmd::Plugin::VERSION = '0.310';
  }
  # ABSTRACT: a plugin for App::Cmd commands
  
  sub _faux_curried_method {
    my ($class, $name, $arg) = @_;
  
    return sub {
      my $cmd = $App::Cmd::active_cmd;
      $class->$name($cmd, @_);
    }
  }
  
  1;
  
  __END__
  =pod
  
  =head1 NAME
  
  App::Cmd::Plugin - a plugin for App::Cmd commands
  
  =head1 VERSION
  
  version 0.310
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2010 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
APP_CMD_PLUGIN

$fatpacked{"App/Cmd/Setup.pm"} = <<'APP_CMD_SETUP';
  use strict;
  use warnings;
  package App::Cmd::Setup;
  BEGIN {
    $App::Cmd::Setup::VERSION = '0.310';
  }
  # ABSTRACT: helper for setting up App::Cmd classes
  
  
  use App::Cmd ();
  use App::Cmd::Command ();
  use App::Cmd::Plugin ();
  use Carp ();
  use Data::OptList ();
  use String::RewritePrefix ();
  
  # 0.06 is needed for load_optional_class
  use Class::Load 0.06 qw();
  
  use Sub::Exporter -setup => {
    -as     => '_import',
    exports => [ qw(foo) ],
    collectors => [
      -app     => \'_make_app_class',
      -command => \'_make_command_class',
      -plugin  => \'_make_plugin_class',
    ],
  };
  
  sub import {
    goto &_import;
  }
  
  sub _app_base_class { 'App::Cmd' }
  
  sub _make_app_class {
    my ($self, $val, $data) = @_;
    my $into = $data->{into};
  
    $val ||= {};
    Carp::confess "invalid argument to -app setup"
      if grep { $_ ne 'plugins' } keys %$val;
  
    Carp::confess "app setup requested on App::Cmd subclass $into"
      if $into->isa('App::Cmd');
  
    $self->_make_x_isa_y($into, $self->_app_base_class);
  
    if ( ! Class::Load::load_optional_class( $into->_default_command_base ) ) {
      my $base = $self->_command_base_class;
      Sub::Install::install_sub({
        code => sub { $base },
        into => $into,
        as   => '_default_command_base',
      });
    }
  
    # TODO Check this is right. -- kentnl, 2010-12
    #
    #  my $want_plugin_base = $self->_plugin_base_class;
    my $want_plugin_base = 'App::Cmd::Plugin';
  
    my @plugins;
    for my $plugin (@{ $val->{plugins} || [] }) {
      $plugin = String::RewritePrefix->rewrite(
        {
          ''  => 'App::Cmd::Plugin::',
          '=' => ''
        },
        $plugin,
      );
      Class::Load::load_class( $plugin );
      unless( $plugin->isa( $want_plugin_base ) ){
          die "$plugin is not a " . $want_plugin_base;
      }
      push @plugins, $plugin;
    }
  
    Sub::Install::install_sub({
      code => sub { @plugins },
      into => $into,
      as   => '_plugin_plugins',
    });
  
    return 1;
  }
  
  sub _command_base_class { 'App::Cmd::Command' }
  
  sub _make_command_class {
    my ($self, $val, $data) = @_;
    my $into = $data->{into};
  
    Carp::confess "command setup requested on App::Cmd::Command subclass $into"
      if $into->isa('App::Cmd::Command');
  
    $self->_make_x_isa_y($into, $self->_command_base_class);
  
    return 1;
  }
  
  sub _make_x_isa_y {
    my ($self, $x, $y) = @_;
  
    no strict 'refs';
    push @{"$x\::ISA"}, $y;
  }
  
  sub _plugin_base_class { 'App::Cmd::Plugin' }
  sub _make_plugin_class {
    my ($self, $val, $data) = @_;
    my $into = $data->{into};
  
    Carp::confess "plugin setup requested on App::Cmd::Plugin subclass $into"
      if $into->isa('App::Cmd::Plugin');
  
    Carp::confess "plugin setup requires plugin configuration" unless $val;
  
    $self->_make_x_isa_y($into, $self->_plugin_base_class);
  
    # In this special case, exporting everything by default is the sensible thing
    # to do. -- rjbs, 2008-03-31
    $val->{groups} = [ default => [ -all ] ] unless $val->{groups};
  
    my @exports;
    for my $pair (@{ Data::OptList::mkopt($val->{exports}) }) {
      push @exports, $pair->[0], ($pair->[1] || \'_faux_curried_method');
    }
  
    $val->{exports} = \@exports;
  
    Sub::Exporter::setup_exporter({
      %$val,
      into => $into,
      as   => 'import_from_plugin',
    });
  
    return 1;
  }
  
  1;
  
  __END__
  =pod
  
  =head1 NAME
  
  App::Cmd::Setup - helper for setting up App::Cmd classes
  
  =head1 VERSION
  
  version 0.310
  
  =head1 OVERVIEW
  
  App::Cmd::Setup is a helper library, used to set up base classes that will be
  used as part of an App::Cmd program.  For the most part you should refer to
  L<the tutorial|App::Cmd::Tutorial> for how you should use this library.
  
  This class is useful in three scenarios:
  
  =over 4
  
  =item when writing your App::Cmd subclass
  
  Instead of writing:
  
    package MyApp;
    use base 'App::Cmd';
  
  ...you can write:
  
    package MyApp;
    use App::Cmd::Setup -app;
  
  The benefits of doing this are mostly minor, and relate to sanity-checking your
  class.  The significant benefit is that this form allows you to specify
  plugins, as in:
  
    package MyApp;
    use App::Cmd::Setup -app => { plugins => [ 'Prompt' ] };
  
  Plugins are described in L<App::Cmd::Tutorial> and L<App::Cmd::Plugin>.
  
  =item when writing abstract base classes for commands
  
  That is: when you write a subclass of L<App::Cmd::Command> that is intended for
  other commands to use as their base class, you should use App::Cmd::Setup.  For
  example, if you want all the commands in MyApp to inherit from MyApp::Command,
  you may want to write that package like this:
  
    package MyApp::Command;
    use App::Cmd::Setup -command;
  
  Do not confuse this with the way you will write specific commands:
  
    package MyApp::Command::mycmd;
    use MyApp -command;
  
  Again, this form mostly performs some validation and setup behind the scenes
  for you.  You can use C<L<base>> if you prefer.
  
  =item when writing App::Cmd plugins
  
  L<App::Cmd::Plugin> is a mechanism that allows an App::Cmd class to inject code
  into all its command classes, providing them with utility routines.
  
  To write a plugin, you must use App::Cmd::Setup.  As seen above, you must also
  use App::Cmd::Setup to set up your App::Cmd subclass if you wish to consume
  plugins.
  
  For more information on writing plugins, see L<App::Cmd::Manual> and
  L<App::Cmd::Plugin>.
  
  =back
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2010 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
APP_CMD_SETUP

$fatpacked{"App/Cmd/Simple.pm"} = <<'APP_CMD_SIMPLE';
  use strict;
  use warnings;
  
  package App::Cmd::Simple;
  BEGIN {
    $App::Cmd::Simple::VERSION = '0.310';
  }
  use App::Cmd::Command;
  BEGIN { our @ISA = 'App::Cmd::Command' }
  
  # ABSTRACT: a helper for building one-command App::Cmd applications
  
  use App::Cmd;
  use Sub::Install;
  
  
  # The idea here is that the user will someday replace "Simple" in his ISA with
  # "Command" and then write a standard App::Cmd package.  To make that possible,
  # we produce a behind-the-scenes App::Cmd object when the user says 'use
  # MyApp::Simple' and redirect MyApp::Simple->run to that.
  my $i;
  BEGIN { $i = 0 }
  
  sub import {
    my ($class) = @_;
    return if $class eq __PACKAGE__;
  
    # This signals that something has already set the target up.
    return $class if $class->_cmd_pkg;
  
    my $core_execute = App::Cmd::Command->can('execute');
    my $our_execute  = $class->can('execute');
    Carp::confess(
      "App::Cmd::Simple subclasses must implement ->execute, not ->run"
    ) unless $our_execute and $our_execute != $core_execute;
  
    # I doubt the $i will ever be needed, but let's start paranoid.
    my $generated_name = join('::', $class, '_App_Cmd', $i++);
  
    {
      no strict 'refs';
      *{$generated_name . '::ISA'} = [ 'App::Cmd' ];
    }
  
    Sub::Install::install_sub({
      into => $class,
      as   => '_cmd_pkg',
      code => sub { $generated_name },
    });
  
    Sub::Install::install_sub({
      into => $generated_name,
      as   => '_command',
      code => sub { { only => $class } },
    });
  
    Sub::Install::install_sub({
      into => $generated_name,
      as   => 'default_command',
      code => sub { 'only' },
    });
  
    Sub::Install::install_sub({
      into => $generated_name,
      as   => '_cmd_from_args',
      code => sub {
        my ($self, $args) = @_;
  
        return ('only', $args);
      },
    });
  
    Sub::Install::install_sub({
      into => $class,
      as   => 'run',
      code => sub {
        $generated_name->new({
          no_help_plugin     => 1,
          no_commands_plugin => 1,
        })->run(@_);
      }
    });
  
    return $class;
  }
  
  sub usage_desc {
    return "%c %o"
  }
  
  sub _cmd_pkg { }
  
  
  1;
  
  __END__
  =pod
  
  =head1 NAME
  
  App::Cmd::Simple - a helper for building one-command App::Cmd applications
  
  =head1 VERSION
  
  version 0.310
  
  =head1 SYNOPSIS
  
  in F<simplecmd>:
  
    use YourApp::Cmd;
    Your::Cmd->run;
  
  in F<YourApp/Cmd.pm>:
  
    package YourApp::Cmd;
    use base qw(App::Cmd::Simple);
  
    sub opt_spec {
      return (
        [ "blortex|X",  "use the blortex algorithm" ],
        [ "recheck|r",  "recheck all results"       ],
      );
    }
  
    sub validate_args {
      my ($self, $opt, $args) = @_;
  
      # no args allowed but options!
      $self->usage_error("No args allowed") if @$args;
    }
  
    sub execute {
      my ($self, $opt, $args) = @_;
  
      my $result = $opt->{blortex} ? blortex() : blort();
  
      recheck($result) if $opt->{recheck};
  
      print $result;
    }
  
  and, finally, at the command line:
  
    knight!rjbs$ simplecmd --recheck
  
    All blorts successful.
  
  =head1 SUBCLASSING
  
  When writing a subclass of App::Cmd:Simple, there are only a few methods that
  you might want to implement.  They behave just like the same-named methods in
  App::Cmd.
  
  =head2 opt_spec
  
  This method should be overridden to provide option specifications.  (This is
  list of arguments passed to C<describe_options> from Getopt::Long::Descriptive,
  after the first.)
  
  If not overridden, it returns an empty list.
  
  =head2 validate_args
  
    $cmd->validate_args(\%opt, \@args);
  
  This method is passed a hashref of command line options (as processed by
  Getopt::Long::Descriptive) and an arrayref of leftover arguments.  It may throw
  an exception (preferably by calling C<usage_error>) if they are invalid, or it
  may do nothing to allow processing to continue.
  
  =head2 execute
  
    Your::App::Cmd::Simple->execute(\%opt, \@args);
  
  This method does whatever it is the command should do!  It is passed a hash
  reference of the parsed command-line options and an array reference of left
  over arguments.
  
  =head1 WARNINGS
  
  B<This should be considered experimental!>  Although it is probably not going
  to change much, don't build your business model around it yet, okay?
  
  App::Cmd::Simple is not rich in black magic, but it does do some somewhat
  gnarly things to make an App::Cmd::Simple look as much like an
  App::Cmd::Command as possible.  This means that you can't deviate too much from
  the sort of thing shown in the synopsis as you might like.  If you're doing
  something other than writing a fairly simple command, and you want to screw
  around with the App::Cmd-iness of your program, Simple might not be the best
  choice.
  
  B<One specific warning...>  if you are writing a program with the
  App::Cmd::Simple class embedded in it, you B<must> call import on the class.
  That's how things work.  You can just do this:
  
    YourApp::Cmd->import->run;
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2010 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
APP_CMD_SIMPLE

$fatpacked{"App/Cmd/Subdispatch.pm"} = <<'APP_CMD_SUBDISPATCH';
  use strict;
  use warnings;
  
  package App::Cmd::Subdispatch;
  BEGIN {
    $App::Cmd::Subdispatch::VERSION = '0.310';
  }
  
  use App::Cmd;
  use App::Cmd::Command;
  BEGIN { our @ISA = qw(App::Cmd::Command App::Cmd) } 
  
  # ABSTRACT: an App::Cmd::Command that is also an App::Cmd
  
  
  sub new {
  	my ($inv, $fields, @args) = @_;
  	if (ref $inv) {
  		@{ $inv }{ keys %$fields } = values %$fields;
  		return $inv;
  	} else {
  		$inv->SUPER::new($fields, @args);
  	}
  }
  
  
  sub prepare {
  	my ($class, $app, @args) = @_;
  
  	my $self = $class->new({ app => $app });
  
  	my ($subcommand, $opt, @sub_args) = $self->get_command(@args);
  
    $self->set_global_options($opt);
  
  	if (defined $subcommand) {
      return $self->_prepare_command($subcommand, $opt, @sub_args);
    } else {
      if (@args) {
        return $self->_bad_command(undef, $opt, @sub_args);
      } else {
        return $self->prepare_default_command($opt, @sub_args);
      }
    }
  }
  
  sub _plugin_prepare {
    my ($self, $plugin, @args) = @_;
    return $plugin->prepare($self->choose_parent_app($self->app, $plugin), @args);
  }
  
  
  sub app { $_[0]{app} }
  
  
  sub choose_parent_app {
  	my ( $self, $app, $plugin ) = @_;
  
  	if (
      $plugin->isa("App::Cmd::Command::commands")
      or $plugin->isa("App::Cmd::Command::help")
      or scalar keys %{ $self->global_options }
    ) {
  		return $self;
  	} else {
  		return $app;
  	}
  }
  
  1;
  
  __END__
  =pod
  
  =head1 NAME
  
  App::Cmd::Subdispatch - an App::Cmd::Command that is also an App::Cmd
  
  =head1 VERSION
  
  version 0.310
  
  =head1 METHODS
  
  =head2 new
  
  A hackish new that allows us to have an Command instance before they normally
  exist.
  
  =head2 prepare
  
    my $subcmd = $subdispatch->prepare($app, @args);
  
  An overridden version of L<App::Cmd::Command/prepare> that performs a new
  dispatch cycle.
  
  =head2 app
  
    $subdispatch->app;
  
  This method returns the application that this subdispatch is a command of.
  
  =head2 choose_parent_app
  
    $subcmd->prepare(
      $subdispatch->choose_parent_app($app, $opt, $plugin),
      @$args
    );
  
  A method that chooses whether the parent app or the subdispatch is going to be
  C<< $cmd->app >>.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2010 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
APP_CMD_SUBDISPATCH

$fatpacked{"App/Cmd/Subdispatch/DashedStyle.pm"} = <<'APP_CMD_SUBDISPATCH_DASHEDSTYLE';
  use strict;
  use warnings;
  
  package App::Cmd::Subdispatch::DashedStyle;
  BEGIN {
    $App::Cmd::Subdispatch::DashedStyle::VERSION = '0.310';
  }
  use App::Cmd::Subdispatch;
  BEGIN { our @ISA = 'App::Cmd::Subdispatch' };
  
  # ABSTRACT: "app cmd --subcmd" style subdispatching
  
  
  sub get_command {
  	my ($self, @args) = @_;
  
  	my (undef, $opt, @sub_args)
      = $self->App::Cmd::Command::prepare($self->app, @args);
  
  	if (my $cmd = delete $opt->{subcommand}) {
  		delete $opt->{$cmd}; # useless boolean
  		return ($cmd, $opt, @sub_args);
  	} else {
      return (undef, $opt, @sub_args);
    }
  }
  
  
  sub prepare_default_command {
    my ( $self, $opt, @args ) = @_;
    $self->_prepare_command( "help" );
  }
  
  
  sub opt_spec {
  	my ($self, $app) = @_;
  
  	my $subcommands = $self->_command;
  	my %plugins = map {
  		$_ => [ $_->command_names ],
  	} values %$subcommands;
  
  	foreach my $opt_spec (values %plugins) {
  		$opt_spec = join("|", grep { /^\w/ } @$opt_spec);
  	}
  
  	my @subcommands = map { [ $plugins{$_} =>  $_->abstract ] } keys %plugins;
  
  	return (
  		[ subcommand => hidden => { one_of => \@subcommands } ],
  		$self->global_opt_spec($app),
  		{ getopt_conf => [ 'pass_through' ] },
  	);
  }
  
  1;
  
  __END__
  =pod
  
  =head1 NAME
  
  App::Cmd::Subdispatch::DashedStyle - "app cmd --subcmd" style subdispatching
  
  =head1 VERSION
  
  version 0.310
  
  =head1 METHODS
  
  =head2 get_command
  
    my ($subcommand, $opt, $args) = $subdispatch->get_command(@args)
  
  A version of get_command that chooses commands as options in the following
  style:
  
    mytool mycommand --mysubcommand
  
  =head2 opt_spec
  
  A version of C<opt_spec> that calculates the getopt specification from the
  subcommands.
  
  =for Pod::Coverage prepare_default_command
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2010 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
APP_CMD_SUBDISPATCH_DASHEDSTYLE

$fatpacked{"App/Cmd/Tester.pm"} = <<'APP_CMD_TESTER';
  use strict;
  use warnings;
  package App::Cmd::Tester;
  BEGIN {
    $App::Cmd::Tester::VERSION = '0.310';
  }
  
  # ABSTRACT: for capturing the result of running an app
  
  
  use Sub::Exporter::Util qw(curry_method);
  use Sub::Exporter -setup => {
    exports => { test_app => curry_method },
    groups  => { default  => [ qw(test_app) ] },
  };
  
  our $TEST_IN_PROGRESS;
  BEGIN {
    *CORE::GLOBAL::exit = sub {
      return CORE::exit(@_) unless $TEST_IN_PROGRESS;
      App::Cmd::Tester::Exited->throw($_[0]);
    };
  }
  
  
  sub result_class { 'App::Cmd::Tester::Result' }
  
  sub test_app {
    my ($class, $app, $argv) = @_;
  
    require IO::TieCombine;
    my $hub = IO::TieCombine->new;
  
    my $stdout = tie local *STDOUT, $hub, 'stdout';
    my $stderr = tie local *STDERR, $hub, 'stderr';
  
    my $run_rv;
  
    $app = $app->new unless ref($app) or $app->isa('App::Cmd::Simple');
  
    my $ok = eval {
      local $TEST_IN_PROGRESS = 1;
      local @ARGV = @$argv;
      $run_rv = $app->run;
      1;
    };
  
    my $error = $ok ? undef : $@;
  
    my $exit_code = defined $error ? ((0+$!)||-1) : 0;
  
    if ($error and eval { $error->isa('App::Cmd::Tester::Exited') }) {
      $exit_code = $$error;
    }
  
    $class->result_class->new({
      app    => $app,
      stdout => $hub->slot_contents('stdout'),
      stderr => $hub->slot_contents('stderr'),
      output => $hub->combined_contents,
      error  => $error,
      run_rv => $run_rv,
      exit_code => $exit_code
    });
  }
  
  {
    package App::Cmd::Tester::Result;
  BEGIN {
    $App::Cmd::Tester::Result::VERSION = '0.310';
  }
  
    sub new {
      my ($class, $arg) = @_;
      bless $arg => $class;
    }
  
    for my $attr (qw(app stdout stderr output error run_rv exit_code)) {
      Sub::Install::install_sub({
        code => sub { $_[0]->{$attr} },
        as   => $attr,
      });
    }
  }
  
  {
    package App::Cmd::Tester::Exited;
  BEGIN {
    $App::Cmd::Tester::Exited::VERSION = '0.310';
  }
    sub throw {
      my ($class, $code) = @_;
      my $self = (bless \$code => $class);
      die $self;
    }
  }
  
  1;
  
  __END__
  =pod
  
  =head1 NAME
  
  App::Cmd::Tester - for capturing the result of running an app
  
  =head1 VERSION
  
  version 0.310
  
  =head1 SYNOPSIS
  
    use Test::More tests => 4;
    use App::Cmd::Tester;
  
    use YourApp;
  
    my $result = test_app(YourApp => [ qw(command --opt value) ]);
  
    like($result->stdout, qr/expected output/, 'printed what we expected');
  
    is($result->stderr, '', 'nothing sent to sderr');
  
    is($result->error, undef, 'threw no exceptions');
  
    my $result = test_app(YourApp => [ qw(command --opt value --quiet) ]);
  
    is($result->output, '', 'absolutely no output with --quiet');
  
  =head1 DESCRIPTION
  
  One of the reasons that user-executed programs are so often poorly tested is
  that they are hard to test.  App::Cmd::Tester is one of the tools App-Cmd
  provides to help make it easy to test App::Cmd-based programs.
  
  It provides one routine: test_app.
  
  =head1 METHODS
  
  =head2 test_app
  
  B<Note>: while C<test_app> is a method, it is by default exported as a
  subroutine into the namespace that uses App::Cmd::Tester.  In other words: you
  probably don't need to think about this as a method unless you want to subclass
  App::Cmd::Tester.
  
    my $result = test_app($app_class => \@argv_contents);
  
  This will locally set C<@ARGV> to simulate command line arguments, and will
  then call the C<run> method on the given application class (or application).
  Output to the standard output and standard error filehandles  will be captured.
  
  C<$result> is an App::Cmd::Tester::Result object, which has methods to access
  the following data:
  
    stdout - the output sent to stdout
    stderr - the output sent to stderr
    output - the combined output of stdout and stderr
    error  - the exception thrown by running the application, or undef
    run_rv - the return value of the run method (generally irrelevant)
    exit_code - the numeric exit code that would've been issued (0 is 'okay')
  
  =for Pod::Coverage result_class
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2010 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
APP_CMD_TESTER

$fatpacked{"App/Mist.pm"} = <<'APP_MIST';
  package App::Mist;
  
  use strict;
  use warnings;
  
  use Carp;
  use Scalar::Util qw/looks_like_number blessed/;
  
  use App::Cmd::Setup -app;
  
  use App::Mist::Command::build;
  use App::Mist::Command::index;
  
  1;
APP_MIST

$fatpacked{"App/Mist/Command.pm"} = <<'APP_MIST_COMMAND';
  # package App::Mist::Command;
  #
  # use strict;
  # use warnings;
  #
  # use Carp;
  # use Scalar::Util qw/looks_like_number blessed/;
  #
  # use App::Cmd::Setup -command;
  #
  # sub opt_spec {
  #   my ( $class, $app ) = @_;
  #   return (
  #     [ 'help' => "This usage screen" ],
  #     # $class->options($app),
  #   )
  # }
  #
  # sub validate_args {
  #   my ( $self, $opt, $args ) = @_;
  #   die $self->_usage_text if $opt->{help};
  #   $self->validate( $opt, $args );
  # }
  #
  # 1;
APP_MIST_COMMAND

$fatpacked{"App/Mist/Command/build.pm"} = <<'APP_MIST_COMMAND_BUILD';
  package App::Mist::Command::build;
  
  use strict;
  use warnings;
  
  use App::Mist -command;
  
  use Try::Tiny;
  use File::Which;
  use File::Find::Upwards;
  use Path::Class qw/dir/;
  use Cwd;
  
  sub execute {
    my ( $self, $opt, $args ) = @_;
  
    my $cpanm = which( 'cpanm' )
      or die "cpanm not found";
  
    do $cpanm;
    require App::cpanminus;
  
    die "cpanm v$App::cpanminus::VERSION is too old, v1.4 needed"
      if $App::cpanminus::VERSION < 1.4;
  
    my $home = find_containing_dir_upwards( 'dist.ini' )
      or die "Can't find project root";
  
    my $mpan      = $home->subdir( $ENV{MIST_DIST_DIR}  || 'mpan-dist' );
    my $mpan_conf = $mpan->subdir( 'mist' );
    my $local_lib = $home->subdir( $ENV{MIST_LOCAL_LIB} || 'perl5' );
  
    my $dist_prepend = $mpan_conf->file(qw/ 01.prepend.txt /);
    my $dist_notest  = $mpan_conf->file(qw/ 02.notest.txt /);
  
    chdir $home->stringify;
    $mpan_conf->mkpath;
    $_->touch for grep{ not -r $_->stringify } $dist_prepend, $dist_notest;
  
    try {
  
      open my $in,  "<", "$cpanm" or die $!;
      open my $out, ">", "mist-install.tmp" or die $!;
  
      print STDERR "Generating mist-installer\n";
  
      while (<$in>) {
          print $out $_;
          last if /# END OF FATPACK CODE\s*$/;
      }
  
      my $slurp_file = sub{
        my $file = shift;
        my @lines;
        printf STDERR "Reading: %s\n", $file;
  
        return () unless -f -r $file->stringify;
        my $fh = $file->openr;
        @lines = readline $fh;
        chomp for @lines;
        @lines = grep{ $_ } @lines;
        return @lines;
      };
  
      my @prepend = $slurp_file->( $dist_prepend );
      my @notest  = $slurp_file->( $dist_notest );
  
      my @prereqs = qx{ dzil listdeps };
      chomp for @prereqs;
      @prereqs = grep{ $_ } @prereqs;
  
      my @args = (
        $mpan->relative( $home ),
        $local_lib->relative( $home ),
        @prepend ? sprintf( qq{'%s'}, join qq{',\n    '}, @prepend ) : '',
        @notest  ? sprintf( qq{'%s'}, join qq{',\n    '}, @notest  ) : '',
        @prereqs ? sprintf( qq{'%s'}, join qq{',\n    '}, @prereqs ) : '',
      );
  
      printf $out <<'INSTALLER', @args;
  
  use App::cpanminus::script;
  use FindBin qw/$RealBin/;
  use Path::Class qw/file dir/;
  
  my $mpan      = dir( $RealBin, '%s' );
  my $local_lib = dir( $RealBin, '%s' );
  
  sub run_cpanm {
    my $app       = App::cpanminus::script->new;
    my @options   = (
      "--quiet",
      "--local-lib-contained=${local_lib}",
      "--mirror=file://${mpan}",
      '--mirror-only',
    );
  
    # use Data::Dumper::Concise;
    # printf STDERR '@Options: %%s%%s', Dumper( \@options ), "\n";
  
    $app->parse_options( @options, @_ );
    $app->doit or exit(1);
  }
  
  unless (caller) {
    my @prepend = (
      %s
    );
    my @notest  = (
      %s
    );
    my @prereqs = (
      %s
    );
  
    run_cpanm( @prepend ) if @prepend;
    run_cpanm( '--installdeps', @notest ) if @notest;
    run_cpanm( '--notest', @notest ) if @notest;
    run_cpanm( @prereqs ) if @prereqs;
  }
  
  INSTALLER
  
      close $out;
  
      unlink "mist-install";
      rename "mist-install.tmp", "mist-install";
      chmod 0755, "mist-install";
  
    } catch {
      warn "$_\n";
    } finally {
  
      unlink "mist-install.tmp"
  
    };
  
  }
  
  
  
  1;
APP_MIST_COMMAND_BUILD

$fatpacked{"App/Mist/Command/index.pm"} = <<'APP_MIST_COMMAND_INDEX';
  package App::Mist::Command::index;
  
  use strict;
  use warnings;
  
  use App::Mist -command;
  
  use CPAN::ParseDistribution;
  use CPAN::DistnameInfo;
  use CPAN::PackageDetails;
  
  use File::Find;
  use File::Find::Upwards;
  use Path::Class qw/dir file/;
  use Cwd;
  
  sub execute {
    my ( $self, $opt, $args ) = @_;
  
    my $home = find_containing_dir_upwards( 'dist.ini' )
      or die "Can't find project root";
  
    my $mpan      = $home->subdir( $ENV{MIST_DIST_DIR}  || 'mpan-dist' );
    my $local_lib = $home->subdir( $ENV{MIST_LOCAL_LIB} || 'perl5' );
  
    chdir $home->stringify;
  
    my $mpan_modules = $mpan->subdir( 'modules' );
    my $mpan_authors = $mpan->subdir( 'authors' );
  
    my $package_details;
  
    my $index_local_lib = sub {
      return unless -r -f;
  
      my $d = CPAN::DistnameInfo->new( $_ );
  
      warn "$0: skipping $_\n" and return
        unless $d->distvname;
  
      my $mpath = file( $d->pathname )->relative( $mpan_authors->subdir('id'));
  
      printf "Indexing %s ...\n", $mpath;
  
      my $dist    = CPAN::ParseDistribution->new( $d->pathname );
      my $modules = $dist->modules;
  
      {
        ( my $dist_pkg = $dist->dist ) =~ s/-/::/g;
        $package_details->add_entry(
          package_name => $dist_pkg,
          version      => $dist->distversion,
          path         => $mpath,
        );
      }
  
      while ( my ( $pkg, $version ) = each %$modules ) {
        $package_details->add_entry(
          package_name => $pkg,
          version      => $version,
          path         => $mpath,
        );
      }
    };
  
    $package_details = CPAN::PackageDetails->new(
      file         => "02packages.details.txt",
      url          => "http://example.com/MyCPAN/modules/02packages.details.txt",
      description  => "Package names for my private CPAN",
      columns      => "package name, version, path",
      intended_for => "My private CPAN",
      written_by   => "$0 using CPAN::PackageDetails $CPAN::PackageDetails::VERSION",
      allow_packages_only_once => 0,
    );
  
    chdir $mpan->stringify;
    find(
      { wanted => $index_local_lib, no_chdir => 1 },
      $mpan_authors->stringify
    );
  
    $mpan_modules->mkpath;
    $package_details->write_file(
      $mpan_modules->file( '02packages.details.txt.gz' )->stringify
    );
  
  }
  
  1;
APP_MIST_COMMAND_INDEX

$fatpacked{"App/Mist/Command/install.pm"} = <<'APP_MIST_COMMAND_INSTALL';
  package App::Mist::Command::install;
  
  use strict;
  use warnings;
  
  use App::Mist -command;
  
  use Try::Tiny;
  use File::Which;
  use File::Find::Upwards;
  use Path::Class qw/dir/;
  use Cwd;
  
  use File::Temp qw/ tempfile tempdir /;
  
  
  sub execute {
    my ( $self, $opt, $args ) = @_;
  
    die "No module to install" unless $args and ref $args eq 'ARRAY' and @$args;
  
    my $cpanm = which( 'cpanm' )
      or die "cpanm not found";
  
    do $cpanm;
    require App::cpanminus::script;
  
    my $home = find_containing_dir_upwards( 'dist.ini' )
      or die "Can't find project root";
  
    my $workspace = tempdir( CLEANUP => 1 );
    my $mpan      = $home->subdir( $ENV{MIST_DIST_DIR}  || 'mpan-dist' );
    my $mpan_conf = $mpan->subdir( 'mist' );
    my $local_lib = $home->subdir( $ENV{MIST_LOCAL_LIB} || 'perl5' );
  
    my @options   = (
      "--quiet",
      "--local-lib-contained=${workspace}",
      "--mirror=file://${mpan}",
      "--mirror=http://search.cpan.org/CPAN",
      "--save-dists=${mpan}",
    );
  
    my $app1 = App::cpanminus::script->new;
    $app1->parse_options( @options, '--installdeps', @$args );
    $app1->doit or exit(1);
  
    my $app2 = App::cpanminus::script->new;
    $app2->parse_options( @options, '--reinstall', @$args );
    $app2->doit or exit(1);
  
  }
  
  
  
  1;
APP_MIST_COMMAND_INSTALL

$fatpacked{"Archive/Zip.pm"} = <<'ARCHIVE_ZIP';
  package Archive::Zip;
  
  use strict;
  BEGIN {
      require 5.003_96;
  }
  use UNIVERSAL           ();
  use Carp                ();
  use Cwd                 ();
  use IO::File            ();
  use IO::Seekable        ();
  use Compress::Raw::Zlib ();
  use File::Spec          ();
  use File::Temp          ();
  use FileHandle          ();
  
  use vars qw( $VERSION @ISA );
  BEGIN {
      $VERSION = '1.30';
  
      require Exporter;
      @ISA = qw( Exporter );
  }
  
  use vars qw( $ChunkSize $ErrorHandler );
  BEGIN {
      # This is the size we'll try to read, write, and (de)compress.
      # You could set it to something different if you had lots of memory
      # and needed more speed.
      $ChunkSize ||= 32768;
  
      $ErrorHandler = \&Carp::carp;
  }
  
  # BEGIN block is necessary here so that other modules can use the constants.
  use vars qw( @EXPORT_OK %EXPORT_TAGS );
  BEGIN {
      @EXPORT_OK   = ('computeCRC32');
      %EXPORT_TAGS = (
          CONSTANTS => [ qw(
              FA_MSDOS
              FA_UNIX
              GPBF_ENCRYPTED_MASK
              GPBF_DEFLATING_COMPRESSION_MASK
              GPBF_HAS_DATA_DESCRIPTOR_MASK
              COMPRESSION_STORED
              COMPRESSION_DEFLATED
              COMPRESSION_LEVEL_NONE
              COMPRESSION_LEVEL_DEFAULT
              COMPRESSION_LEVEL_FASTEST
              COMPRESSION_LEVEL_BEST_COMPRESSION
              IFA_TEXT_FILE_MASK
              IFA_TEXT_FILE
              IFA_BINARY_FILE
              ) ],
  
          MISC_CONSTANTS => [ qw(
              FA_AMIGA
              FA_VAX_VMS
              FA_VM_CMS
              FA_ATARI_ST
              FA_OS2_HPFS
              FA_MACINTOSH
              FA_Z_SYSTEM
              FA_CPM
              FA_TOPS20
              FA_WINDOWS_NTFS
              FA_QDOS
              FA_ACORN
              FA_VFAT
              FA_MVS
              FA_BEOS
              FA_TANDEM
              FA_THEOS
              GPBF_IMPLODING_8K_SLIDING_DICTIONARY_MASK
              GPBF_IMPLODING_3_SHANNON_FANO_TREES_MASK
              GPBF_IS_COMPRESSED_PATCHED_DATA_MASK
              COMPRESSION_SHRUNK
              DEFLATING_COMPRESSION_NORMAL
              DEFLATING_COMPRESSION_MAXIMUM
              DEFLATING_COMPRESSION_FAST
              DEFLATING_COMPRESSION_SUPER_FAST
              COMPRESSION_REDUCED_1
              COMPRESSION_REDUCED_2
              COMPRESSION_REDUCED_3
              COMPRESSION_REDUCED_4
              COMPRESSION_IMPLODED
              COMPRESSION_TOKENIZED
              COMPRESSION_DEFLATED_ENHANCED
              COMPRESSION_PKWARE_DATA_COMPRESSION_LIBRARY_IMPLODED
              ) ],
  
          ERROR_CODES => [ qw(
              AZ_OK
              AZ_STREAM_END
              AZ_ERROR
              AZ_FORMAT_ERROR
              AZ_IO_ERROR
              ) ],
  
          # For Internal Use Only
          PKZIP_CONSTANTS => [ qw(
              SIGNATURE_FORMAT
              SIGNATURE_LENGTH
              LOCAL_FILE_HEADER_SIGNATURE
              LOCAL_FILE_HEADER_FORMAT
              LOCAL_FILE_HEADER_LENGTH
              CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE
              DATA_DESCRIPTOR_FORMAT
              DATA_DESCRIPTOR_LENGTH
              DATA_DESCRIPTOR_SIGNATURE
              DATA_DESCRIPTOR_FORMAT_NO_SIG
              DATA_DESCRIPTOR_LENGTH_NO_SIG
              CENTRAL_DIRECTORY_FILE_HEADER_FORMAT
              CENTRAL_DIRECTORY_FILE_HEADER_LENGTH
              END_OF_CENTRAL_DIRECTORY_SIGNATURE
              END_OF_CENTRAL_DIRECTORY_SIGNATURE_STRING
              END_OF_CENTRAL_DIRECTORY_FORMAT
              END_OF_CENTRAL_DIRECTORY_LENGTH
              ) ],
  
          # For Internal Use Only
          UTILITY_METHODS => [ qw(
              _error
              _printError
              _ioError
              _formatError
              _subclassResponsibility
              _binmode
              _isSeekable
              _newFileHandle
              _readSignature
              _asZipDirName
              ) ],
      );
  
      # Add all the constant names and error code names to @EXPORT_OK
      Exporter::export_ok_tags( qw(
          CONSTANTS
          ERROR_CODES
          PKZIP_CONSTANTS
          UTILITY_METHODS
          MISC_CONSTANTS
          ) );
  
  }
  
  # Error codes
  use constant AZ_OK           => 0;
  use constant AZ_STREAM_END   => 1;
  use constant AZ_ERROR        => 2;
  use constant AZ_FORMAT_ERROR => 3;
  use constant AZ_IO_ERROR     => 4;
  
  # File types
  # Values of Archive::Zip::Member->fileAttributeFormat()
  
  use constant FA_MSDOS        => 0;
  use constant FA_AMIGA        => 1;
  use constant FA_VAX_VMS      => 2;
  use constant FA_UNIX         => 3;
  use constant FA_VM_CMS       => 4;
  use constant FA_ATARI_ST     => 5;
  use constant FA_OS2_HPFS     => 6;
  use constant FA_MACINTOSH    => 7;
  use constant FA_Z_SYSTEM     => 8;
  use constant FA_CPM          => 9;
  use constant FA_TOPS20       => 10;
  use constant FA_WINDOWS_NTFS => 11;
  use constant FA_QDOS         => 12;
  use constant FA_ACORN        => 13;
  use constant FA_VFAT         => 14;
  use constant FA_MVS          => 15;
  use constant FA_BEOS         => 16;
  use constant FA_TANDEM       => 17;
  use constant FA_THEOS        => 18;
  
  # general-purpose bit flag masks
  # Found in Archive::Zip::Member->bitFlag()
  
  use constant GPBF_ENCRYPTED_MASK             => 1 << 0;
  use constant GPBF_DEFLATING_COMPRESSION_MASK => 3 << 1;
  use constant GPBF_HAS_DATA_DESCRIPTOR_MASK   => 1 << 3;
  
  # deflating compression types, if compressionMethod == COMPRESSION_DEFLATED
  # ( Archive::Zip::Member->bitFlag() & GPBF_DEFLATING_COMPRESSION_MASK )
  
  use constant DEFLATING_COMPRESSION_NORMAL     => 0 << 1;
  use constant DEFLATING_COMPRESSION_MAXIMUM    => 1 << 1;
  use constant DEFLATING_COMPRESSION_FAST       => 2 << 1;
  use constant DEFLATING_COMPRESSION_SUPER_FAST => 3 << 1;
  
  # compression method
  
  # these two are the only ones supported in this module
  use constant COMPRESSION_STORED                 => 0; # file is stored (no compression)
  use constant COMPRESSION_DEFLATED               => 8; # file is Deflated
  use constant COMPRESSION_LEVEL_NONE             => 0;
  use constant COMPRESSION_LEVEL_DEFAULT          => -1;
  use constant COMPRESSION_LEVEL_FASTEST          => 1;
  use constant COMPRESSION_LEVEL_BEST_COMPRESSION => 9;
  
  # internal file attribute bits
  # Found in Archive::Zip::Member::internalFileAttributes()
  
  use constant IFA_TEXT_FILE_MASK => 1;
  use constant IFA_TEXT_FILE      => 1;
  use constant IFA_BINARY_FILE    => 0;
  
  # PKZIP file format miscellaneous constants (for internal use only)
  use constant SIGNATURE_FORMAT   => "V";
  use constant SIGNATURE_LENGTH   => 4;
  
  # these lengths are without the signature.
  use constant LOCAL_FILE_HEADER_SIGNATURE   => 0x04034b50;
  use constant LOCAL_FILE_HEADER_FORMAT      => "v3 V4 v2";
  use constant LOCAL_FILE_HEADER_LENGTH      => 26;
  
  # PKZIP docs don't mention the signature, but Info-Zip writes it.
  use constant DATA_DESCRIPTOR_SIGNATURE     => 0x08074b50;
  use constant DATA_DESCRIPTOR_FORMAT        => "V3";
  use constant DATA_DESCRIPTOR_LENGTH        => 12;
  
  # but the signature is apparently optional.
  use constant DATA_DESCRIPTOR_FORMAT_NO_SIG => "V2";
  use constant DATA_DESCRIPTOR_LENGTH_NO_SIG => 8;
  
  use constant CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE  => 0x02014b50;
  use constant CENTRAL_DIRECTORY_FILE_HEADER_FORMAT     => "C2 v3 V4 v5 V2";
  use constant CENTRAL_DIRECTORY_FILE_HEADER_LENGTH     => 42;
  
  use constant END_OF_CENTRAL_DIRECTORY_SIGNATURE        => 0x06054b50;
  use constant END_OF_CENTRAL_DIRECTORY_SIGNATURE_STRING =>
      pack( "V", END_OF_CENTRAL_DIRECTORY_SIGNATURE );
  use constant END_OF_CENTRAL_DIRECTORY_FORMAT           => "v4 V2 v";
  use constant END_OF_CENTRAL_DIRECTORY_LENGTH           => 18;
  
  use constant GPBF_IMPLODING_8K_SLIDING_DICTIONARY_MASK => 1 << 1;
  use constant GPBF_IMPLODING_3_SHANNON_FANO_TREES_MASK  => 1 << 2;
  use constant GPBF_IS_COMPRESSED_PATCHED_DATA_MASK      => 1 << 5;
  
  # the rest of these are not supported in this module
  use constant COMPRESSION_SHRUNK    => 1;    # file is Shrunk
  use constant COMPRESSION_REDUCED_1 => 2;    # file is Reduced CF=1
  use constant COMPRESSION_REDUCED_2 => 3;    # file is Reduced CF=2
  use constant COMPRESSION_REDUCED_3 => 4;    # file is Reduced CF=3
  use constant COMPRESSION_REDUCED_4 => 5;    # file is Reduced CF=4
  use constant COMPRESSION_IMPLODED  => 6;    # file is Imploded
  use constant COMPRESSION_TOKENIZED => 7;    # reserved for Tokenizing compr.
  use constant COMPRESSION_DEFLATED_ENHANCED => 9;   # reserved for enh. Deflating
  use constant COMPRESSION_PKWARE_DATA_COMPRESSION_LIBRARY_IMPLODED => 10;
  
  # Load the various required classes
  require Archive::Zip::Archive;
  require Archive::Zip::Member;
  require Archive::Zip::FileMember;
  require Archive::Zip::DirectoryMember;
  require Archive::Zip::ZipFileMember;
  require Archive::Zip::NewFileMember;
  require Archive::Zip::StringMember;
  
  use constant ZIPARCHIVECLASS => 'Archive::Zip::Archive';
  use constant ZIPMEMBERCLASS  => 'Archive::Zip::Member';
  
  # Convenience functions
  
  sub _ISA ($$) {
      # Can't rely on Scalar::Util, so use the next best way
      local $@;
      !! eval { ref $_[0] and $_[0]->isa($_[1]) };
  }
  
  sub _CAN ($$) {
      local $@;
      !! eval { ref $_[0] and $_[0]->can($_[1]) };
  }
  
  
  
  
  
  #####################################################################
  # Methods
  
  sub new {
      my $class = shift;
      return $class->ZIPARCHIVECLASS->new(@_);
  }
  
  sub computeCRC32 {
      my ( $data, $crc );
  
      if ( ref( $_[0] ) eq 'HASH' ) {
          $data = $_[0]->{string};
          $crc  = $_[0]->{checksum};
      }
      else {
          $data = shift;
          $data = shift if ref($data);
          $crc  = shift;
      }
  
  	return Compress::Raw::Zlib::crc32( $data, $crc );
  }
  
  # Report or change chunk size used for reading and writing.
  # Also sets Zlib's default buffer size (eventually).
  sub setChunkSize {
      shift if ref( $_[0] ) eq 'Archive::Zip::Archive';
      my $chunkSize = ( ref( $_[0] ) eq 'HASH' ) ? shift->{chunkSize} : shift;
      my $oldChunkSize = $Archive::Zip::ChunkSize;
      $Archive::Zip::ChunkSize = $chunkSize if ($chunkSize);
      return $oldChunkSize;
  }
  
  sub chunkSize {
      return $Archive::Zip::ChunkSize;
  }
  
  sub setErrorHandler {
      my $errorHandler = ( ref( $_[0] ) eq 'HASH' ) ? shift->{subroutine} : shift;
      $errorHandler = \&Carp::carp unless defined($errorHandler);
      my $oldErrorHandler = $Archive::Zip::ErrorHandler;
      $Archive::Zip::ErrorHandler = $errorHandler;
      return $oldErrorHandler;
  }
  
  
  
  
  
  ######################################################################
  # Private utility functions (not methods).
  
  sub _printError {
      my $string = join ( ' ', @_, "\n" );
      my $oldCarpLevel = $Carp::CarpLevel;
      $Carp::CarpLevel += 2;
      &{$ErrorHandler} ($string);
      $Carp::CarpLevel = $oldCarpLevel;
  }
  
  # This is called on format errors.
  sub _formatError {
      shift if ref( $_[0] );
      _printError( 'format error:', @_ );
      return AZ_FORMAT_ERROR;
  }
  
  # This is called on IO errors.
  sub _ioError {
      shift if ref( $_[0] );
      _printError( 'IO error:', @_, ':', $! );
      return AZ_IO_ERROR;
  }
  
  # This is called on generic errors.
  sub _error {
      shift if ref( $_[0] );
      _printError( 'error:', @_ );
      return AZ_ERROR;
  }
  
  # Called when a subclass should have implemented
  # something but didn't
  sub _subclassResponsibility {
      Carp::croak("subclass Responsibility\n");
  }
  
  # Try to set the given file handle or object into binary mode.
  sub _binmode {
      my $fh = shift;
      return _CAN( $fh, 'binmode' ) ? $fh->binmode() : binmode($fh);
  }
  
  # Attempt to guess whether file handle is seekable.
  # Because of problems with Windows, this only returns true when
  # the file handle is a real file.  
  sub _isSeekable {
      my $fh = shift;
      return 0 unless ref $fh;
      if ( _ISA($fh, 'IO::Scalar') ) {
          # IO::Scalar objects are brokenly-seekable
          return 0;
      }
      if ( _ISA($fh, 'IO::String') ) {
          return 1;
      }
      if ( _ISA($fh, 'IO::Seekable') ) {
          # Unfortunately, some things like FileHandle objects
          # return true for Seekable, but AREN'T!!!!!
          if ( _ISA($fh, 'FileHandle') ) {
              return 0;
          } else {
              return 1;
          }
      }
      if ( _CAN($fh, 'stat') ) {
          return -f $fh;
      }
      return (
          _CAN($fh, 'seek') and _CAN($fh, 'tell')
          ) ? 1 : 0;
  }
  
  # Print to the filehandle, while making sure the pesky Perl special global 
  # variables don't interfere.
  sub _print
  {
      my ($self, $fh, @data) = @_;
  
      local $\;
  
      return $fh->print(@data);
  }
  
  # Return an opened IO::Handle
  # my ( $status, fh ) = _newFileHandle( 'fileName', 'w' );
  # Can take a filename, file handle, or ref to GLOB
  # Or, if given something that is a ref but not an IO::Handle,
  # passes back the same thing.
  sub _newFileHandle {
      my $fd     = shift;
      my $status = 1;
      my $handle;
  
      if ( ref($fd) ) {
          if ( _ISA($fd, 'IO::Scalar') or _ISA($fd, 'IO::String') ) {
              $handle = $fd;
          } elsif ( _ISA($fd, 'IO::Handle') or ref($fd) eq 'GLOB' ) {
              $handle = IO::File->new;
              $status = $handle->fdopen( $fd, @_ );
          } else {
              $handle = $fd;
          }
      } else {
          $handle = IO::File->new;
          $status = $handle->open( $fd, @_ );
      }
  
      return ( $status, $handle );
  }
  
  # Returns next signature from given file handle, leaves
  # file handle positioned afterwards.
  # In list context, returns ($status, $signature)
  # ( $status, $signature) = _readSignature( $fh, $fileName );
  
  sub _readSignature {
      my $fh                = shift;
      my $fileName          = shift;
      my $expectedSignature = shift;    # optional
  
      my $signatureData;
      my $bytesRead = $fh->read( $signatureData, SIGNATURE_LENGTH );
      if ( $bytesRead != SIGNATURE_LENGTH ) {
          return _ioError("reading header signature");
      }
      my $signature = unpack( SIGNATURE_FORMAT, $signatureData );
      my $status    = AZ_OK;
  
      # compare with expected signature, if any, or any known signature.
      if ( ( defined($expectedSignature) && $signature != $expectedSignature )
          || ( !defined($expectedSignature)
              && $signature != CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE
              && $signature != LOCAL_FILE_HEADER_SIGNATURE
              && $signature != END_OF_CENTRAL_DIRECTORY_SIGNATURE
              && $signature != DATA_DESCRIPTOR_SIGNATURE ) )
      {
          my $errmsg = sprintf( "bad signature: 0x%08x", $signature );
          if ( _isSeekable($fh) )
          {
              $errmsg .=
                sprintf( " at offset %d", $fh->tell() - SIGNATURE_LENGTH );
          }
  
          $status = _formatError("$errmsg in file $fileName");
      }
  
      return ( $status, $signature );
  }
  
  # Utility method to make and open a temp file.
  # Will create $temp_dir if it doesn't exist.
  # Returns file handle and name:
  #
  # my ($fh, $name) = Archive::Zip::tempFile();
  # my ($fh, $name) = Archive::Zip::tempFile('mytempdir');
  #
  
  sub tempFile {
      my $dir = ( ref( $_[0] ) eq 'HASH' ) ? shift->{tempDir} : shift;
      my ( $fh, $filename ) = File::Temp::tempfile(
          SUFFIX => '.zip',
          UNLINK => 0,        # we will delete it!
          $dir ? ( DIR => $dir ) : ()
      );
      return ( undef, undef ) unless $fh;
      my ( $status, $newfh ) = _newFileHandle( $fh, 'w+' );
      return ( $newfh, $filename );
  }
  
  # Return the normalized directory name as used in a zip file (path
  # separators become slashes, etc.). 
  # Will translate internal slashes in path components (i.e. on Macs) to
  # underscores.  Discards volume names.
  # When $forceDir is set, returns paths with trailing slashes (or arrays
  # with trailing blank members).
  #
  # If third argument is a reference, returns volume information there.
  #
  # input         output
  # .             ('.')   '.'
  # ./a           ('a')   a
  # ./a/b         ('a','b')   a/b
  # ./a/b/        ('a','b')   a/b
  # a/b/          ('a','b')   a/b
  # /a/b/         ('','a','b')    /a/b
  # c:\a\b\c.doc  ('','a','b','c.doc')    /a/b/c.doc      # on Windoze
  # "i/o maps:whatever"   ('i_o maps', 'whatever')  "i_o maps/whatever"   # on Macs
  sub _asZipDirName    
  {
      my $name      = shift;
      my $forceDir  = shift;
      my $volReturn = shift;
      my ( $volume, $directories, $file ) =
        File::Spec->splitpath( File::Spec->canonpath($name), $forceDir );
      $$volReturn = $volume if ( ref($volReturn) );
      my @dirs = map { $_ =~ s{/}{_}g; $_ } File::Spec->splitdir($directories);
      if ( @dirs > 0 ) { pop (@dirs) unless $dirs[-1] }   # remove empty component
      push ( @dirs, defined($file) ? $file : '' );
      #return wantarray ? @dirs : join ( '/', @dirs );
      return join ( '/', @dirs );
  }
  
  # Return an absolute local name for a zip name.
  # Assume a directory if zip name has trailing slash.
  # Takes an optional volume name in FS format (like 'a:').
  #
  sub _asLocalName    
  {
      my $name   = shift;    # zip format
      my $volume = shift;
      $volume = '' unless defined($volume);    # local FS format
  
      my @paths = split ( /\//, $name );
      my $filename = pop (@paths);
      $filename = '' unless defined($filename);
      my $localDirs = @paths ? File::Spec->catdir(@paths) : '';
      my $localName = File::Spec->catpath( $volume, $localDirs, $filename );
      unless ( $volume ) {
          $localName = File::Spec->rel2abs( $localName, Cwd::getcwd() );
      }
      return $localName;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Archive::Zip - Provide an interface to ZIP archive files.
  
  =head1 SYNOPSIS
  
     # Create a Zip file
     use Archive::Zip qw( :ERROR_CODES :CONSTANTS );
     my $zip = Archive::Zip->new();
     
     # Add a directory
     my $dir_member = $zip->addDirectory( 'dirname/' );
     
     # Add a file from a string with compression
     my $string_member = $zip->addString( 'This is a test', 'stringMember.txt' );
     $string_member->desiredCompressionMethod( COMPRESSION_DEFLATED );
     
     # Add a file from disk
     my $file_member = $zip->addFile( 'xyz.pl', 'AnotherName.pl' );
     
     # Save the Zip file
     unless ( $zip->writeToFileNamed('someZip.zip') == AZ_OK ) {
         die 'write error';
     }
     
     # Read a Zip file
     my $somezip = Archive::Zip->new();
     unless ( $somezip->read( 'someZip.zip' ) == AZ_OK ) {
         die 'read error';
     }
     
     # Change the compression type for a file in the Zip
     my $member = $somezip->memberNamed( 'stringMember.txt' );
     $member->desiredCompressionMethod( COMPRESSION_STORED );
     unless ( $zip->writeToFileNamed( 'someOtherZip.zip' ) == AZ_OK ) {
         die 'write error';
     }
  
  =head1 DESCRIPTION
  
  The Archive::Zip module allows a Perl program to create, manipulate, read,
  and write Zip archive files.
  
  Zip archives can be created, or you can read from existing zip files.
  
  Once created, they can be written to files, streams, or strings. Members
  can be added, removed, extracted, replaced, rearranged, and enumerated.
  They can also be renamed or have their dates, comments, or other attributes
  queried or modified. Their data can be compressed or uncompressed as needed.
  
  Members can be created from members in existing Zip files, or from existing
  directories, files, or strings.
  
  This module uses the L<Compress::Raw::Zlib> library to read and write the
  compressed streams inside the files.
  
  One can use L<Archive::Zip::MemberRead> to read the zip file archive members
  as if they were files.
  
  =head2 File Naming
  
  Regardless of what your local file system uses for file naming, names in a
  Zip file are in Unix format (I<forward> slashes (/) separating directory
  names, etc.).
  
  C<Archive::Zip> tries to be consistent with file naming conventions, and will
  translate back and forth between native and Zip file names.
  
  However, it can't guess which format names are in. So two rules control what
  kind of file name you must pass various routines:
  
  =over 4
  
  =item Names of files are in local format.
  
  C<File::Spec> and C<File::Basename> are used for various file
  operations. When you're referring to a file on your system, use its
  file naming conventions.
  
  =item Names of archive members are in Unix format.
  
  This applies to every method that refers to an archive member, or
  provides a name for new archive members. The C<extract()> methods
  that can take one or two names will convert from local to zip names
  if you call them with a single name.
  
  =back
  
  =head2 Archive::Zip Object Model
  
  =head2 Overview
  
  Archive::Zip::Archive objects are what you ordinarily deal with.
  These maintain the structure of a zip file, without necessarily
  holding data. When a zip is read from a disk file, the (possibly
  compressed) data still lives in the file, not in memory. Archive
  members hold information about the individual members, but not
  (usually) the actual member data. When the zip is written to a
  (different) file, the member data is compressed or copied as needed.
  It is possible to make archive members whose data is held in a string
  in memory, but this is not done when a zip file is read. Directory
  members don't have any data.
  
  =head2 Inheritance
  
    Exporter
     Archive::Zip                            Common base class, has defs.
         Archive::Zip::Archive               A Zip archive.
         Archive::Zip::Member                Abstract superclass for all members.
             Archive::Zip::StringMember      Member made from a string
             Archive::Zip::FileMember        Member made from an external file
                 Archive::Zip::ZipFileMember Member that lives in a zip file
                 Archive::Zip::NewFileMember Member whose data is in a file
             Archive::Zip::DirectoryMember   Member that is a directory
  
  =head1 EXPORTS
  
  =over 4
  
  =item :CONSTANTS
  
  Exports the following constants:
  
  FA_MSDOS FA_UNIX GPBF_ENCRYPTED_MASK
  GPBF_DEFLATING_COMPRESSION_MASK GPBF_HAS_DATA_DESCRIPTOR_MASK
  COMPRESSION_STORED COMPRESSION_DEFLATED IFA_TEXT_FILE_MASK
  IFA_TEXT_FILE IFA_BINARY_FILE COMPRESSION_LEVEL_NONE
  COMPRESSION_LEVEL_DEFAULT COMPRESSION_LEVEL_FASTEST
  COMPRESSION_LEVEL_BEST_COMPRESSION
  
  =item :MISC_CONSTANTS
  
  Exports the following constants (only necessary for extending the
  module):
  
  FA_AMIGA FA_VAX_VMS FA_VM_CMS FA_ATARI_ST FA_OS2_HPFS
  FA_MACINTOSH FA_Z_SYSTEM FA_CPM FA_WINDOWS_NTFS
  GPBF_IMPLODING_8K_SLIDING_DICTIONARY_MASK
  GPBF_IMPLODING_3_SHANNON_FANO_TREES_MASK
  GPBF_IS_COMPRESSED_PATCHED_DATA_MASK COMPRESSION_SHRUNK
  DEFLATING_COMPRESSION_NORMAL DEFLATING_COMPRESSION_MAXIMUM
  DEFLATING_COMPRESSION_FAST DEFLATING_COMPRESSION_SUPER_FAST
  COMPRESSION_REDUCED_1 COMPRESSION_REDUCED_2 COMPRESSION_REDUCED_3
  COMPRESSION_REDUCED_4 COMPRESSION_IMPLODED COMPRESSION_TOKENIZED
  COMPRESSION_DEFLATED_ENHANCED
  COMPRESSION_PKWARE_DATA_COMPRESSION_LIBRARY_IMPLODED
  
  =item :ERROR_CODES
  
  Explained below. Returned from most methods.
  
  AZ_OK AZ_STREAM_END AZ_ERROR AZ_FORMAT_ERROR AZ_IO_ERROR
  
  =back
  
  =head1 ERROR CODES
  
  Many of the methods in Archive::Zip return error codes. These are implemented
  as inline subroutines, using the C<use constant> pragma. They can be imported
  into your namespace using the C<:ERROR_CODES> tag:
  
    use Archive::Zip qw( :ERROR_CODES );
    
    ...
    
    unless ( $zip->read( 'myfile.zip' ) == AZ_OK ) {
        die "whoops!";
    }
  
  =over 4
  
  =item AZ_OK (0)
  
  Everything is fine.
  
  =item AZ_STREAM_END (1)
  
  The read stream (or central directory) ended normally.
  
  =item AZ_ERROR (2)
  
  There was some generic kind of error.
  
  =item AZ_FORMAT_ERROR (3)
  
  There is a format error in a ZIP file being read.
  
  =item AZ_IO_ERROR (4)
  
  There was an IO error.
  
  =back
  
  =head2 Compression
  
  Archive::Zip allows each member of a ZIP file to be compressed (using the
  Deflate algorithm) or uncompressed.
  
  Other compression algorithms that some versions of ZIP have been able to
  produce are not supported. Each member has two compression methods: the
  one it's stored as (this is always COMPRESSION_STORED for string and external
  file members), and the one you desire for the member in the zip file.
  
  These can be different, of course, so you can make a zip member that is not
  compressed out of one that is, and vice versa.
  
  You can inquire about the current compression and set the desired
  compression method:
  
    my $member = $zip->memberNamed( 'xyz.txt' );
    $member->compressionMethod();    # return current compression
    
    # set to read uncompressed
    $member->desiredCompressionMethod( COMPRESSION_STORED );
    
    # set to read compressed
    $member->desiredCompressionMethod( COMPRESSION_DEFLATED );
  
  There are two different compression methods:
  
  =over 4
  
  =item COMPRESSION_STORED
  
  File is stored (no compression)
  
  =item COMPRESSION_DEFLATED
  
  File is Deflated
  
  =back
  
  =head2 Compression Levels
  
  If a member's desiredCompressionMethod is COMPRESSION_DEFLATED, you
  can choose different compression levels. This choice may affect the
  speed of compression and decompression, as well as the size of the
  compressed member data.
  
    $member->desiredCompressionLevel( 9 );
  
  The levels given can be:
  
  =over 4
  
  =item 0 or COMPRESSION_LEVEL_NONE
  
  This is the same as saying
  
    $member->desiredCompressionMethod( COMPRESSION_STORED );
  
  =item 1 .. 9
  
  1 gives the best speed and worst compression, and 9 gives the
  best compression and worst speed.
  
  =item COMPRESSION_LEVEL_FASTEST
  
  This is a synonym for level 1.
  
  =item COMPRESSION_LEVEL_BEST_COMPRESSION
  
  This is a synonym for level 9.
  
  =item COMPRESSION_LEVEL_DEFAULT
  
  This gives a good compromise between speed and compression,
  and is currently equivalent to 6 (this is in the zlib code).
  This is the level that will be used if not specified.
  
  =back
  
  =head1 Archive::Zip Methods
  
  The Archive::Zip class (and its invisible subclass Archive::Zip::Archive)
  implement generic zip file functionality. Creating a new Archive::Zip object
  actually makes an Archive::Zip::Archive object, but you don't have to worry
  about this unless you're subclassing.
  
  =head2 Constructor
  
  =over 4
  
  =item new( [$fileName] )
  
  Make a new, empty zip archive.
  
      my $zip = Archive::Zip->new();
  
  If an additional argument is passed, new() will call read()
  to read the contents of an archive:
  
      my $zip = Archive::Zip->new( 'xyz.zip' );
  
  If a filename argument is passed and the read fails for any
  reason, new will return undef. For this reason, it may be
  better to call read separately.
  
  =back
  
  =head2 Zip Archive Utility Methods
  
  These Archive::Zip methods may be called as functions or as object
  methods. Do not call them as class methods:
  
      $zip = Archive::Zip->new();
      $crc = Archive::Zip::computeCRC32( 'ghijkl' );    # OK
      $crc = $zip->computeCRC32( 'ghijkl' );            # also OK
      $crc = Archive::Zip->computeCRC32( 'ghijkl' );    # NOT OK
  
  =over 4
  
  =item Archive::Zip::computeCRC32( $string [, $crc] )
  
  This is a utility function that uses the Compress::Raw::Zlib CRC
  routine to compute a CRC-32. You can get the CRC of a string:
  
      $crc = Archive::Zip::computeCRC32( $string );
  
  Or you can compute the running CRC:
  
      $crc = 0;
      $crc = Archive::Zip::computeCRC32( 'abcdef', $crc );
      $crc = Archive::Zip::computeCRC32( 'ghijkl', $crc );
  
  =item Archive::Zip::setChunkSize( $number )
  
  Report or change chunk size used for reading and writing.
  This can make big differences in dealing with large files.
  Currently, this defaults to 32K. This also changes the chunk
  size used for Compress::Raw::Zlib. You must call setChunkSize()
  before reading or writing. This is not exportable, so you
  must call it like:
  
      Archive::Zip::setChunkSize( 4096 );
  
  or as a method on a zip (though this is a global setting).
  Returns old chunk size.
  
  =item Archive::Zip::chunkSize()
  
  Returns the current chunk size:
  
      my $chunkSize = Archive::Zip::chunkSize();
  
  =item Archive::Zip::setErrorHandler( \&subroutine )
  
  Change the subroutine called with error strings. This
  defaults to \&Carp::carp, but you may want to change it to
  get the error strings. This is not exportable, so you must
  call it like:
  
      Archive::Zip::setErrorHandler( \&myErrorHandler );
  
  If myErrorHandler is undef, resets handler to default.
  Returns old error handler. Note that if you call Carp::carp
  or a similar routine or if you're chaining to the default
  error handler from your error handler, you may want to
  increment the number of caller levels that are skipped (do
  not just set it to a number):
  
      $Carp::CarpLevel++;
  
  =item Archive::Zip::tempFile( [$tmpdir] )
  
  Create a uniquely named temp file. It will be returned open
  for read/write. If C<$tmpdir> is given, it is used as the
  name of a directory to create the file in. If not given,
  creates the file using C<File::Spec::tmpdir()>. Generally, you can
  override this choice using the
  
      $ENV{TMPDIR}
  
  environment variable. But see the L<File::Spec|File::Spec>
  documentation for your system. Note that on many systems, if you're
  running in taint mode, then you must make sure that C<$ENV{TMPDIR}> is
  untainted for it to be used.
  Will I<NOT> create C<$tmpdir> if it doesn't exist (this is a change
  from prior versions!). Returns file handle and name:
  
      my ($fh, $name) = Archive::Zip::tempFile();
      my ($fh, $name) = Archive::Zip::tempFile('myTempDir');
      my $fh = Archive::Zip::tempFile();  # if you don't need the name
  
  =back
  
  =head2 Zip Archive Accessors
  
  =over 4
  
  =item members()
  
  Return a copy of the members array
  
      my @members = $zip->members();
  
  =item numberOfMembers()
  
  Return the number of members I have
  
  =item memberNames()
  
  Return a list of the (internal) file names of the zip members
  
  =item memberNamed( $string )
  
  Return ref to member whose filename equals given filename or
  undef. C<$string> must be in Zip (Unix) filename format.
  
  =item membersMatching( $regex )
  
  Return array of members whose filenames match given regular
  expression in list context. Returns number of matching
  members in scalar context.
  
      my @textFileMembers = $zip->membersMatching( '.*\.txt' );
      # or
      my $numberOfTextFiles = $zip->membersMatching( '.*\.txt' );
  
  =item diskNumber()
  
  Return the disk that I start on. Not used for writing zips,
  but might be interesting if you read a zip in. This should be
  0, as Archive::Zip does not handle multi-volume archives.
  
  =item diskNumberWithStartOfCentralDirectory()
  
  Return the disk number that holds the beginning of the
  central directory. Not used for writing zips, but might be
  interesting if you read a zip in. This should be 0, as
  Archive::Zip does not handle multi-volume archives.
  
  =item numberOfCentralDirectoriesOnThisDisk()
  
  Return the number of CD structures in the zipfile last read in.
  Not used for writing zips, but might be interesting if you read a zip
  in.
  
  =item numberOfCentralDirectories()
  
  Return the number of CD structures in the zipfile last read in.
  Not used for writing zips, but might be interesting if you read a zip
  in.
  
  =item centralDirectorySize()
  
  Returns central directory size, as read from an external zip
  file. Not used for writing zips, but might be interesting if
  you read a zip in.
  
  =item centralDirectoryOffsetWRTStartingDiskNumber()
  
  Returns the offset into the zip file where the CD begins. Not
  used for writing zips, but might be interesting if you read a
  zip in.
  
  =item zipfileComment( [$string] )
  
  Get or set the zipfile comment. Returns the old comment.
  
      print $zip->zipfileComment();
      $zip->zipfileComment( 'New Comment' );
  
  =item eocdOffset()
  
  Returns the (unexpected) number of bytes between where the
  EOCD was found and where it expected to be. This is normally
  0, but would be positive if something (a virus, perhaps) had
  added bytes somewhere before the EOCD. Not used for writing
  zips, but might be interesting if you read a zip in. Here is
  an example of how you can diagnose this:
  
    my $zip = Archive::Zip->new('somefile.zip');
    if ($zip->eocdOffset())
    {
      warn "A virus has added ", $zip->eocdOffset, " bytes of garbage\n";
    }
  
  The C<eocdOffset()> is used to adjust the starting position of member
  headers, if necessary.
  
  =item fileName()
  
  Returns the name of the file last read from. If nothing has
  been read yet, returns an empty string; if read from a file
  handle, returns the handle in string form.
  
  =back
  
  =head2 Zip Archive Member Operations
  
  Various operations on a zip file modify members. When a member is
  passed as an argument, you can either use a reference to the member
  itself, or the name of a member. Of course, using the name requires
  that names be unique within a zip (this is not enforced).
  
  =over 4
  
  =item removeMember( $memberOrName )
  
  Remove and return the given member, or match its name and
  remove it. Returns undef if member or name doesn't exist in this
  Zip. No-op if member does not belong to this zip.
  
  =item replaceMember( $memberOrName, $newMember )
  
  Remove and return the given member, or match its name and
  remove it. Replace with new member. Returns undef if member or
  name doesn't exist in this Zip, or if C<$newMember> is undefined.
  
  It is an (undiagnosed) error to provide a C<$newMember> that is a
  member of the zip being modified.
  
      my $member1 = $zip->removeMember( 'xyz' );
      my $member2 = $zip->replaceMember( 'abc', $member1 );
      # now, $member2 (named 'abc') is not in $zip,
      # and $member1 (named 'xyz') is, having taken $member2's place.
  
  =item extractMember( $memberOrName [, $extractedName ] )
  
  Extract the given member, or match its name and extract it.
  Returns undef if member doesn't exist in this Zip. If
  optional second arg is given, use it as the name of the
  extracted member. Otherwise, the internal filename of the
  member is used as the name of the extracted file or
  directory.
  If you pass C<$extractedName>, it should be in the local file
  system's format.
  All necessary directories will be created. Returns C<AZ_OK>
  on success.
  
  =item extractMemberWithoutPaths( $memberOrName [, $extractedName ] )
  
  Extract the given member, or match its name and extract it.
  Does not use path information (extracts into the current
  directory). Returns undef if member doesn't exist in this
  Zip.
  If optional second arg is given, use it as the name of the
  extracted member (its paths will be deleted too). Otherwise,
  the internal filename of the member (minus paths) is used as
  the name of the extracted file or directory. Returns C<AZ_OK>
  on success.
  
  =item addMember( $member )
  
  Append a member (possibly from another zip file) to the zip
  file. Returns the new member. Generally, you will use
  addFile(), addDirectory(), addFileOrDirectory(), addString(),
  or read() to add members.
  
      # Move member named 'abc' to end of zip:
      my $member = $zip->removeMember( 'abc' );
      $zip->addMember( $member );
  
  =item updateMember( $memberOrName, $fileName )
  
  Update a single member from the file or directory named C<$fileName>.
  Returns the (possibly added or updated) member, if any; C<undef> on
  errors.
  The comparison is based on C<lastModTime()> and (in the case of a
  non-directory) the size of the file.
  
  =item addFile( $fileName [, $newName ] )
  
  Append a member whose data comes from an external file,
  returning the member or undef. The member will have its file
  name set to the name of the external file, and its
  desiredCompressionMethod set to COMPRESSION_DEFLATED. The
  file attributes and last modification time will be set from
  the file.
  If the name given does not represent a readable plain file or
  symbolic link, undef will be returned. C<$fileName> must be
  in the format required for the local file system.
  The optional C<$newName> argument sets the internal file name
  to something different than the given $fileName. C<$newName>,
  if given, must be in Zip name format (i.e. Unix).
  The text mode bit will be set if the contents appears to be
  text (as returned by the C<-T> perl operator).
  
  
  I<NOTE> that you shouldn't (generally) use absolute path names
  in zip member names, as this will cause problems with some zip
  tools as well as introduce a security hole and make the zip
  harder to use.
  
  =item addDirectory( $directoryName [, $fileName ] )
  
  
  
  Append a member created from the given directory name. The
  directory name does not have to name an existing directory.
  If the named directory exists, the file modification time and
  permissions are set from the existing directory, otherwise
  they are set to now and permissive default permissions.
  C<$directoryName> must be in local file system format.
  The optional second argument sets the name of the archive
  member (which defaults to C<$directoryName>). If given, it
  must be in Zip (Unix) format.
  Returns the new member.
  
  =item addFileOrDirectory( $name [, $newName ] )
  
  
  
  Append a member from the file or directory named $name. If
  $newName is given, use it for the name of the new member.
  Will add or remove trailing slashes from $newName as needed.
  C<$name> must be in local file system format.
  The optional second argument sets the name of the archive
  member (which defaults to C<$name>). If given, it must be in
  Zip (Unix) format.
  
  =item addString( $stringOrStringRef, $name )
  
  
  
  Append a member created from the given string or string
  reference. The name is given by the second argument.
  Returns the new member. The last modification time will be
  set to now, and the file attributes will be set to permissive
  defaults.
  
      my $member = $zip->addString( 'This is a test', 'test.txt' );
  
  =item contents( $memberOrMemberName [, $newContents ] )
  
  
  
  Returns the uncompressed data for a particular member, or
  undef.
  
      print "xyz.txt contains " . $zip->contents( 'xyz.txt' );
  
  Also can change the contents of a member:
  
      $zip->contents( 'xyz.txt', 'This is the new contents' );
  
  If called expecting an array as the return value, it will include
  the status as the second value in the array.
  
      ($content, $status) = $zip->contents( 'xyz.txt');
  
  =back
  
  =head2 Zip Archive I/O operations
  
  
  A Zip archive can be written to a file or file handle, or read from
  one.
  
  =over 4
  
  =item writeToFileNamed( $fileName )
  
  
  
  Write a zip archive to named file. Returns C<AZ_OK> on
  success.
  
      my $status = $zip->writeToFileNamed( 'xx.zip' );
      die "error somewhere" if $status != AZ_OK;
  
  Note that if you use the same name as an existing zip file
  that you read in, you will clobber ZipFileMembers. So
  instead, write to a different file name, then delete the
  original.
  If you use the C<overwrite()> or C<overwriteAs()> methods, you can
  re-write the original zip in this way.
  C<$fileName> should be a valid file name on your system.
  
  =item writeToFileHandle( $fileHandle [, $seekable] )
  
  Write a zip archive to a file handle. Return AZ_OK on
  success. The optional second arg tells whether or not to try
  to seek backwards to re-write headers. If not provided, it is
  set if the Perl C<-f> test returns true. This could fail on
  some operating systems, though.
  
      my $fh = IO::File->new( 'someFile.zip', 'w' );
      unless ( $zip->writeToFileHandle( $fh ) == AZ_OK ) {
          # error handling
      }
  
  If you pass a file handle that is not seekable (like if
  you're writing to a pipe or a socket), pass a false second
  argument:
  
      my $fh = IO::File->new( '| cat > somefile.zip', 'w' );
      $zip->writeToFileHandle( $fh, 0 );   # fh is not seekable
  
  If this method fails during the write of a member, that
  member and all following it will return false from
  C<wasWritten()>. See writeCentralDirectory() for a way to
  deal with this.
  If you want, you can write data to the file handle before
  passing it to writeToFileHandle(); this could be used (for
  instance) for making self-extracting archives. However, this
  only works reliably when writing to a real file (as opposed
  to STDOUT or some other possible non-file).
  
  See examples/selfex.pl for how to write a self-extracting
  archive.
  
  =item writeCentralDirectory( $fileHandle [, $offset ] )
  
  Writes the central directory structure to the given file
  handle.
  
  Returns AZ_OK on success. If given an $offset, will
  seek to that point before writing. This can be used for
  recovery in cases where writeToFileHandle or writeToFileNamed
  returns an IO error because of running out of space on the
  destination file.
  
  You can truncate the zip by seeking backwards and then writing the
  directory:
  
      my $fh = IO::File->new( 'someFile.zip', 'w' );
          my $retval = $zip->writeToFileHandle( $fh );
      if ( $retval == AZ_IO_ERROR ) {
          my @unwritten = grep { not $_->wasWritten() } $zip->members();
          if (@unwritten) {
              $zip->removeMember( $member ) foreach my $member ( @unwritten );
              $zip->writeCentralDirectory( $fh,
              $unwritten[0]->writeLocalHeaderRelativeOffset());
          }
      }
  
  =item overwriteAs( $newName )
  
  Write the zip to the specified file, as safely as possible.
  This is done by first writing to a temp file, then renaming
  the original if it exists, then renaming the temp file, then
  deleting the renamed original if it exists. Returns AZ_OK if
  successful.
  
  =item overwrite()
  
  Write back to the original zip file. See overwriteAs() above.
  If the zip was not ever read from a file, this generates an
  error.
  
  =item read( $fileName )
  
  Read zipfile headers from a zip file, appending new members.
  Returns C<AZ_OK> or error code.
  
      my $zipFile = Archive::Zip->new();
      my $status = $zipFile->read( '/some/FileName.zip' );
  
  =item readFromFileHandle( $fileHandle, $filename )
  
  Read zipfile headers from an already-opened file handle,
  appending new members. Does not close the file handle.
  Returns C<AZ_OK> or error code. Note that this requires a
  seekable file handle; reading from a stream is not yet
  supported.
  
      my $fh = IO::File->new( '/some/FileName.zip', 'r' );
      my $zip1 = Archive::Zip->new();
      my $status = $zip1->readFromFileHandle( $fh );
      my $zip2 = Archive::Zip->new();
      $status = $zip2->readFromFileHandle( $fh );
  
  =back
  
  =head2 Zip Archive Tree operations
  
  These used to be in Archive::Zip::Tree but got moved into
  Archive::Zip. They enable operation on an entire tree of members or
  files.
  A usage example:
  
    use Archive::Zip;
    my $zip = Archive::Zip->new();
    
    # add all readable files and directories below . as xyz/*
    $zip->addTree( '.', 'xyz' );
    
    # add all readable plain files below /abc as def/*
    $zip->addTree( '/abc', 'def', sub { -f && -r } );
    
    # add all .c files below /tmp as stuff/*
    $zip->addTreeMatching( '/tmp', 'stuff', '\.c$' );
    
    # add all .o files below /tmp as stuff/* if they aren't writable
    $zip->addTreeMatching( '/tmp', 'stuff', '\.o$', sub { ! -w } );
    
    # add all .so files below /tmp that are smaller than 200 bytes as stuff/*
    $zip->addTreeMatching( '/tmp', 'stuff', '\.o$', sub { -s < 200 } );
    
    # and write them into a file
    $zip->writeToFileNamed('xxx.zip');
    
    # now extract the same files into /tmpx
    $zip->extractTree( 'stuff', '/tmpx' );
  
  =over 4
  
  =item $zip->addTree( $root, $dest [,$pred] ) -- Add tree of files to a zip
  
  C<$root> is the root of the tree of files and directories to be
  added. It is a valid directory name on your system. C<$dest> is
  the name for the root in the zip file (undef or blank means
  to use relative pathnames). It is a valid ZIP directory name
  (that is, it uses forward slashes (/) for separating
  directory components). C<$pred> is an optional subroutine
  reference to select files: it is passed the name of the
  prospective file or directory using C<$_>, and if it returns
  true, the file or directory will be included. The default is
  to add all readable files and directories. For instance,
  using
  
    my $pred = sub { /\.txt/ };
    $zip->addTree( '.', '', $pred );
  
  will add all the .txt files in and below the current
  directory, using relative names, and making the names
  identical in the zipfile:
  
    original name           zip member name
    ./xyz                   xyz
    ./a/                    a/
    ./a/b                   a/b
  
  To translate absolute to relative pathnames, just pass them
  in: $zip->addTree( '/c/d', 'a' );
  
    original name           zip member name
    /c/d/xyz                a/xyz
    /c/d/a/                 a/a/
    /c/d/a/b                a/a/b
  
  Returns AZ_OK on success. Note that this will not follow
  symbolic links to directories. Note also that this does not
  check for the validity of filenames.
  
  Note that you generally I<don't> want to make zip archive member names
  absolute.
  
  =item $zip->addTreeMatching( $root, $dest, $pattern [,$pred] )
  
  $root is the root of the tree of files and directories to be
  added $dest is the name for the root in the zip file (undef
  means to use relative pathnames) $pattern is a (non-anchored)
  regular expression for filenames to match $pred is an
  optional subroutine reference to select files: it is passed
  the name of the prospective file or directory in C<$_>, and
  if it returns true, the file or directory will be included.
  The default is to add all readable files and directories. To
  add all files in and below the current dirctory whose names
  end in C<.pl>, and make them extract into a subdirectory
  named C<xyz>, do this:
  
    $zip->addTreeMatching( '.', 'xyz', '\.pl$' )
  
  To add all I<writable> files in and below the dirctory named
  C</abc> whose names end in C<.pl>, and make them extract into
  a subdirectory named C<xyz>, do this:
  
    $zip->addTreeMatching( '/abc', 'xyz', '\.pl$', sub { -w } )
  
  Returns AZ_OK on success. Note that this will not follow
  symbolic links to directories.
  
  =item $zip->updateTree( $root, [ $dest, [ $pred [, $mirror]]] );
  
  
  
  Update a zip file from a directory tree.
  
  C<updateTree()> takes the same arguments as C<addTree()>, but first
  checks to see whether the file or directory already exists in the zip
  file, and whether it has been changed.
  
  If the fourth argument C<$mirror> is true, then delete all my members
  if corresponding files weren't found.
  
  
  Returns an error code or AZ_OK if all is well.
  
  =item $zip->extractTree()
  
  
  
  =item $zip->extractTree( $root )
  
  
  
  =item $zip->extractTree( $root, $dest )
  
  
  
  =item $zip->extractTree( $root, $dest, $volume )
  
  
  
  If you don't give any arguments at all, will extract all the
  files in the zip with their original names.
  
  
  If you supply one argument for C<$root>, C<extractTree> will extract
  all the members whose names start with C<$root> into the current
  directory, stripping off C<$root> first.
  C<$root> is in Zip (Unix) format.
  For instance,
  
    $zip->extractTree( 'a' );
  
  when applied to a zip containing the files:
  a/x a/b/c ax/d/e d/e will extract:
  
  
  a/x as ./x
  
  
  a/b/c as ./b/c
  
  
  If you give two arguments, C<extractTree> extracts all the members
  whose names start with C<$root>. It will translate C<$root> into
  C<$dest> to construct the destination file name.
  C<$root> and C<$dest> are in Zip (Unix) format.
  For instance,
  
     $zip->extractTree( 'a', 'd/e' );
  
  when applied to a zip containing the files:
  a/x a/b/c ax/d/e d/e will extract:
  
  
  a/x to d/e/x
  
  
  a/b/c to d/e/b/c and ignore ax/d/e and d/e
  
  
  If you give three arguments, C<extractTree> extracts all the members
  whose names start with C<$root>. It will translate C<$root> into
  C<$dest> to construct the destination file name, and then it will
  convert to local file system format, using C<$volume> as the name of
  the destination volume.
  
  
  C<$root> and C<$dest> are in Zip (Unix) format.
  
  
  C<$volume> is in local file system format.
  
  
  For instance, under Windows,
  
     $zip->extractTree( 'a', 'd/e', 'f:' );
  
  when applied to a zip containing the files:
  a/x a/b/c ax/d/e d/e will extract:
  
  
  a/x to f:d/e/x
  
  
  a/b/c to f:d/e/b/c and ignore ax/d/e and d/e
  
  
  If you want absolute paths (the prior example used paths relative to
  the current directory on the destination volume, you can specify these
  in C<$dest>:
  
     $zip->extractTree( 'a', '/d/e', 'f:' );
  
  when applied to a zip containing the files:
  a/x a/b/c ax/d/e d/e will extract:
  
  
  a/x to f:\d\e\x
  
  
  a/b/c to f:\d\e\b\c and ignore ax/d/e and d/e
  
  Returns an error code or AZ_OK if everything worked OK.
  
  =back
  
  =head1 MEMBER OPERATIONS
  
  
  =head2 Member Class Methods
  
  
  Several constructors allow you to construct members without adding
  them to a zip archive. These work the same as the addFile(),
  addDirectory(), and addString() zip instance methods described above,
  but they don't add the new members to a zip.
  
  =over 4
  
  =item Archive::Zip::Member->newFromString( $stringOrStringRef [, $fileName] )
  
  
  
  Construct a new member from the given string. Returns undef
  on error.
  
      my $member = Archive::Zip::Member->newFromString( 'This is a test',
                                                   'xyz.txt' );
  
  =item newFromFile( $fileName )
  
  
  
  Construct a new member from the given file. Returns undef on
  error.
  
      my $member = Archive::Zip::Member->newFromFile( 'xyz.txt' );
  
  =item newDirectoryNamed( $directoryName [, $zipname ] )
  
  
  
  Construct a new member from the given directory.
  C<$directoryName> must be a valid name on your file system; it doesn't
  have to exist.
  
  
  If given, C<$zipname> will be the name of the zip member; it must be a
  valid Zip (Unix) name. If not given, it will be converted from
  C<$directoryName>.
  
  
  Returns undef on error.
  
      my $member = Archive::Zip::Member->newDirectoryNamed( 'CVS/' );
  
  =back
  
  =head2 Member Simple accessors
  
  
  These methods get (and/or set) member attribute values.
  
  =over 4
  
  =item versionMadeBy()
  
  
  
  Gets the field from the member header.
  
  =item fileAttributeFormat( [$format] )
  
  
  
  Gets or sets the field from the member header. These are
  C<FA_*> values.
  
  =item versionNeededToExtract()
  
  
  
  Gets the field from the member header.
  
  =item bitFlag()
  
  
  
  Gets the general purpose bit field from the member header.
  This is where the C<GPBF_*> bits live.
  
  =item compressionMethod()
  
  
  
  Returns the member compression method. This is the method
  that is currently being used to compress the member data.
  This will be COMPRESSION_STORED for added string or file
  members, or any of the C<COMPRESSION_*> values for members
  from a zip file. However, this module can only handle members
  whose data is in COMPRESSION_STORED or COMPRESSION_DEFLATED
  format.
  
  =item desiredCompressionMethod( [$method] )
  
  
  
  Get or set the member's C<desiredCompressionMethod>. This is
  the compression method that will be used when the member is
  written. Returns prior desiredCompressionMethod. Only
  COMPRESSION_DEFLATED or COMPRESSION_STORED are valid
  arguments. Changing to COMPRESSION_STORED will change the
  member desiredCompressionLevel to 0; changing to
  COMPRESSION_DEFLATED will change the member
  desiredCompressionLevel to COMPRESSION_LEVEL_DEFAULT.
  
  =item desiredCompressionLevel( [$method] )
  
  
  
  Get or set the member's desiredCompressionLevel This is the
  method that will be used to write. Returns prior
  desiredCompressionLevel. Valid arguments are 0 through 9,
  COMPRESSION_LEVEL_NONE, COMPRESSION_LEVEL_DEFAULT,
  COMPRESSION_LEVEL_BEST_COMPRESSION, and
  COMPRESSION_LEVEL_FASTEST. 0 or COMPRESSION_LEVEL_NONE will
  change the desiredCompressionMethod to COMPRESSION_STORED.
  All other arguments will change the desiredCompressionMethod
  to COMPRESSION_DEFLATED.
  
  =item externalFileName()
  
  
  
  Return the member's external file name, if any, or undef.
  
  =item fileName()
  
  
  
  Get or set the member's internal filename. Returns the
  (possibly new) filename. Names will have backslashes
  converted to forward slashes, and will have multiple
  consecutive slashes converted to single ones.
  
  =item lastModFileDateTime()
  
  
  
  Return the member's last modification date/time stamp in
  MS-DOS format.
  
  =item lastModTime()
  
  
  
  Return the member's last modification date/time stamp,
  converted to unix localtime format.
  
      print "Mod Time: " . scalar( localtime( $member->lastModTime() ) );
  
  =item setLastModFileDateTimeFromUnix()
  
  Set the member's lastModFileDateTime from the given unix
  time.
  
      $member->setLastModFileDateTimeFromUnix( time() );
  
  =item internalFileAttributes()
  
  Return the internal file attributes field from the zip
  header. This is only set for members read from a zip file.
  
  =item externalFileAttributes()
  
  Return member attributes as read from the ZIP file. Note that
  these are NOT UNIX!
  
  =item unixFileAttributes( [$newAttributes] )
  
  Get or set the member's file attributes using UNIX file
  attributes. Returns old attributes.
  
      my $oldAttribs = $member->unixFileAttributes( 0666 );
  
  Note that the return value has more than just the file
  permissions, so you will have to mask off the lowest bits for
  comparisions.
  
  =item localExtraField( [$newField] )
  
  Gets or sets the extra field that was read from the local
  header. This is not set for a member from a zip file until
  after the member has been written out. The extra field must
  be in the proper format.
  
  =item cdExtraField( [$newField] )
  
  Gets or sets the extra field that was read from the central
  directory header. The extra field must be in the proper
  format.
  
  =item extraFields()
  
  Return both local and CD extra fields, concatenated.
  
  =item fileComment( [$newComment] )
  
  Get or set the member's file comment.
  
  =item hasDataDescriptor()
  
  Get or set the data descriptor flag. If this is set, the
  local header will not necessarily have the correct data
  sizes. Instead, a small structure will be stored at the end
  of the member data with these values. This should be
  transparent in normal operation.
  
  =item crc32()
  
  Return the CRC-32 value for this member. This will not be set
  for members that were constructed from strings or external
  files until after the member has been written.
  
  =item crc32String()
  
  Return the CRC-32 value for this member as an 8 character
  printable hex string. This will not be set for members that
  were constructed from strings or external files until after
  the member has been written.
  
  =item compressedSize()
  
  Return the compressed size for this member. This will not be
  set for members that were constructed from strings or
  external files until after the member has been written.
  
  =item uncompressedSize()
  
  Return the uncompressed size for this member.
  
  =item isEncrypted()
  
  Return true if this member is encrypted. The Archive::Zip
  module does not currently create or extract encrypted
  members.
  
  =item isTextFile( [$flag] )
  
  Returns true if I am a text file. Also can set the status if
  given an argument (then returns old state). Note that this
  module does not currently do anything with this flag upon
  extraction or storage. That is, bytes are stored in native
  format whether or not they came from a text file.
  
  =item isBinaryFile()
  
  Returns true if I am a binary file. Also can set the status
  if given an argument (then returns old state). Note that this
  module does not currently do anything with this flag upon
  extraction or storage. That is, bytes are stored in native
  format whether or not they came from a text file.
  
  =item extractToFileNamed( $fileName )
  
  Extract me to a file with the given name. The file will be
  created with default modes. Directories will be created as
  needed.
  The C<$fileName> argument should be a valid file name on your
  file system.
  Returns AZ_OK on success.
  
  =item isDirectory()
  
  Returns true if I am a directory.
  
  =item writeLocalHeaderRelativeOffset()
  
  Returns the file offset in bytes the last time I was written.
  
  =item wasWritten()
  
  Returns true if I was successfully written. Reset at the
  beginning of a write attempt.
  
  =back
  
  =head2 Low-level member data reading
  
  It is possible to use lower-level routines to access member data
  streams, rather than the extract* methods and contents(). For
  instance, here is how to print the uncompressed contents of a member
  in chunks using these methods:
  
      my ( $member, $status, $bufferRef );
      $member = $zip->memberNamed( 'xyz.txt' );
      $member->desiredCompressionMethod( COMPRESSION_STORED );
      $status = $member->rewindData();
      die "error $status" unless $status == AZ_OK;
      while ( ! $member->readIsDone() )
      {
      ( $bufferRef, $status ) = $member->readChunk();
      die "error $status"
                  if $status != AZ_OK && $status != AZ_STREAM_END;
      # do something with $bufferRef:
      print $$bufferRef;
      }
      $member->endRead();
  
  =over 4
  
  =item readChunk( [$chunkSize] )
  
  This reads the next chunk of given size from the member's
  data stream and compresses or uncompresses it as necessary,
  returning a reference to the bytes read and a status. If size
  argument is not given, defaults to global set by
  Archive::Zip::setChunkSize. Status is AZ_OK on success until
  the last chunk, where it returns AZ_STREAM_END. Returns C<(
  \$bytes, $status)>.
  
      my ( $outRef, $status ) = $self->readChunk();
      print $$outRef if $status != AZ_OK && $status != AZ_STREAM_END;
  
  =item rewindData()
  
  Rewind data and set up for reading data streams or writing
  zip files. Can take options for C<inflateInit()> or
  C<deflateInit()>, but this isn't likely to be necessary.
  Subclass overrides should call this method. Returns C<AZ_OK>
  on success.
  
  =item endRead()
  
  Reset the read variables and free the inflater or deflater.
  Must be called to close files, etc. Returns AZ_OK on success.
  
  =item readIsDone()
  
  Return true if the read has run out of data or errored out.
  
  =item contents()
  
  Return the entire uncompressed member data or undef in scalar
  context. When called in array context, returns C<( $string,
  $status )>; status will be AZ_OK on success:
  
      my $string = $member->contents();
      # or
      my ( $string, $status ) = $member->contents();
      die "error $status" unless $status == AZ_OK;
  
  Can also be used to set the contents of a member (this may
  change the class of the member):
  
      $member->contents( "this is my new contents" );
  
  =item extractToFileHandle( $fh )
  
  Extract (and uncompress, if necessary) the member's contents
  to the given file handle. Return AZ_OK on success.
  
  =back
  
  =head1 Archive::Zip::FileMember methods
  
  The Archive::Zip::FileMember class extends Archive::Zip::Member. It is the
  base class for both ZipFileMember and NewFileMember classes. This class adds
  an C<externalFileName> and an C<fh> member to keep track of the external
  file.
  
  =over 4
  
  =item externalFileName()
  
  Return the member's external filename.
  
  =item fh()
  
  Return the member's read file handle. Automatically opens file if
  necessary.
  
  =back
  
  =head1 Archive::Zip::ZipFileMember methods
  
  The Archive::Zip::ZipFileMember class represents members that have been read
  from external zip files.
  
  =over 4
  
  =item diskNumberStart()
  
  Returns the disk number that the member's local header resides in.
  Should be 0.
  
  =item localHeaderRelativeOffset()
  
  Returns the offset into the zip file where the member's local header
  is.
  
  =item dataOffset()
  
  Returns the offset from the beginning of the zip file to the member's
  data.
  
  =back
  
  =head1 REQUIRED MODULES
  
  L<Archive::Zip> requires several other modules:
  
  L<Carp>
  
  L<Compress::Raw::Zlib>
  
  L<Cwd>
  
  L<File::Basename>
  
  L<File::Copy>
  
  L<File::Find>
  
  L<File::Path>
  
  L<File::Spec>
  
  L<IO::File>
  
  L<IO::Seekable>
  
  L<Time::Local>
  
  =head1 BUGS AND CAVEATS
  
  =head2 When not to use Archive::Zip
  
  If you are just going to be extracting zips (and/or other archives) you
  are recommended to look at using L<Archive::Extract> instead, as it is much
  easier to use and factors out archive-specific functionality.
  
  =head2 Try to avoid IO::Scalar
  
  One of the most common ways to use Archive::Zip is to generate Zip files
  in-memory. Most people have use L<IO::Scalar> for this purpose.
  
  Unfortunately, as of 1.11 this module no longer works with L<IO::Scalar>
  as it incorrectly implements seeking.
  
  Anybody using L<IO::Scalar> should consider porting to L<IO::String>,
  which is smaller, lighter, and is implemented to be perfectly compatible
  with regular seekable filehandles.
  
  Support for L<IO::Scalar> most likely will B<not> be restored in the
  future, as L<IO::Scalar> itself cannot change the way it is implemented
  due to back-compatibility issues.
  
  =head1 TO DO
  
  * auto-choosing storing vs compression
  
  * extra field hooks (see notes.txt)
  
  * check for dups on addition/renaming?
  
  * Text file extraction (line end translation)
  
  * Reading zip files from non-seekable inputs
    (Perhaps by proxying through IO::String?)
  
  * separate unused constants into separate module
  
  * cookbook style docs
  
  * Handle tainted paths correctly
  
  * Work on better compatability with other IO:: modules
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Archive-Zip>
  
  For other issues contact the maintainer
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Previously maintained by Steve Peters E<lt>steve@fisharerojo.orgE<gt>.
  
  File attributes code by Maurice Aubrey E<lt>maurice@lovelyfilth.comE<gt>.
  
  Originally by Ned Konz E<lt>nedkonz@cpan.orgE<gt>.
  
  =head1 COPYRIGHT
  
  Some parts copyright 2006 - 2009 Adam Kennedy.
  
  Some parts copyright 2005 Steve Peters.
  
  Original work copyright 2000 - 2004 Ned Konz.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  Look at L<Archive::Zip::MemberRead> which is a wrapper that allows one to
  read Zip archive members as if they were files.
  
  L<Compress::Raw::Zlib>, L<Archive::Tar>, L<Archive::Extract>
  
  There is a Japanese translation of this
  document at L<http://www.memb.jp/~deq/perl/doc-ja/Archive-Zip.html>
  that was done by DEQ E<lt>deq@oct.zaq.ne.jpE<gt> . Thanks! 
  
  =cut
ARCHIVE_ZIP

$fatpacked{"Archive/Zip/Archive.pm"} = <<'ARCHIVE_ZIP_ARCHIVE';
  package Archive::Zip::Archive;
  
  # Represents a generic ZIP archive
  
  use strict;
  use File::Path;
  use File::Find ();
  use File::Spec ();
  use File::Copy ();
  use File::Basename;
  use Cwd;
  
  use vars qw( $VERSION @ISA );
  
  BEGIN {
      $VERSION = '1.30';
      @ISA     = qw( Archive::Zip );
  }
  
  use Archive::Zip qw(
    :CONSTANTS
    :ERROR_CODES
    :PKZIP_CONSTANTS
    :UTILITY_METHODS
  );
  
  # Note that this returns undef on read errors, else new zip object.
  
  sub new {
      my $class = shift;
      my $self  = bless(
          {
              'diskNumber'                            => 0,
              'diskNumberWithStartOfCentralDirectory' => 0,
              'numberOfCentralDirectoriesOnThisDisk'  => 0, # shld be # of members
              'numberOfCentralDirectories'            => 0, # shld be # of members
              'centralDirectorySize' => 0,    # must re-compute on write
              'centralDirectoryOffsetWRTStartingDiskNumber' =>
                0,                            # must re-compute
              'writeEOCDOffset'             => 0,
              'writeCentralDirectoryOffset' => 0,
              'zipfileComment'              => '',
              'eocdOffset'                  => 0,
              'fileName'                    => ''
          },
          $class
      );
      $self->{'members'} = [];
      my $fileName = ( ref( $_[0] ) eq 'HASH' ) ? shift->{filename} : shift;
      if ($fileName) {
          my $status = $self->read($fileName);
          return $status == AZ_OK ? $self : undef;
      }
      return $self;
  }
  
  sub storeSymbolicLink {
      my $self = shift;
      $self->{'storeSymbolicLink'} = shift;
  }
  
  sub members {
      @{ shift->{'members'} };
  }
  
  sub numberOfMembers {
      scalar( shift->members() );
  }
  
  sub memberNames {
      my $self = shift;
      return map { $_->fileName() } $self->members();
  }
  
  # return ref to member with given name or undef
  sub memberNamed {
      my $self     = shift;
      my $fileName = ( ref( $_[0] ) eq 'HASH' ) ? shift->{zipName} : shift;
      foreach my $member ( $self->members() ) {
          return $member if $member->fileName() eq $fileName;
      }
      return undef;
  }
  
  sub membersMatching {
      my $self    = shift;
      my $pattern = ( ref( $_[0] ) eq 'HASH' ) ? shift->{regex} : shift;
      return grep { $_->fileName() =~ /$pattern/ } $self->members();
  }
  
  sub diskNumber {
      shift->{'diskNumber'};
  }
  
  sub diskNumberWithStartOfCentralDirectory {
      shift->{'diskNumberWithStartOfCentralDirectory'};
  }
  
  sub numberOfCentralDirectoriesOnThisDisk {
      shift->{'numberOfCentralDirectoriesOnThisDisk'};
  }
  
  sub numberOfCentralDirectories {
      shift->{'numberOfCentralDirectories'};
  }
  
  sub centralDirectorySize {
      shift->{'centralDirectorySize'};
  }
  
  sub centralDirectoryOffsetWRTStartingDiskNumber {
      shift->{'centralDirectoryOffsetWRTStartingDiskNumber'};
  }
  
  sub zipfileComment {
      my $self    = shift;
      my $comment = $self->{'zipfileComment'};
      if (@_) {
          my $new_comment = ( ref( $_[0] ) eq 'HASH' ) ? shift->{comment} : shift;
          $self->{'zipfileComment'} = pack( 'C0a*', $new_comment );    # avoid unicode
      }
      return $comment;
  }
  
  sub eocdOffset {
      shift->{'eocdOffset'};
  }
  
  # Return the name of the file last read.
  sub fileName {
      shift->{'fileName'};
  }
  
  sub removeMember {
      my $self    = shift;
      my $member  = ( ref( $_[0] ) eq 'HASH' ) ? shift->{memberOrZipName} : shift;
      $member = $self->memberNamed($member) unless ref($member);
      return undef unless $member;
      my @newMembers = grep { $_ != $member } $self->members();
      $self->{'members'} = \@newMembers;
      return $member;
  }
  
  sub replaceMember {
      my $self = shift;
  
      my ( $oldMember, $newMember );
      if ( ref( $_[0] ) eq 'HASH' ) {
          $oldMember = $_[0]->{memberOrZipName};
          $newMember = $_[0]->{newMember};
      }
      else {
          ( $oldMember, $newMember ) = @_;
      }
  
      $oldMember = $self->memberNamed($oldMember) unless ref($oldMember);
      return undef unless $oldMember;
      return undef unless $newMember;
      my @newMembers =
        map { ( $_ == $oldMember ) ? $newMember : $_ } $self->members();
      $self->{'members'} = \@newMembers;
      return $oldMember;
  }
  
  sub extractMember {
      my $self = shift;
  
      my ( $member, $name );
      if ( ref( $_[0] ) eq 'HASH' ) {
          $member = $_[0]->{memberOrZipName};
          $name   = $_[0]->{name};
      }
      else {
          ( $member, $name ) = @_;
      }
  
      $member = $self->memberNamed($member) unless ref($member);
      return _error('member not found') unless $member;
      my $originalSize = $member->compressedSize();
      my ( $volumeName, $dirName, $fileName );
      if ( defined($name) ) {
          ( $volumeName, $dirName, $fileName ) = File::Spec->splitpath($name);
          $dirName = File::Spec->catpath( $volumeName, $dirName, '' );
      }
      else {
          $name = $member->fileName();
          ( $dirName = $name ) =~ s{[^/]*$}{};
          $dirName = Archive::Zip::_asLocalName($dirName);
          $name    = Archive::Zip::_asLocalName($name);
      }
      if ( $dirName && !-d $dirName ) {
          mkpath($dirName);
          return _ioError("can't create dir $dirName") if ( !-d $dirName );
      }
      my $rc = $member->extractToFileNamed( $name, @_ );
  
      # TODO refactor this fix into extractToFileNamed()
      $member->{'compressedSize'} = $originalSize;
      return $rc;
  }
  
  sub extractMemberWithoutPaths {
      my $self = shift;
  
      my ( $member, $name );
      if ( ref( $_[0] ) eq 'HASH' ) {
          $member = $_[0]->{memberOrZipName};
          $name   = $_[0]->{name};
      }
      else {
          ( $member, $name ) = @_;
      }
  
      $member = $self->memberNamed($member) unless ref($member);
      return _error('member not found') unless $member;
      my $originalSize = $member->compressedSize();
      return AZ_OK if $member->isDirectory();
      unless ($name) {
          $name = $member->fileName();
          $name =~ s{.*/}{};    # strip off directories, if any
          $name = Archive::Zip::_asLocalName($name);
      }
      my $rc = $member->extractToFileNamed( $name, @_ );
      $member->{'compressedSize'} = $originalSize;
      return $rc;
  }
  
  sub addMember {
      my $self       = shift;
      my $newMember  = ( ref( $_[0] ) eq 'HASH' ) ? shift->{member} : shift;
      push( @{ $self->{'members'} }, $newMember ) if $newMember;
      return $newMember;
  }
  
  sub addFile {
      my $self = shift;
  
      my ( $fileName, $newName, $compressionLevel );
      if ( ref( $_[0] ) eq 'HASH' ) {
          $fileName         = $_[0]->{filename};
          $newName          = $_[0]->{zipName};
          $compressionLevel = $_[0]->{compressionLevel};
      }
      else {
          ( $fileName, $newName, $compressionLevel ) = @_;
      }
  
      my $newMember = $self->ZIPMEMBERCLASS->newFromFile( $fileName, $newName );
      $newMember->desiredCompressionLevel($compressionLevel);
      if ( $self->{'storeSymbolicLink'} && -l $fileName ) {
          my $newMember = $self->ZIPMEMBERCLASS->newFromString(readlink $fileName, $newName);
          # For symbolic links, External File Attribute is set to 0xA1FF0000 by Info-ZIP
          $newMember->{'externalFileAttributes'} = 0xA1FF0000;
          $self->addMember($newMember);
      } else {
          $self->addMember($newMember);
      }
      return $newMember;
  }
  
  sub addString {
      my $self = shift;
  
      my ( $stringOrStringRef, $name, $compressionLevel );
      if ( ref( $_[0] ) eq 'HASH' ) {
          $stringOrStringRef = $_[0]->{string};
          $name              = $_[0]->{zipName};
          $compressionLevel  = $_[0]->{compressionLevel};
      }
      else {
          ( $stringOrStringRef, $name, $compressionLevel ) = @_;;
      }
  
      my $newMember = $self->ZIPMEMBERCLASS->newFromString(
          $stringOrStringRef, $name
      );
      $newMember->desiredCompressionLevel($compressionLevel);
      return $self->addMember($newMember);
  }
  
  sub addDirectory {
      my $self = shift;
  
      my ( $name, $newName );
      if ( ref( $_[0] ) eq 'HASH' ) {
          $name    = $_[0]->{directoryName};
          $newName = $_[0]->{zipName};
      }
      else {
          ( $name, $newName ) = @_;
      }
  
      my $newMember = $self->ZIPMEMBERCLASS->newDirectoryNamed( $name, $newName );
      if ( $self->{'storeSymbolicLink'} && -l $name ) {
          my $link = readlink $name;
          ( $newName =~ s{/$}{} ) if $newName; # Strip trailing /
          my $newMember = $self->ZIPMEMBERCLASS->newFromString($link, $newName);
          # For symbolic links, External File Attribute is set to 0xA1FF0000 by Info-ZIP
          $newMember->{'externalFileAttributes'} = 0xA1FF0000;
          $self->addMember($newMember);
      } else {
          $self->addMember($newMember);
      }
      return $newMember;
  }
  
  # add either a file or a directory.
  
  sub addFileOrDirectory {
      my $self = shift;
  
      my ( $name, $newName, $compressionLevel );
      if ( ref( $_[0] ) eq 'HASH' ) {
          $name             = $_[0]->{name};
          $newName          = $_[0]->{zipName};
          $compressionLevel = $_[0]->{compressionLevel};
      }
      else {
          ( $name, $newName, $compressionLevel ) = @_;
      }
  
      $name =~ s{/$}{};
      if ( $newName ) {
          $newName =~ s{/$}{};
      } else {
          $newName = $name;
      }
      if ( -f $name ) {
          return $self->addFile( $name, $newName, $compressionLevel );
      }
      elsif ( -d $name ) {
          return $self->addDirectory( $name, $newName );
      }
      else {
          return _error("$name is neither a file nor a directory");
      }
  }
  
  sub contents {
      my $self = shift;
  
      my ( $member, $newContents );
      if ( ref( $_[0] ) eq 'HASH' ) {
          $member      = $_[0]->{memberOrZipName};
          $newContents = $_[0]->{contents};
      }
      else {
          ( $member, $newContents ) = @_;
      }
  
      return _error('No member name given') unless $member;
      $member = $self->memberNamed($member) unless ref($member);
      return undef unless $member;
      return $member->contents($newContents);
  }
  
  sub writeToFileNamed {
      my $self = shift;
      my $fileName =
        ( ref( $_[0] ) eq 'HASH' ) ? shift->{filename} : shift;  # local FS format
      foreach my $member ( $self->members() ) {
          if ( $member->_usesFileNamed($fileName) ) {
              return _error( "$fileName is needed by member "
                    . $member->fileName()
                    . "; consider using overwrite() or overwriteAs() instead." );
          }
      }
      my ( $status, $fh ) = _newFileHandle( $fileName, 'w' );
      return _ioError("Can't open $fileName for write") unless $status;
      my $retval = $self->writeToFileHandle( $fh, 1 );
      $fh->close();
      $fh = undef;
  
      return $retval;
  }
  
  # It is possible to write data to the FH before calling this,
  # perhaps to make a self-extracting archive.
  sub writeToFileHandle {
      my $self = shift;
  
      my ( $fh, $fhIsSeekable );
      if ( ref( $_[0] ) eq 'HASH' ) {
          $fh           = $_[0]->{fileHandle};
          $fhIsSeekable =
            exists( $_[0]->{seek} ) ? $_[0]->{seek} : _isSeekable($fh);
      }
      else {
          $fh           = shift;
          $fhIsSeekable = @_ ? shift : _isSeekable($fh);
      }
  
      return _error('No filehandle given')   unless $fh;
      return _ioError('filehandle not open') unless $fh->opened();
      _binmode($fh);
  
      # Find out where the current position is.
      my $offset = $fhIsSeekable ? $fh->tell() : 0;
      $offset    = 0 if $offset < 0;
  
      foreach my $member ( $self->members() ) {
          my $retval = $member->_writeToFileHandle( $fh, $fhIsSeekable, $offset );
          $member->endRead();
          return $retval if $retval != AZ_OK;
          $offset += $member->_localHeaderSize() + $member->_writeOffset();
          $offset +=
            $member->hasDataDescriptor()
            ? DATA_DESCRIPTOR_LENGTH + SIGNATURE_LENGTH
            : 0;
  
          # changed this so it reflects the last successful position
          $self->{'writeCentralDirectoryOffset'} = $offset;
      }
      return $self->writeCentralDirectory($fh);
  }
  
  # Write zip back to the original file,
  # as safely as possible.
  # Returns AZ_OK if successful.
  sub overwrite {
      my $self = shift;
      return $self->overwriteAs( $self->{'fileName'} );
  }
  
  # Write zip to the specified file,
  # as safely as possible.
  # Returns AZ_OK if successful.
  sub overwriteAs {
      my $self    = shift;
      my $zipName = ( ref( $_[0] ) eq 'HASH' ) ? $_[0]->{filename} : shift;
      return _error("no filename in overwriteAs()") unless defined($zipName);
  
      my ( $fh, $tempName ) = Archive::Zip::tempFile();
      return _error( "Can't open temp file", $! ) unless $fh;
  
      ( my $backupName = $zipName ) =~ s{(\.[^.]*)?$}{.zbk};
  
      my $status = $self->writeToFileHandle($fh);
      $fh->close();
      $fh = undef;
  
      if ( $status != AZ_OK ) {
          unlink($tempName);
          _printError("Can't write to $tempName");
          return $status;
      }
  
      my $err;
  
      # rename the zip
      if ( -f $zipName && !rename( $zipName, $backupName ) ) {
          $err = $!;
          unlink($tempName);
          return _error( "Can't rename $zipName as $backupName", $err );
      }
  
      # move the temp to the original name (possibly copying)
      unless ( File::Copy::move( $tempName, $zipName ) ) {
          $err = $!;
          rename( $backupName, $zipName );
          unlink($tempName);
          return _error( "Can't move $tempName to $zipName", $err );
      }
  
      # unlink the backup
      if ( -f $backupName && !unlink($backupName) ) {
          $err = $!;
          return _error( "Can't unlink $backupName", $err );
      }
  
      return AZ_OK;
  }
  
  # Used only during writing
  sub _writeCentralDirectoryOffset {
      shift->{'writeCentralDirectoryOffset'};
  }
  
  sub _writeEOCDOffset {
      shift->{'writeEOCDOffset'};
  }
  
  # Expects to have _writeEOCDOffset() set
  sub _writeEndOfCentralDirectory {
      my ( $self, $fh ) = @_;
  
      $self->_print($fh, END_OF_CENTRAL_DIRECTORY_SIGNATURE_STRING)
        or return _ioError('writing EOCD Signature');
      my $zipfileCommentLength = length( $self->zipfileComment() );
  
      my $header = pack(
          END_OF_CENTRAL_DIRECTORY_FORMAT,
          0,                          # {'diskNumber'},
          0,                          # {'diskNumberWithStartOfCentralDirectory'},
          $self->numberOfMembers(),   # {'numberOfCentralDirectoriesOnThisDisk'},
          $self->numberOfMembers(),   # {'numberOfCentralDirectories'},
          $self->_writeEOCDOffset() - $self->_writeCentralDirectoryOffset(),
          $self->_writeCentralDirectoryOffset(),
          $zipfileCommentLength
      );
      $self->_print($fh, $header)
        or return _ioError('writing EOCD header');
      if ($zipfileCommentLength) {
          $self->_print($fh,  $self->zipfileComment() )
            or return _ioError('writing zipfile comment');
      }
      return AZ_OK;
  }
  
  # $offset can be specified to truncate a zip file.
  sub writeCentralDirectory {
      my $self = shift;
  
      my ( $fh, $offset );
      if ( ref( $_[0] ) eq 'HASH' ) {
          $fh     = $_[0]->{fileHandle};
          $offset = $_[0]->{offset};
      }
      else {
          ( $fh, $offset ) = @_;
      }
  
      if ( defined($offset) ) {
          $self->{'writeCentralDirectoryOffset'} = $offset;
          $fh->seek( $offset, IO::Seekable::SEEK_SET )
            or return _ioError('seeking to write central directory');
      }
      else {
          $offset = $self->_writeCentralDirectoryOffset();
      }
  
      foreach my $member ( $self->members() ) {
          my $status = $member->_writeCentralDirectoryFileHeader($fh);
          return $status if $status != AZ_OK;
          $offset += $member->_centralDirectoryHeaderSize();
          $self->{'writeEOCDOffset'} = $offset;
      }
      return $self->_writeEndOfCentralDirectory($fh);
  }
  
  sub read {
      my $self     = shift;
      my $fileName = ( ref( $_[0] ) eq 'HASH' ) ? shift->{filename} : shift;
      return _error('No filename given') unless $fileName;
      my ( $status, $fh ) = _newFileHandle( $fileName, 'r' );
      return _ioError("opening $fileName for read") unless $status;
  
      $status = $self->readFromFileHandle( $fh, $fileName );
      return $status if $status != AZ_OK;
  
      $fh->close();
      $self->{'fileName'} = $fileName;
      return AZ_OK;
  }
  
  sub readFromFileHandle {
      my $self = shift;
  
      my ( $fh, $fileName );
      if ( ref( $_[0] ) eq 'HASH' ) {
          $fh       = $_[0]->{fileHandle};
          $fileName = $_[0]->{filename};
      }
      else {
          ( $fh, $fileName ) = @_;
      }
  
      $fileName = $fh unless defined($fileName);
      return _error('No filehandle given')   unless $fh;
      return _ioError('filehandle not open') unless $fh->opened();
  
      _binmode($fh);
      $self->{'fileName'} = "$fh";
  
      # TODO: how to support non-seekable zips?
      return _error('file not seekable')
        unless _isSeekable($fh);
  
      $fh->seek( 0, 0 );    # rewind the file
  
      my $status = $self->_findEndOfCentralDirectory($fh);
      return $status if $status != AZ_OK;
  
      my $eocdPosition = $fh->tell();
  
      $status = $self->_readEndOfCentralDirectory($fh);
      return $status if $status != AZ_OK;
  
      $fh->seek( $eocdPosition - $self->centralDirectorySize(),
          IO::Seekable::SEEK_SET )
        or return _ioError("Can't seek $fileName");
  
      # Try to detect garbage at beginning of archives
      # This should be 0
      $self->{'eocdOffset'} = $eocdPosition - $self->centralDirectorySize() # here
        - $self->centralDirectoryOffsetWRTStartingDiskNumber();
  
      for ( ; ; ) {
          my $newMember =
            $self->ZIPMEMBERCLASS->_newFromZipFile( $fh, $fileName,
              $self->eocdOffset() );
          my $signature;
          ( $status, $signature ) = _readSignature( $fh, $fileName );
          return $status if $status != AZ_OK;
          last           if $signature == END_OF_CENTRAL_DIRECTORY_SIGNATURE;
          $status = $newMember->_readCentralDirectoryFileHeader();
          return $status if $status != AZ_OK;
          $status = $newMember->endRead();
          return $status if $status != AZ_OK;
          $newMember->_becomeDirectoryIfNecessary();
          push( @{ $self->{'members'} }, $newMember );
      }
  
      return AZ_OK;
  }
  
  # Read EOCD, starting from position before signature.
  # Return AZ_OK on success.
  sub _readEndOfCentralDirectory {
      my $self = shift;
      my $fh   = shift;
  
      # Skip past signature
      $fh->seek( SIGNATURE_LENGTH, IO::Seekable::SEEK_CUR )
        or return _ioError("Can't seek past EOCD signature");
  
      my $header = '';
      my $bytesRead = $fh->read( $header, END_OF_CENTRAL_DIRECTORY_LENGTH );
      if ( $bytesRead != END_OF_CENTRAL_DIRECTORY_LENGTH ) {
          return _ioError("reading end of central directory");
      }
  
      my $zipfileCommentLength;
      (
          $self->{'diskNumber'},
          $self->{'diskNumberWithStartOfCentralDirectory'},
          $self->{'numberOfCentralDirectoriesOnThisDisk'},
          $self->{'numberOfCentralDirectories'},
          $self->{'centralDirectorySize'},
          $self->{'centralDirectoryOffsetWRTStartingDiskNumber'},
          $zipfileCommentLength
      ) = unpack( END_OF_CENTRAL_DIRECTORY_FORMAT, $header );
  
      if ($zipfileCommentLength) {
          my $zipfileComment = '';
          $bytesRead = $fh->read( $zipfileComment, $zipfileCommentLength );
          if ( $bytesRead != $zipfileCommentLength ) {
              return _ioError("reading zipfile comment");
          }
          $self->{'zipfileComment'} = $zipfileComment;
      }
  
      return AZ_OK;
  }
  
  # Seek in my file to the end, then read backwards until we find the
  # signature of the central directory record. Leave the file positioned right
  # before the signature. Returns AZ_OK if success.
  sub _findEndOfCentralDirectory {
      my $self = shift;
      my $fh   = shift;
      my $data = '';
      $fh->seek( 0, IO::Seekable::SEEK_END )
        or return _ioError("seeking to end");
  
      my $fileLength = $fh->tell();
      if ( $fileLength < END_OF_CENTRAL_DIRECTORY_LENGTH + 4 ) {
          return _formatError("file is too short");
      }
  
      my $seekOffset = 0;
      my $pos        = -1;
      for ( ; ; ) {
          $seekOffset += 512;
          $seekOffset = $fileLength if ( $seekOffset > $fileLength );
          $fh->seek( -$seekOffset, IO::Seekable::SEEK_END )
            or return _ioError("seek failed");
          my $bytesRead = $fh->read( $data, $seekOffset );
          if ( $bytesRead != $seekOffset ) {
              return _ioError("read failed");
          }
          $pos = rindex( $data, END_OF_CENTRAL_DIRECTORY_SIGNATURE_STRING );
          last
            if ( $pos >= 0
              or $seekOffset == $fileLength
              or $seekOffset >= $Archive::Zip::ChunkSize );
      }
  
      if ( $pos >= 0 ) {
          $fh->seek( $pos - $seekOffset, IO::Seekable::SEEK_CUR )
            or return _ioError("seeking to EOCD");
          return AZ_OK;
      }
      else {
          return _formatError("can't find EOCD signature");
      }
  }
  
  # Used to avoid taint problems when chdir'ing.
  # Not intended to increase security in any way; just intended to shut up the -T
  # complaints.  If your Cwd module is giving you unreliable returns from cwd()
  # you have bigger problems than this.
  sub _untaintDir {
      my $dir = shift;
      $dir =~ m/\A(.+)\z/s;
      return $1;
  }
  
  sub addTree {
      my $self = shift;
  
      my ( $root, $dest, $pred, $compressionLevel );
      if ( ref( $_[0] ) eq 'HASH' ) {
          $root             = $_[0]->{root};
          $dest             = $_[0]->{zipName};
          $pred             = $_[0]->{select};
          $compressionLevel = $_[0]->{compressionLevel};
      }
      else {
          ( $root, $dest, $pred, $compressionLevel ) = @_;
      }
  
      return _error("root arg missing in call to addTree()")
        unless defined($root);
      $dest = '' unless defined($dest);
      $pred = sub { -r } unless defined($pred);
  
      my @files;
      my $startDir = _untaintDir( cwd() );
  
      return _error( 'undef returned by _untaintDir on cwd ', cwd() )
        unless $startDir;
  
      # This avoids chdir'ing in Find, in a way compatible with older
      # versions of File::Find.
      my $wanted = sub {
          local $main::_ = $File::Find::name;
          my $dir = _untaintDir($File::Find::dir);
          chdir($startDir);
          push( @files, $File::Find::name ) if (&$pred);
          chdir($dir);
      };
  
      File::Find::find( $wanted, $root );
  
      my $rootZipName = _asZipDirName( $root, 1 );    # with trailing slash
      my $pattern = $rootZipName eq './' ? '^' : "^\Q$rootZipName\E";
  
      $dest = _asZipDirName( $dest, 1 );              # with trailing slash
  
      foreach my $fileName (@files) {
          my $isDir = -d $fileName;
  
          # normalize, remove leading ./
          my $archiveName = _asZipDirName( $fileName, $isDir );
          if ( $archiveName eq $rootZipName ) { $archiveName = $dest }
          else { $archiveName =~ s{$pattern}{$dest} }
          next if $archiveName =~ m{^\.?/?$};         # skip current dir
          my $member = $isDir
            ? $self->addDirectory( $fileName, $archiveName )
            : $self->addFile( $fileName, $archiveName );
          $member->desiredCompressionLevel($compressionLevel);
  
          return _error("add $fileName failed in addTree()") if !$member;
      }
      return AZ_OK;
  }
  
  sub addTreeMatching {
      my $self = shift;
  
      my ( $root, $dest, $pattern, $pred, $compressionLevel );
      if ( ref( $_[0] ) eq 'HASH' ) {
          $root             = $_[0]->{root};
          $dest             = $_[0]->{zipName};
          $pattern          = $_[0]->{pattern};
          $pred             = $_[0]->{select};
          $compressionLevel = $_[0]->{compressionLevel};
      }
      else {
          ( $root, $dest, $pattern, $pred, $compressionLevel ) = @_;
      }
  
      return _error("root arg missing in call to addTreeMatching()")
        unless defined($root);
      $dest = '' unless defined($dest);
      return _error("pattern missing in call to addTreeMatching()")
        unless defined($pattern);
      my $matcher =
        $pred ? sub { m{$pattern} && &$pred } : sub { m{$pattern} && -r };
      return $self->addTree( $root, $dest, $matcher, $compressionLevel );
  }
  
  # $zip->extractTree( $root, $dest [, $volume] );
  #
  # $root and $dest are Unix-style.
  # $volume is in local FS format.
  #
  sub extractTree {
      my $self = shift;
  
      my ( $root, $dest, $volume );
      if ( ref( $_[0] ) eq 'HASH' ) {
          $root   = $_[0]->{root};
          $dest   = $_[0]->{zipName};
          $volume = $_[0]->{volume};
      }
      else {
          ( $root, $dest, $volume ) = @_;
      }
  
      $root = '' unless defined($root);
      $dest = './' unless defined($dest);
      my $pattern = "^\Q$root";
      my @members = $self->membersMatching($pattern);
  
      foreach my $member (@members) {
          my $fileName = $member->fileName();           # in Unix format
          $fileName =~ s{$pattern}{$dest};    # in Unix format
                                              # convert to platform format:
          $fileName = Archive::Zip::_asLocalName( $fileName, $volume );
          my $status = $member->extractToFileNamed($fileName);
          return $status if $status != AZ_OK;
      }
      return AZ_OK;
  }
  
  # $zip->updateMember( $memberOrName, $fileName );
  # Returns (possibly updated) member, if any; undef on errors.
  
  sub updateMember {
      my $self = shift;
  
      my ( $oldMember, $fileName );
      if ( ref( $_[0] ) eq 'HASH' ) {
          $oldMember = $_[0]->{memberOrZipName};
          $fileName  = $_[0]->{name};
      }
      else {
          ( $oldMember, $fileName ) = @_;
      }
  
      if ( !defined($fileName) ) {
          _error("updateMember(): missing fileName argument");
          return undef;
      }
  
      my @newStat = stat($fileName);
      if ( !@newStat ) {
          _ioError("Can't stat $fileName");
          return undef;
      }
  
      my $isDir = -d _;
  
      my $memberName;
  
      if ( ref($oldMember) ) {
          $memberName = $oldMember->fileName();
      }
      else {
          $oldMember = $self->memberNamed( $memberName = $oldMember )
            || $self->memberNamed( $memberName =
                _asZipDirName( $oldMember, $isDir ) );
      }
  
      unless ( defined($oldMember)
          && $oldMember->lastModTime() == $newStat[9]
          && $oldMember->isDirectory() == $isDir
          && ( $isDir || ( $oldMember->uncompressedSize() == $newStat[7] ) ) )
      {
  
          # create the new member
          my $newMember = $isDir
            ? $self->ZIPMEMBERCLASS->newDirectoryNamed( $fileName, $memberName )
            : $self->ZIPMEMBERCLASS->newFromFile( $fileName, $memberName );
  
          unless ( defined($newMember) ) {
              _error("creation of member $fileName failed in updateMember()");
              return undef;
          }
  
          # replace old member or append new one
          if ( defined($oldMember) ) {
              $self->replaceMember( $oldMember, $newMember );
          }
          else { $self->addMember($newMember); }
  
          return $newMember;
      }
  
      return $oldMember;
  }
  
  # $zip->updateTree( $root, [ $dest, [ $pred [, $mirror]]] );
  #
  # This takes the same arguments as addTree, but first checks to see
  # whether the file or directory already exists in the zip file.
  #
  # If the fourth argument $mirror is true, then delete all my members
  # if corresponding files weren't found.
  
  sub updateTree {
      my $self = shift;
  
      my ( $root, $dest, $pred, $mirror, $compressionLevel );
      if ( ref( $_[0] ) eq 'HASH' ) {
          $root             = $_[0]->{root};
          $dest             = $_[0]->{zipName};
          $pred             = $_[0]->{select};
          $mirror           = $_[0]->{mirror};
          $compressionLevel = $_[0]->{compressionLevel};
      }
      else {
          ( $root, $dest, $pred, $mirror, $compressionLevel ) = @_;
      }
  
      return _error("root arg missing in call to updateTree()")
        unless defined($root);
      $dest = '' unless defined($dest);
      $pred = sub { -r } unless defined($pred);
  
      $dest = _asZipDirName( $dest, 1 );
      my $rootZipName = _asZipDirName( $root, 1 );    # with trailing slash
      my $pattern = $rootZipName eq './' ? '^' : "^\Q$rootZipName\E";
  
      my @files;
      my $startDir = _untaintDir( cwd() );
  
      return _error( 'undef returned by _untaintDir on cwd ', cwd() )
        unless $startDir;
  
      # This avoids chdir'ing in Find, in a way compatible with older
      # versions of File::Find.
      my $wanted = sub {
          local $main::_ = $File::Find::name;
          my $dir = _untaintDir($File::Find::dir);
          chdir($startDir);
          push( @files, $File::Find::name ) if (&$pred);
          chdir($dir);
      };
  
      File::Find::find( $wanted, $root );
  
      # Now @files has all the files that I could potentially be adding to
      # the zip. Only add the ones that are necessary.
      # For each file (updated or not), add its member name to @done.
      my %done;
      foreach my $fileName (@files) {
          my @newStat = stat($fileName);
          my $isDir   = -d _;
  
          # normalize, remove leading ./
          my $memberName = _asZipDirName( $fileName, $isDir );
          if ( $memberName eq $rootZipName ) { $memberName = $dest }
          else { $memberName =~ s{$pattern}{$dest} }
          next if $memberName =~ m{^\.?/?$};    # skip current dir
  
          $done{$memberName} = 1;
          my $changedMember = $self->updateMember( $memberName, $fileName );
          $changedMember->desiredCompressionLevel($compressionLevel);
          return _error("updateTree failed to update $fileName")
            unless ref($changedMember);
      }
  
      # @done now has the archive names corresponding to all the found files.
      # If we're mirroring, delete all those members that aren't in @done.
      if ($mirror) {
          foreach my $member ( $self->members() ) {
              $self->removeMember($member)
                unless $done{ $member->fileName() };
          }
      }
  
      return AZ_OK;
  }
  
  1;
ARCHIVE_ZIP_ARCHIVE

$fatpacked{"Archive/Zip/BufferedFileHandle.pm"} = <<'ARCHIVE_ZIP_BUFFEREDFILEHANDLE';
  package Archive::Zip::BufferedFileHandle;
  
  # File handle that uses a string internally and can seek
  # This is given as a demo for getting a zip file written
  # to a string.
  # I probably should just use IO::Scalar instead.
  # Ned Konz, March 2000
  
  use strict;
  use IO::File;
  use Carp;
  
  use vars qw{$VERSION};
  
  BEGIN {
      $VERSION = '1.30';
      $VERSION = eval $VERSION;
  }
  
  sub new {
      my $class = shift || __PACKAGE__;
      $class = ref($class) || $class;
      my $self = bless(
          {
              content  => '',
              position => 0,
              size     => 0
          },
          $class
      );
      return $self;
  }
  
  # Utility method to read entire file
  sub readFromFile {
      my $self     = shift;
      my $fileName = shift;
      my $fh       = IO::File->new( $fileName, "r" );
      CORE::binmode($fh);
      if ( !$fh ) {
          Carp::carp("Can't open $fileName: $!\n");
          return undef;
      }
      local $/ = undef;
      $self->{content} = <$fh>;
      $self->{size}    = length( $self->{content} );
      return $self;
  }
  
  sub contents {
      my $self = shift;
      if (@_) {
          $self->{content} = shift;
          $self->{size}    = length( $self->{content} );
      }
      return $self->{content};
  }
  
  sub binmode { 1 }
  
  sub close { 1 }
  
  sub opened { 1 }
  
  sub eof {
      my $self = shift;
      return $self->{position} >= $self->{size};
  }
  
  sub seek {
      my $self   = shift;
      my $pos    = shift;
      my $whence = shift;
  
      # SEEK_SET
      if ( $whence == 0 ) { $self->{position} = $pos; }
  
      # SEEK_CUR
      elsif ( $whence == 1 ) { $self->{position} += $pos; }
  
      # SEEK_END
      elsif ( $whence == 2 ) { $self->{position} = $self->{size} + $pos; }
      else                   { return 0; }
  
      return 1;
  }
  
  sub tell { return shift->{position}; }
  
  # Copy my data to given buffer
  sub read {
      my $self = shift;
      my $buf  = \( $_[0] );
      shift;
      my $len = shift;
      my $offset = shift || 0;
  
      $$buf = '' if not defined($$buf);
      my $bytesRead =
          ( $self->{position} + $len > $self->{size} )
        ? ( $self->{size} - $self->{position} )
        : $len;
      substr( $$buf, $offset, $bytesRead ) =
        substr( $self->{content}, $self->{position}, $bytesRead );
      $self->{position} += $bytesRead;
      return $bytesRead;
  }
  
  # Copy given buffer to me
  sub write {
      my $self = shift;
      my $buf  = \( $_[0] );
      shift;
      my $len = shift;
      my $offset = shift || 0;
  
      $$buf = '' if not defined($$buf);
      my $bufLen = length($$buf);
      my $bytesWritten =
        ( $offset + $len > $bufLen )
        ? $bufLen - $offset
        : $len;
      substr( $self->{content}, $self->{position}, $bytesWritten ) =
        substr( $$buf, $offset, $bytesWritten );
      $self->{size} = length( $self->{content} );
      return $bytesWritten;
  }
  
  sub clearerr() { 1 }
  
  1;
ARCHIVE_ZIP_BUFFEREDFILEHANDLE

$fatpacked{"Archive/Zip/DirectoryMember.pm"} = <<'ARCHIVE_ZIP_DIRECTORYMEMBER';
  package Archive::Zip::DirectoryMember;
  
  use strict;
  use File::Path;
  
  use vars qw( $VERSION @ISA );
  
  BEGIN {
      $VERSION = '1.30';
      @ISA     = qw( Archive::Zip::Member );
  }
  
  use Archive::Zip qw(
    :ERROR_CODES
    :UTILITY_METHODS
  );
  
  sub _newNamed {
      my $class    = shift;
      my $fileName = shift;    # FS name
      my $newName  = shift;    # Zip name
      $newName = _asZipDirName($fileName) unless $newName;
      my $self = $class->new(@_);
      $self->{'externalFileName'} = $fileName;
      $self->fileName($newName);
  
      if ( -e $fileName ) {
  
          # -e does NOT do a full stat, so we need to do one now
          if ( -d _ ) {
              my @stat = stat(_);
              $self->unixFileAttributes( $stat[2] );
              my $mod_t = $stat[9];
              if ( $^O eq 'MSWin32' and !$mod_t ) {
                  $mod_t = time();
              }
              $self->setLastModFileDateTimeFromUnix($mod_t);
  
          } else {    # hmm.. trying to add a non-directory?
              _error( $fileName, ' exists but is not a directory' );
              return undef;
          }
      } else {
          $self->unixFileAttributes( $self->DEFAULT_DIRECTORY_PERMISSIONS );
          $self->setLastModFileDateTimeFromUnix( time() );
      }
      return $self;
  }
  
  sub externalFileName {
      shift->{'externalFileName'};
  }
  
  sub isDirectory {
      return 1;
  }
  
  sub extractToFileNamed {
      my $self    = shift;
      my $name    = shift;                                 # local FS name
      my $attribs = $self->unixFileAttributes() & 07777;
      mkpath( $name, 0, $attribs );                        # croaks on error
      utime( $self->lastModTime(), $self->lastModTime(), $name );
      return AZ_OK;
  }
  
  sub fileName {
      my $self    = shift;
      my $newName = shift;
      $newName =~ s{/?$}{/} if defined($newName);
      return $self->SUPER::fileName($newName);
  }
  
  # So people don't get too confused. This way it looks like the problem
  # is in their code...
  sub contents {
      return wantarray ? ( undef, AZ_OK ) : undef;
  }
  
  1;
ARCHIVE_ZIP_DIRECTORYMEMBER

$fatpacked{"Archive/Zip/FileMember.pm"} = <<'ARCHIVE_ZIP_FILEMEMBER';
  package Archive::Zip::FileMember;
  
  use strict;
  use vars qw( $VERSION @ISA );
  
  BEGIN {
      $VERSION = '1.30';
      @ISA     = qw ( Archive::Zip::Member );
  }
  
  use Archive::Zip qw(
    :UTILITY_METHODS
  );
  
  sub externalFileName {
      shift->{'externalFileName'};
  }
  
  # Return true if I depend on the named file
  sub _usesFileNamed {
      my $self     = shift;
      my $fileName = shift;
      my $xfn      = $self->externalFileName();
      return undef if ref($xfn);
      return $xfn eq $fileName;
  }
  
  sub fh {
      my $self = shift;
      $self->_openFile()
        if !defined( $self->{'fh'} ) || !$self->{'fh'}->opened();
      return $self->{'fh'};
  }
  
  # opens my file handle from my file name
  sub _openFile {
      my $self = shift;
      my ( $status, $fh ) = _newFileHandle( $self->externalFileName(), 'r' );
      if ( !$status ) {
          _ioError( "Can't open", $self->externalFileName() );
          return undef;
      }
      $self->{'fh'} = $fh;
      _binmode($fh);
      return $fh;
  }
  
  # Make sure I close my file handle
  sub endRead {
      my $self = shift;
      undef $self->{'fh'};    # _closeFile();
      return $self->SUPER::endRead(@_);
  }
  
  sub _become {
      my $self     = shift;
      my $newClass = shift;
      return $self if ref($self) eq $newClass;
      delete( $self->{'externalFileName'} );
      delete( $self->{'fh'} );
      return $self->SUPER::_become($newClass);
  }
  
  1;
ARCHIVE_ZIP_FILEMEMBER

$fatpacked{"Archive/Zip/Member.pm"} = <<'ARCHIVE_ZIP_MEMBER';
  package Archive::Zip::Member;
  
  # A generic membet of an archive
  
  use strict;
  use vars qw( $VERSION @ISA );
  
  BEGIN {
      $VERSION = '1.30';
      @ISA     = qw( Archive::Zip );
  }
  
  use Archive::Zip qw(
    :CONSTANTS
    :MISC_CONSTANTS
    :ERROR_CODES
    :PKZIP_CONSTANTS
    :UTILITY_METHODS
  );
  
  use Time::Local ();
  use Compress::Raw::Zlib qw( Z_OK Z_STREAM_END MAX_WBITS );
  use File::Path;
  use File::Basename;
  
  use constant ZIPFILEMEMBERCLASS   => 'Archive::Zip::ZipFileMember';
  use constant NEWFILEMEMBERCLASS   => 'Archive::Zip::NewFileMember';
  use constant STRINGMEMBERCLASS    => 'Archive::Zip::StringMember';
  use constant DIRECTORYMEMBERCLASS => 'Archive::Zip::DirectoryMember';
  
  # Unix perms for default creation of files/dirs.
  use constant DEFAULT_DIRECTORY_PERMISSIONS => 040755;
  use constant DEFAULT_FILE_PERMISSIONS      => 0100666;
  use constant DIRECTORY_ATTRIB              => 040000;
  use constant FILE_ATTRIB                   => 0100000;
  
  # Returns self if successful, else undef
  # Assumes that fh is positioned at beginning of central directory file header.
  # Leaves fh positioned immediately after file header or EOCD signature.
  sub _newFromZipFile {
      my $class = shift;
      my $self  = $class->ZIPFILEMEMBERCLASS->_newFromZipFile(@_);
      return $self;
  }
  
  sub newFromString {
      my $class = shift;
  
      my ( $stringOrStringRef, $fileName );
      if ( ref( $_[0] ) eq 'HASH' ) {
          $stringOrStringRef = $_[0]->{string};
          $fileName          = $_[0]->{zipName};
      }
      else {
          ( $stringOrStringRef, $fileName ) = @_;
      }
  
      my $self  = $class->STRINGMEMBERCLASS->_newFromString( $stringOrStringRef,
          $fileName );
      return $self;
  }
  
  sub newFromFile {
      my $class = shift;
  
      my ( $fileName, $zipName );
      if ( ref( $_[0] ) eq 'HASH' ) {
          $fileName = $_[0]->{fileName};
          $zipName  = $_[0]->{zipName};
      }
      else {
          ( $fileName, $zipName ) = @_;
      }
  
      my $self = $class->NEWFILEMEMBERCLASS->_newFromFileNamed( $fileName,
        $zipName );
      return $self;
  }
  
  sub newDirectoryNamed {
      my $class = shift;
  
      my ( $directoryName, $newName );
      if ( ref( $_[0] ) eq 'HASH' ) {
          $directoryName = $_[0]->{directoryName};
          $newName       = $_[0]->{zipName};
      }
      else {
          ( $directoryName, $newName ) = @_;
      }
  
      my $self  = $class->DIRECTORYMEMBERCLASS->_newNamed( $directoryName,
          $newName );
      return $self;
  }
  
  sub new {
      my $class = shift;
      my $self  = {
          'lastModFileDateTime'      => 0,
          'fileAttributeFormat'      => FA_UNIX,
          'versionMadeBy'            => 20,
          'versionNeededToExtract'   => 20,
          'bitFlag'                  => 0,
          'compressionMethod'        => COMPRESSION_STORED,
          'desiredCompressionMethod' => COMPRESSION_STORED,
          'desiredCompressionLevel'  => COMPRESSION_LEVEL_NONE,
          'internalFileAttributes'   => 0,
          'externalFileAttributes'   => 0,                        # set later
          'fileName'                 => '',
          'cdExtraField'             => '',
          'localExtraField'          => '',
          'fileComment'              => '',
          'crc32'                    => 0,
          'compressedSize'           => 0,
          'uncompressedSize'         => 0,
          'isSymbolicLink'           => 0,
          @_
      };
      bless( $self, $class );
      $self->unixFileAttributes( $self->DEFAULT_FILE_PERMISSIONS );
      return $self;
  }
  
  sub _becomeDirectoryIfNecessary {
      my $self = shift;
      $self->_become(DIRECTORYMEMBERCLASS)
        if $self->isDirectory();
      return $self;
  }
  
  # Morph into given class (do whatever cleanup I need to do)
  sub _become {
      return bless( $_[0], $_[1] );
  }
  
  sub versionMadeBy {
      shift->{'versionMadeBy'};
  }
  
  sub fileAttributeFormat {
      my $self = shift;
  
      if (@_) {
          $self->{fileAttributeFormat} = ( ref( $_[0] ) eq 'HASH' )
          ? $_[0]->{format} : $_[0];
      }
      else {
          return $self->{fileAttributeFormat};
      }
  }
  
  sub versionNeededToExtract {
      shift->{'versionNeededToExtract'};
  }
  
  sub bitFlag {
      my $self = shift;
  
      # Set General Purpose Bit Flags according to the desiredCompressionLevel setting
      if ( $self->desiredCompressionLevel == 1 || $self->desiredCompressionLevel == 2 ) {
          $self->{'bitFlag'} = DEFLATING_COMPRESSION_FAST;
      } elsif ( $self->desiredCompressionLevel == 3 || $self->desiredCompressionLevel == 4
            || $self->desiredCompressionLevel == 5 || $self->desiredCompressionLevel == 6
            || $self->desiredCompressionLevel == 7 ) {
          $self->{'bitFlag'} = DEFLATING_COMPRESSION_NORMAL;
      } elsif ( $self->desiredCompressionLevel == 8 || $self->desiredCompressionLevel == 9 ) {
          $self->{'bitFlag'} = DEFLATING_COMPRESSION_MAXIMUM;
      }
      $self->{'bitFlag'};
  }
  
  sub compressionMethod {
      shift->{'compressionMethod'};
  }
  
  sub desiredCompressionMethod {
      my $self = shift;
      my $newDesiredCompressionMethod =
        ( ref( $_[0] ) eq 'HASH' ) ? shift->{compressionMethod} : shift;
      my $oldDesiredCompressionMethod = $self->{'desiredCompressionMethod'};
      if ( defined($newDesiredCompressionMethod) ) {
          $self->{'desiredCompressionMethod'} = $newDesiredCompressionMethod;
          if ( $newDesiredCompressionMethod == COMPRESSION_STORED ) {
              $self->{'desiredCompressionLevel'} = 0;
              $self->{'bitFlag'} &= ~GPBF_HAS_DATA_DESCRIPTOR_MASK;
  
          } elsif ( $oldDesiredCompressionMethod == COMPRESSION_STORED ) {
              $self->{'desiredCompressionLevel'} = COMPRESSION_LEVEL_DEFAULT;
          }
      }
      return $oldDesiredCompressionMethod;
  }
  
  sub desiredCompressionLevel {
      my $self = shift;
      my $newDesiredCompressionLevel =
        ( ref( $_[0] ) eq 'HASH' ) ? shift->{compressionLevel} : shift;
      my $oldDesiredCompressionLevel = $self->{'desiredCompressionLevel'};
      if ( defined($newDesiredCompressionLevel) ) {
          $self->{'desiredCompressionLevel'}  = $newDesiredCompressionLevel;
          $self->{'desiredCompressionMethod'} = (
              $newDesiredCompressionLevel
              ? COMPRESSION_DEFLATED
              : COMPRESSION_STORED
          );
      }
      return $oldDesiredCompressionLevel;
  }
  
  sub fileName {
      my $self    = shift;
      my $newName = shift;
      if ($newName) {
          $newName =~ s{[\\/]+}{/}g;    # deal with dos/windoze problems
          $self->{'fileName'} = $newName;
      }
      return $self->{'fileName'};
  }
  
  sub lastModFileDateTime {
      my $modTime = shift->{'lastModFileDateTime'};
      $modTime =~ m/^(\d+)$/;           # untaint
      return $1;
  }
  
  sub lastModTime {
      my $self = shift;
      return _dosToUnixTime( $self->lastModFileDateTime() );
  }
  
  sub setLastModFileDateTimeFromUnix {
      my $self   = shift;
      my $time_t = shift;
      $self->{'lastModFileDateTime'} = _unixToDosTime($time_t);
  }
  
  sub internalFileAttributes {
      shift->{'internalFileAttributes'};
  }
  
  sub externalFileAttributes {
      shift->{'externalFileAttributes'};
  }
  
  # Convert UNIX permissions into proper value for zip file
  # Usable as a function or a method
  sub _mapPermissionsFromUnix {
      my $self    = shift;
      my $mode    = shift;
      my $attribs = $mode << 16;
  
      # Microsoft Windows Explorer needs this bit set for directories
      if ( $mode & DIRECTORY_ATTRIB ) {
          $attribs |= 16;
      }
  
      return $attribs;
  
      # TODO: map more MS-DOS perms
  }
  
  # Convert ZIP permissions into Unix ones
  #
  # This was taken from Info-ZIP group's portable UnZip
  # zipfile-extraction program, version 5.50.
  # http://www.info-zip.org/pub/infozip/
  #
  # See the mapattr() function in unix/unix.c
  # See the attribute format constants in unzpriv.h
  #
  # XXX Note that there's one situation that isn't implemented
  # yet that depends on the "extra field."
  sub _mapPermissionsToUnix {
      my $self = shift;
  
      my $format  = $self->{'fileAttributeFormat'};
      my $attribs = $self->{'externalFileAttributes'};
  
      my $mode = 0;
  
      if ( $format == FA_AMIGA ) {
          $attribs = $attribs >> 17 & 7;                         # Amiga RWE bits
          $mode    = $attribs << 6 | $attribs << 3 | $attribs;
          return $mode;
      }
  
      if ( $format == FA_THEOS ) {
          $attribs &= 0xF1FFFFFF;
          if ( ( $attribs & 0xF0000000 ) != 0x40000000 ) {
              $attribs &= 0x01FFFFFF;    # not a dir, mask all ftype bits
          }
          else {
              $attribs &= 0x41FFFFFF;    # leave directory bit as set
          }
      }
  
      if (   $format == FA_UNIX
          || $format == FA_VAX_VMS
          || $format == FA_ACORN
          || $format == FA_ATARI_ST
          || $format == FA_BEOS
          || $format == FA_QDOS
          || $format == FA_TANDEM )
      {
          $mode = $attribs >> 16;
          return $mode if $mode != 0 or not $self->localExtraField;
  
          # warn("local extra field is: ", $self->localExtraField, "\n");
  
          # XXX This condition is not implemented
          # I'm just including the comments from the info-zip section for now.
  
          # Some (non-Info-ZIP) implementations of Zip for Unix and
          # VMS (and probably others ??) leave 0 in the upper 16-bit
          # part of the external_file_attributes field. Instead, they
          # store file permission attributes in some extra field.
          # As a work-around, we search for the presence of one of
          # these extra fields and fall back to the MSDOS compatible
          # part of external_file_attributes if one of the known
          # e.f. types has been detected.
          # Later, we might implement extraction of the permission
          # bits from the VMS extra field. But for now, the work-around
          # should be sufficient to provide "readable" extracted files.
          # (For ASI Unix e.f., an experimental remap from the e.f.
          # mode value IS already provided!)
      }
  
      # PKWARE's PKZip for Unix marks entries as FA_MSDOS, but stores the
      # Unix attributes in the upper 16 bits of the external attributes
      # field, just like Info-ZIP's Zip for Unix.  We try to use that
      # value, after a check for consistency with the MSDOS attribute
      # bits (see below).
      if ( $format == FA_MSDOS ) {
          $mode = $attribs >> 16;
      }
  
      # FA_MSDOS, FA_OS2_HPFS, FA_WINDOWS_NTFS, FA_MACINTOSH, FA_TOPS20
      $attribs = !( $attribs & 1 ) << 1 | ( $attribs & 0x10 ) >> 4;
  
      # keep previous $mode setting when its "owner"
      # part appears to be consistent with DOS attribute flags!
      return $mode if ( $mode & 0700 ) == ( 0400 | $attribs << 6 );
      $mode = 0444 | $attribs << 6 | $attribs << 3 | $attribs;
      return $mode;
  }
  
  sub unixFileAttributes {
      my $self     = shift;
      my $oldPerms = $self->_mapPermissionsToUnix;
  
      my $perms;
      if ( @_ ) {
          $perms = ( ref( $_[0] ) eq 'HASH' ) ? $_[0]->{attributes} : $_[0];
  
          if ( $self->isDirectory ) {
              $perms &= ~FILE_ATTRIB;
              $perms |= DIRECTORY_ATTRIB;
          } else {
              $perms &= ~DIRECTORY_ATTRIB;
              $perms |= FILE_ATTRIB;
          }
          $self->{externalFileAttributes} = $self->_mapPermissionsFromUnix($perms);
      }
  
      return $oldPerms;
  }
  
  sub localExtraField {
      my $self = shift;
  
      if (@_) {
          $self->{localExtraField} = ( ref( $_[0] ) eq 'HASH' )
            ? $_[0]->{field} : $_[0];
      }
      else {
          return $self->{localExtraField};
      }
  }
  
  sub cdExtraField {
      my $self = shift;
  
      if (@_) {
          $self->{cdExtraField} = ( ref( $_[0] ) eq 'HASH' )
            ? $_[0]->{field} : $_[0];
      }
      else {
          return $self->{cdExtraField};
      }
  }
  
  sub extraFields {
      my $self = shift;
      return $self->localExtraField() . $self->cdExtraField();
  }
  
  sub fileComment {
      my $self = shift;
  
      if (@_) {
          $self->{fileComment} = ( ref( $_[0] ) eq 'HASH' )
            ? pack( 'C0a*', $_[0]->{comment} ) : pack( 'C0a*', $_[0] );
      }
      else {
          return $self->{fileComment};
      }
  }
  
  sub hasDataDescriptor {
      my $self = shift;
      if (@_) {
          my $shouldHave = shift;
          if ($shouldHave) {
              $self->{'bitFlag'} |= GPBF_HAS_DATA_DESCRIPTOR_MASK;
          }
          else {
              $self->{'bitFlag'} &= ~GPBF_HAS_DATA_DESCRIPTOR_MASK;
          }
      }
      return $self->{'bitFlag'} & GPBF_HAS_DATA_DESCRIPTOR_MASK;
  }
  
  sub crc32 {
      shift->{'crc32'};
  }
  
  sub crc32String {
      sprintf( "%08x", shift->{'crc32'} );
  }
  
  sub compressedSize {
      shift->{'compressedSize'};
  }
  
  sub uncompressedSize {
      shift->{'uncompressedSize'};
  }
  
  sub isEncrypted {
      shift->bitFlag() & GPBF_ENCRYPTED_MASK;
  }
  
  sub isTextFile {
      my $self = shift;
      my $bit  = $self->internalFileAttributes() & IFA_TEXT_FILE_MASK;
      if (@_) {
          my $flag = ( ref( $_[0] ) eq 'HASH' ) ? shift->{flag} : shift;
          $self->{'internalFileAttributes'} &= ~IFA_TEXT_FILE_MASK;
          $self->{'internalFileAttributes'} |=
            ( $flag ? IFA_TEXT_FILE: IFA_BINARY_FILE );
      }
      return $bit == IFA_TEXT_FILE;
  }
  
  sub isBinaryFile {
      my $self = shift;
      my $bit  = $self->internalFileAttributes() & IFA_TEXT_FILE_MASK;
      if (@_) {
          my $flag = shift;
          $self->{'internalFileAttributes'} &= ~IFA_TEXT_FILE_MASK;
          $self->{'internalFileAttributes'} |=
            ( $flag ? IFA_BINARY_FILE: IFA_TEXT_FILE );
      }
      return $bit == IFA_BINARY_FILE;
  }
  
  sub extractToFileNamed {
      my $self = shift;
  
      # local FS name
      my $name = ( ref( $_[0] ) eq 'HASH' ) ? $_[0]->{name} : $_[0];
      $self->{'isSymbolicLink'} = 0;
  
      # Check if the file / directory is a symbolic link or not
      if ( $self->{'externalFileAttributes'} == 0xA1FF0000 ) {
          $self->{'isSymbolicLink'} = 1;
          $self->{'newName'} = $name;
          my ( $status, $fh ) = _newFileHandle( $name, 'r' );
          my $retval = $self->extractToFileHandle($fh);
          $fh->close();
      } else {
          #return _writeSymbolicLink($self, $name) if $self->isSymbolicLink();
          return _error("encryption unsupported") if $self->isEncrypted();
          mkpath( dirname($name) );    # croaks on error
          my ( $status, $fh ) = _newFileHandle( $name, 'w' );
          return _ioError("Can't open file $name for write") unless $status;
          my $retval = $self->extractToFileHandle($fh);
          $fh->close();
          chmod ($self->unixFileAttributes(), $name)
              or return _error("Can't chmod() ${name}: $!");
          utime( $self->lastModTime(), $self->lastModTime(), $name );
          return $retval;
      }
  }
  
  sub _writeSymbolicLink {
      my $self = shift;
      my $name = shift;
      my $chunkSize = $Archive::Zip::ChunkSize;
      #my ( $outRef, undef ) = $self->readChunk($chunkSize);
      my $fh;
      my $retval = $self->extractToFileHandle($fh);
      my ( $outRef, undef ) = $self->readChunk(100);
  }
  
  sub isSymbolicLink {
      my $self = shift;
      if ( $self->{'externalFileAttributes'} == 0xA1FF0000 ) {
          $self->{'isSymbolicLink'} = 1;
      } else {
          return 0;
      }
      1;
  }
  
  sub isDirectory {
      return 0;
  }
  
  sub externalFileName {
      return undef;
  }
  
  # The following are used when copying data
  sub _writeOffset {
      shift->{'writeOffset'};
  }
  
  sub _readOffset {
      shift->{'readOffset'};
  }
  
  sub writeLocalHeaderRelativeOffset {
      shift->{'writeLocalHeaderRelativeOffset'};
  }
  
  sub wasWritten { shift->{'wasWritten'} }
  
  sub _dataEnded {
      shift->{'dataEnded'};
  }
  
  sub _readDataRemaining {
      shift->{'readDataRemaining'};
  }
  
  sub _inflater {
      shift->{'inflater'};
  }
  
  sub _deflater {
      shift->{'deflater'};
  }
  
  # Return the total size of my local header
  sub _localHeaderSize {
      my $self = shift;
      return SIGNATURE_LENGTH + LOCAL_FILE_HEADER_LENGTH +
        length( $self->fileName() ) + length( $self->localExtraField() );
  }
  
  # Return the total size of my CD header
  sub _centralDirectoryHeaderSize {
      my $self = shift;
      return SIGNATURE_LENGTH + CENTRAL_DIRECTORY_FILE_HEADER_LENGTH +
        length( $self->fileName() ) + length( $self->cdExtraField() ) +
        length( $self->fileComment() );
  }
  
  # DOS date/time format
  # 0-4 (5) Second divided by 2
  # 5-10 (6) Minute (0-59)
  # 11-15 (5) Hour (0-23 on a 24-hour clock)
  # 16-20 (5) Day of the month (1-31)
  # 21-24 (4) Month (1 = January, 2 = February, etc.)
  # 25-31 (7) Year offset from 1980 (add 1980 to get actual year)
  
  # Convert DOS date/time format to unix time_t format
  # NOT AN OBJECT METHOD!
  sub _dosToUnixTime {
      my $dt = shift;
      return time() unless defined($dt);
  
      my $year = ( ( $dt >> 25 ) & 0x7f ) + 80;
      my $mon  = ( ( $dt >> 21 ) & 0x0f ) - 1;
      my $mday = ( ( $dt >> 16 ) & 0x1f );
  
      my $hour = ( ( $dt >> 11 ) & 0x1f );
      my $min  = ( ( $dt >> 5 ) & 0x3f );
      my $sec  = ( ( $dt << 1 ) & 0x3e );
  
      # catch errors
      my $time_t =
        eval { Time::Local::timelocal( $sec, $min, $hour, $mday, $mon, $year ); };
      return time() if ($@);
      return $time_t;
  }
  
  # Note, this isn't exactly UTC 1980, it's 1980 + 12 hours and 1
  # minute so that nothing timezoney can muck us up.
  my $safe_epoch = 315576060;
  
  # convert a unix time to DOS date/time
  # NOT AN OBJECT METHOD!
  sub _unixToDosTime {
      my $time_t = shift;
      unless ($time_t) {
          _error("Tried to add member with zero or undef value for time");
          $time_t = $safe_epoch;
      }
      if ( $time_t < $safe_epoch ) {
          _ioError("Unsupported date before 1980 encountered, moving to 1980");
          $time_t = $safe_epoch;
      }
      my ( $sec, $min, $hour, $mday, $mon, $year ) = localtime($time_t);
      my $dt = 0;
      $dt += ( $sec >> 1 );
      $dt += ( $min << 5 );
      $dt += ( $hour << 11 );
      $dt += ( $mday << 16 );
      $dt += ( ( $mon + 1 ) << 21 );
      $dt += ( ( $year - 80 ) << 25 );
      return $dt;
  }
  
  # Write my local header to a file handle.
  # Stores the offset to the start of the header in my
  # writeLocalHeaderRelativeOffset member.
  # Returns AZ_OK on success.
  sub _writeLocalFileHeader {
      my $self = shift;
      my $fh   = shift;
  
      my $signatureData = pack( SIGNATURE_FORMAT, LOCAL_FILE_HEADER_SIGNATURE );
      $self->_print($fh, $signatureData)
        or return _ioError("writing local header signature");
  
      my $header = pack(
          LOCAL_FILE_HEADER_FORMAT,
          $self->versionNeededToExtract(),
          $self->bitFlag(),
          $self->desiredCompressionMethod(),
          $self->lastModFileDateTime(),
          $self->crc32(),
          $self->compressedSize(),    # may need to be re-written later
          $self->uncompressedSize(),
          length( $self->fileName() ),
          length( $self->localExtraField() )
      );
  
      $self->_print($fh, $header) or return _ioError("writing local header");
  
      # Check for a valid filename or a filename equal to a literal `0'
      if ( $self->fileName() || $self->fileName eq '0' ) {
          $self->_print($fh, $self->fileName() )
            or return _ioError("writing local header filename");
      }
      if ( $self->localExtraField() ) {
          $self->_print($fh, $self->localExtraField() )
            or return _ioError("writing local extra field");
      }
  
      return AZ_OK;
  }
  
  sub _writeCentralDirectoryFileHeader {
      my $self = shift;
      my $fh   = shift;
  
      my $sigData =
        pack( SIGNATURE_FORMAT, CENTRAL_DIRECTORY_FILE_HEADER_SIGNATURE );
      $self->_print($fh, $sigData)
        or return _ioError("writing central directory header signature");
  
      my $fileNameLength    = length( $self->fileName() );
      my $extraFieldLength  = length( $self->cdExtraField() );
      my $fileCommentLength = length( $self->fileComment() );
  
      my $header = pack(
          CENTRAL_DIRECTORY_FILE_HEADER_FORMAT,
          $self->versionMadeBy(),
          $self->fileAttributeFormat(),
          $self->versionNeededToExtract(),
          $self->bitFlag(),
          $self->desiredCompressionMethod(),
          $self->lastModFileDateTime(),
          $self->crc32(),            # these three fields should have been updated
          $self->_writeOffset(),     # by writing the data stream out
          $self->uncompressedSize(), #
          $fileNameLength,
          $extraFieldLength,
          $fileCommentLength,
          0,                         # {'diskNumberStart'},
          $self->internalFileAttributes(),
          $self->externalFileAttributes(),
          $self->writeLocalHeaderRelativeOffset()
      );
  
      $self->_print($fh, $header)
        or return _ioError("writing central directory header");
      if ($fileNameLength) {
          $self->_print($fh,  $self->fileName() )
            or return _ioError("writing central directory header signature");
      }
      if ($extraFieldLength) {
          $self->_print($fh,  $self->cdExtraField() )
            or return _ioError("writing central directory extra field");
      }
      if ($fileCommentLength) {
          $self->_print($fh,  $self->fileComment() )
            or return _ioError("writing central directory file comment");
      }
  
      return AZ_OK;
  }
  
  # This writes a data descriptor to the given file handle.
  # Assumes that crc32, writeOffset, and uncompressedSize are
  # set correctly (they should be after a write).
  # Further, the local file header should have the
  # GPBF_HAS_DATA_DESCRIPTOR_MASK bit set.
  sub _writeDataDescriptor {
      my $self   = shift;
      my $fh     = shift;
      my $header = pack(
          SIGNATURE_FORMAT . DATA_DESCRIPTOR_FORMAT,
          DATA_DESCRIPTOR_SIGNATURE,
          $self->crc32(),
          $self->_writeOffset(),    # compressed size
          $self->uncompressedSize()
      );
  
      $self->_print($fh, $header)
        or return _ioError("writing data descriptor");
      return AZ_OK;
  }
  
  # Re-writes the local file header with new crc32 and compressedSize fields.
  # To be called after writing the data stream.
  # Assumes that filename and extraField sizes didn't change since last written.
  sub _refreshLocalFileHeader {
      my $self = shift;
      my $fh   = shift;
  
      my $here = $fh->tell();
      $fh->seek( $self->writeLocalHeaderRelativeOffset() + SIGNATURE_LENGTH,
          IO::Seekable::SEEK_SET )
        or return _ioError("seeking to rewrite local header");
  
      my $header = pack(
          LOCAL_FILE_HEADER_FORMAT,
          $self->versionNeededToExtract(),
          $self->bitFlag(),
          $self->desiredCompressionMethod(),
          $self->lastModFileDateTime(),
          $self->crc32(),
          $self->_writeOffset(),    # compressed size
          $self->uncompressedSize(),
          length( $self->fileName() ),
          length( $self->localExtraField() )
      );
  
      $self->_print($fh, $header)
        or return _ioError("re-writing local header");
      $fh->seek( $here, IO::Seekable::SEEK_SET )
        or return _ioError("seeking after rewrite of local header");
  
      return AZ_OK;
  }
  
  sub readChunk {
      my $self = shift;
      my $chunkSize = ( ref( $_[0] ) eq 'HASH' ) ? $_[0]->{chunkSize} : $_[0];
  
      if ( $self->readIsDone() ) {
          $self->endRead();
          my $dummy = '';
          return ( \$dummy, AZ_STREAM_END );
      }
  
      $chunkSize = $Archive::Zip::ChunkSize if not defined($chunkSize);
      $chunkSize = $self->_readDataRemaining()
        if $chunkSize > $self->_readDataRemaining();
  
      my $buffer = '';
      my $outputRef;
      my ( $bytesRead, $status ) = $self->_readRawChunk( \$buffer, $chunkSize );
      return ( \$buffer, $status ) unless $status == AZ_OK;
  
      $self->{'readDataRemaining'} -= $bytesRead;
      $self->{'readOffset'} += $bytesRead;
  
      if ( $self->compressionMethod() == COMPRESSION_STORED ) {
          $self->{'crc32'} = $self->computeCRC32( $buffer, $self->{'crc32'} );
      }
  
      ( $outputRef, $status ) = &{ $self->{'chunkHandler'} }( $self, \$buffer );
      $self->{'writeOffset'} += length($$outputRef);
  
      $self->endRead()
        if $self->readIsDone();
  
      return ( $outputRef, $status );
  }
  
  # Read the next raw chunk of my data. Subclasses MUST implement.
  #	my ( $bytesRead, $status) = $self->_readRawChunk( \$buffer, $chunkSize );
  sub _readRawChunk {
      my $self = shift;
      return $self->_subclassResponsibility();
  }
  
  # A place holder to catch rewindData errors if someone ignores
  # the error code.
  sub _noChunk {
      my $self = shift;
      return ( \undef, _error("trying to copy chunk when init failed") );
  }
  
  # Basically a no-op so that I can have a consistent interface.
  # ( $outputRef, $status) = $self->_copyChunk( \$buffer );
  sub _copyChunk {
      my ( $self, $dataRef ) = @_;
      return ( $dataRef, AZ_OK );
  }
  
  # ( $outputRef, $status) = $self->_deflateChunk( \$buffer );
  sub _deflateChunk {
      my ( $self, $buffer ) = @_;
      my ( $status ) = $self->_deflater()->deflate( $buffer, my $out );
  
      if ( $self->_readDataRemaining() == 0 ) {
          my $extraOutput;
          ( $status ) = $self->_deflater()->flush($extraOutput);
          $out .= $extraOutput;
          $self->endRead();
          return ( \$out, AZ_STREAM_END );
      }
      elsif ( $status == Z_OK ) {
          return ( \$out, AZ_OK );
      }
      else {
          $self->endRead();
          my $retval = _error( 'deflate error', $status );
          my $dummy = '';
          return ( \$dummy, $retval );
      }
  }
  
  # ( $outputRef, $status) = $self->_inflateChunk( \$buffer );
  sub _inflateChunk {
      my ( $self, $buffer ) = @_;
      my ( $status ) = $self->_inflater()->inflate( $buffer, my $out );
      my $retval;
      $self->endRead() unless $status == Z_OK;
      if ( $status == Z_OK || $status == Z_STREAM_END ) {
          $retval = ( $status == Z_STREAM_END ) ? AZ_STREAM_END: AZ_OK;
          return ( \$out, $retval );
      }
      else {
          $retval = _error( 'inflate error', $status );
          my $dummy = '';
          return ( \$dummy, $retval );
      }
  }
  
  sub rewindData {
      my $self = shift;
      my $status;
  
      # set to trap init errors
      $self->{'chunkHandler'} = $self->can('_noChunk');
  
      # Work around WinZip bug with 0-length DEFLATED files
      $self->desiredCompressionMethod(COMPRESSION_STORED)
        if $self->uncompressedSize() == 0;
  
      # assume that we're going to read the whole file, and compute the CRC anew.
      $self->{'crc32'} = 0
        if ( $self->compressionMethod() == COMPRESSION_STORED );
  
      # These are the only combinations of methods we deal with right now.
      if (    $self->compressionMethod() == COMPRESSION_STORED
          and $self->desiredCompressionMethod() == COMPRESSION_DEFLATED )
      {
          ( $self->{'deflater'}, $status ) = Compress::Raw::Zlib::Deflate->new(
              '-Level'      => $self->desiredCompressionLevel(),
              '-WindowBits' => -MAX_WBITS(),                     # necessary magic
              '-Bufsize'    => $Archive::Zip::ChunkSize,
              @_
          );    # pass additional options
          return _error( 'deflateInit error:', $status )
            unless $status == Z_OK;
          $self->{'chunkHandler'} = $self->can('_deflateChunk');
      }
      elsif ( $self->compressionMethod() == COMPRESSION_DEFLATED
          and $self->desiredCompressionMethod() == COMPRESSION_STORED )
      {
          ( $self->{'inflater'}, $status ) = Compress::Raw::Zlib::Inflate->new(
              '-WindowBits' => -MAX_WBITS(),               # necessary magic
              '-Bufsize'    => $Archive::Zip::ChunkSize,
              @_
          );    # pass additional options
          return _error( 'inflateInit error:', $status )
            unless $status == Z_OK;
          $self->{'chunkHandler'} = $self->can('_inflateChunk');
      }
      elsif ( $self->compressionMethod() == $self->desiredCompressionMethod() ) {
          $self->{'chunkHandler'} = $self->can('_copyChunk');
      }
      else {
          return _error(
              sprintf(
                  "Unsupported compression combination: read %d, write %d",
                  $self->compressionMethod(),
                  $self->desiredCompressionMethod()
              )
          );
      }
  
      $self->{'readDataRemaining'} =
        ( $self->compressionMethod() == COMPRESSION_STORED )
        ? $self->uncompressedSize()
        : $self->compressedSize();
      $self->{'dataEnded'}  = 0;
      $self->{'readOffset'} = 0;
  
      return AZ_OK;
  }
  
  sub endRead {
      my $self = shift;
      delete $self->{'inflater'};
      delete $self->{'deflater'};
      $self->{'dataEnded'}         = 1;
      $self->{'readDataRemaining'} = 0;
      return AZ_OK;
  }
  
  sub readIsDone {
      my $self = shift;
      return ( $self->_dataEnded() or !$self->_readDataRemaining() );
  }
  
  sub contents {
      my $self        = shift;
      my $newContents = shift;
  
      if ( defined($newContents) ) {
  
          # change our type and call the subclass contents method.
          $self->_become(STRINGMEMBERCLASS);
          return $self->contents( pack( 'C0a*', $newContents ) )
            ;    # in case of Unicode
      }
      else {
          my $oldCompression =
            $self->desiredCompressionMethod(COMPRESSION_STORED);
          my $status = $self->rewindData(@_);
          if ( $status != AZ_OK ) {
              $self->endRead();
              return $status;
          }
          my $retval = '';
          while ( $status == AZ_OK ) {
              my $ref;
              ( $ref, $status ) = $self->readChunk( $self->_readDataRemaining() );
  
              # did we get it in one chunk?
              if ( length($$ref) == $self->uncompressedSize() ) {
                  $retval = $$ref;
              }
              else { $retval .= $$ref }
          }
          $self->desiredCompressionMethod($oldCompression);
          $self->endRead();
          $status = AZ_OK if $status == AZ_STREAM_END;
          $retval = undef unless $status == AZ_OK;
          return wantarray ? ( $retval, $status ) : $retval;
      }
  }
  
  sub extractToFileHandle {
      my $self = shift;
      return _error("encryption unsupported") if $self->isEncrypted();
      my $fh = ( ref( $_[0] ) eq 'HASH' ) ? shift->{fileHandle} : shift;
      _binmode($fh);
      my $oldCompression = $self->desiredCompressionMethod(COMPRESSION_STORED);
      my $status         = $self->rewindData(@_);
      $status = $self->_writeData($fh) if $status == AZ_OK;
      $self->desiredCompressionMethod($oldCompression);
      $self->endRead();
      return $status;
  }
  
  # write local header and data stream to file handle
  sub _writeToFileHandle {
      my $self         = shift;
      my $fh           = shift;
      my $fhIsSeekable = shift;
      my $offset       = shift;
  
      return _error("no member name given for $self")
        if $self->fileName() eq '';
  
      $self->{'writeLocalHeaderRelativeOffset'} = $offset;
      $self->{'wasWritten'}                     = 0;
  
      # Determine if I need to write a data descriptor
      # I need to do this if I can't refresh the header
      # and I don't know compressed size or crc32 fields.
      my $headerFieldsUnknown = (
          ( $self->uncompressedSize() > 0 )
            and ($self->compressionMethod() == COMPRESSION_STORED
              or $self->desiredCompressionMethod() == COMPRESSION_DEFLATED )
      );
  
      my $shouldWriteDataDescriptor =
        ( $headerFieldsUnknown and not $fhIsSeekable );
  
      $self->hasDataDescriptor(1)
        if ($shouldWriteDataDescriptor);
  
      $self->{'writeOffset'} = 0;
  
      my $status = $self->rewindData();
      ( $status = $self->_writeLocalFileHeader($fh) )
        if $status == AZ_OK;
      ( $status = $self->_writeData($fh) )
        if $status == AZ_OK;
      if ( $status == AZ_OK ) {
          $self->{'wasWritten'} = 1;
          if ( $self->hasDataDescriptor() ) {
              $status = $self->_writeDataDescriptor($fh);
          }
          elsif ($headerFieldsUnknown) {
              $status = $self->_refreshLocalFileHeader($fh);
          }
      }
  
      return $status;
  }
  
  # Copy my (possibly compressed) data to given file handle.
  # Returns C<AZ_OK> on success
  sub _writeData {
      my $self    = shift;
      my $writeFh = shift;
  
      # If symbolic link, just create one if the operating system is Linux, Unix, BSD or VMS
      # TODO: Add checks for other operating systems
      if ( $self->{'isSymbolicLink'} == 1 && $^O eq 'linux' ) {
          my $chunkSize = $Archive::Zip::ChunkSize;
          my ( $outRef, $status ) = $self->readChunk($chunkSize);
          symlink $$outRef, $self->{'newName'};
      } else {
          return AZ_OK if ( $self->uncompressedSize() == 0 );
          my $status;
          my $chunkSize = $Archive::Zip::ChunkSize;
          while ( $self->_readDataRemaining() > 0 ) {
              my $outRef;
              ( $outRef, $status ) = $self->readChunk($chunkSize);
              return $status if ( $status != AZ_OK and $status != AZ_STREAM_END );
  
              if ( length($$outRef) > 0 ) {
                  $self->_print($writeFh, $$outRef)
                    or return _ioError("write error during copy");
              }
  
              last if $status == AZ_STREAM_END;
          }
          $self->{'compressedSize'} = $self->_writeOffset();
      }
      return AZ_OK;
  }
  
  # Return true if I depend on the named file
  sub _usesFileNamed {
      return 0;
  }
  
  1;
ARCHIVE_ZIP_MEMBER

$fatpacked{"Archive/Zip/MemberRead.pm"} = <<'ARCHIVE_ZIP_MEMBERREAD';
  package Archive::Zip::MemberRead;
  
  =head1 NAME
  
  Archive::Zip::MemberRead - A wrapper that lets you read Zip archive members as if they were files.
  
  =cut
  
  =head1 SYNOPSIS
  
    use Archive::Zip;
    use Archive::Zip::MemberRead;
    $zip = Archive::Zip->new("file.zip");
    $fh  = Archive::Zip::MemberRead->new($zip, "subdir/abc.txt");
    while (defined($line = $fh->getline()))
    {
        print $fh->input_line_number . "#: $line\n";
    }
  
    $read = $fh->read($buffer, 32*1024);
    print "Read $read bytes as :$buffer:\n";
  
  =head1 DESCRIPTION
  
  The Archive::Zip::MemberRead module lets you read Zip archive member data
  just like you read data from files.
  
  =head1 METHODS
  
  =over 4
  
  =cut
  
  use strict;
  
  use Archive::Zip qw( :ERROR_CODES :CONSTANTS );
  
  use vars qw{$VERSION};
  
  my $nl;
  
  BEGIN {
      $VERSION = '1.30';
      $VERSION = eval $VERSION;
       # Requirement for newline conversion. Should check for e.g., DOS and OS/2 as well, but am too lazy.
       $nl = $^O eq 'MSWin32' ? "\r\n" : "\n";
  }
  
  =item Archive::Zip::Member::readFileHandle()
  
  You can get a C<Archive::Zip::MemberRead> from an archive member by
  calling C<readFileHandle()>:
  
    my $member = $zip->memberNamed('abc/def.c');
    my $fh = $member->readFileHandle();
    while (defined($line = $fh->getline()))
    {
        # ...
    }
    $fh->close();
  
  =cut
  
  sub Archive::Zip::Member::readFileHandle {
      return Archive::Zip::MemberRead->new( shift() );
  }
  
  =item Archive::Zip::MemberRead->new($zip, $fileName)
  
  =item Archive::Zip::MemberRead->new($zip, $member)
  
  =item Archive::Zip::MemberRead->new($member)
  
  Construct a new Archive::Zip::MemberRead on the specified member.
  
    my $fh = Archive::Zip::MemberRead->new($zip, 'fred.c')
  
  =cut
  
  sub new {
      my ( $class, $zip, $file ) = @_;
      my ( $self, $member );
  
      if ( $zip && $file )    # zip and filename, or zip and member
      {
          $member = ref($file) ? $file : $zip->memberNamed($file);
      }
      elsif ( $zip && !$file && ref($zip) )    # just member
      {
          $member = $zip;
      }
      else {
          die(
  'Archive::Zip::MemberRead::new needs a zip and filename, zip and member, or member'
          );
      }
  
      $self = {};
      bless( $self, $class );
      $self->set_member($member);
      return $self;
  }
  
  sub set_member {
      my ( $self, $member ) = @_;
  
      $self->{member} = $member;
      $self->set_compression(COMPRESSION_STORED);
      $self->rewind();
  }
  
  sub set_compression {
      my ( $self, $compression ) = @_;
      $self->{member}->desiredCompressionMethod($compression) if $self->{member};
  }
  
  =item setLineEnd(expr)
  
  Set the line end character to use. This is set to \n by default
  except on Windows systems where it is set to \r\n. You will
  only need to set this on systems which are not Windows or Unix
  based and require a line end diffrent from \n.
  This is a class method so call as C<Archive::Zip::MemberRead>->C<setLineEnd($nl)>
  
  =cut
  
  sub setLineEnd {
      shift;
      $nl = shift;
  }
  
  =item rewind()
  
  Rewinds an C<Archive::Zip::MemberRead> so that you can read from it again
  starting at the beginning.
  
  =cut
  
  sub rewind {
      my $self = shift;
  
      $self->_reset_vars();
      $self->{member}->rewindData() if $self->{member};
  }
  
  sub _reset_vars {
      my $self = shift;
  
      $self->{line_no} = 0;
      $self->{at_end}  = 0;
  
      delete $self->{buffer};
  }
  
  =item input_record_separator(expr)
  
  If the argumnet is given, input_record_separator for this
  instance is set to it. The current setting (which may be
  the global $/) is always returned.
  
  =cut
  
  sub input_record_separator {
      my $self = shift;
       if (@_) {
           $self->{sep}    = shift;
           $self->{sep_re} = _sep_as_re($self->{sep}); # Cache the RE as an optimization
       }
       return exists $self->{sep} ? $self->{sep} : $/;
  }
  
  # Return the input_record_separator in use as an RE fragment
  # Note that if we have a per-instance input_record_separator
  # we can just return the already converted value. Otherwise,
  # the conversion must be done on $/ every time since we cannot
  # know whether it has changed or not.
  sub _sep_re {
      my $self = shift;
      # Important to phrase this way: sep's value may be undef.
      return exists $self->{sep} ? $self->{sep_re} : _sep_as_re($/);
  }
  
  # Convert the input record separator into an RE and return it.
  sub _sep_as_re {
      my $sep = shift;
      if (defined $sep) {
          if ($sep eq '') {
              return "(?:$nl){2,}";
          } else {
              $sep =~ s/\n/$nl/og;
              return quotemeta $sep;
          }
      } else {
          return undef;
      }
  }
  
  =item input_line_number()
  
  Returns the current line number, but only if you're using C<getline()>.
  Using C<read()> will not update the line number.
  
  =cut
  
  sub input_line_number {
      my $self = shift;
      return $self->{line_no};
  }
  
  =item close()
  
  Closes the given file handle.
  
  =cut
  
  sub close {
      my $self = shift;
  
      $self->_reset_vars();
      $self->{member}->endRead();
  }
  
  =item buffer_size([ $size ])
  
  Gets or sets the buffer size used for reads.
  Default is the chunk size used by Archive::Zip.
  
  =cut
  
  sub buffer_size {
      my ( $self, $size ) = @_;
  
      if ( !$size ) {
          return $self->{chunkSize} || Archive::Zip::chunkSize();
      }
      else {
          $self->{chunkSize} = $size;
      }
  }
  
  =item getline()
  
  Returns the next line from the currently open member.
  Makes sense only for text files.
  A read error is considered fatal enough to die.
  Returns undef on eof. All subsequent calls would return undef,
  unless a rewind() is called.
  Note: The line returned has the input_record_separator (default: newline) removed.
  
  =cut
  
  sub getline {
      my $self = shift;
      my $size = $self->buffer_size();
      my $sep  = $self->_sep_re();
  
      for (;;) {
          if (   $sep
              && defined($self->{buffer})
              && $self->{buffer} =~ s/^(.*?)$sep//s
             ) {
              $self->{line_no}++;
              return $1;
          } elsif ($self->{at_end}) {
              $self->{line_no}++ if $self->{buffer};
              return delete $self->{buffer};
          }
          my ($temp,$status) = $self->{member}->readChunk($size);
          if ($status != AZ_OK && $status != AZ_STREAM_END) {
              die "ERROR: Error reading chunk from archive - $status";
          }
          $self->{at_end} = $status == AZ_STREAM_END;
          $self->{buffer} .= $$temp;
      }
  }
  
  =item read($buffer, $num_bytes_to_read)
  
  Simulates a normal C<read()> system call.
  Returns the no. of bytes read. C<undef> on error, 0 on eof, I<e.g.>:
  
    $fh = Archive::Zip::MemberRead->new($zip, "sreeji/secrets.bin");
    while (1)
    {
      $read = $fh->read($buffer, 1024);
      die "FATAL ERROR reading my secrets !\n" if (!defined($read));
      last if (!$read);
      # Do processing.
      ....
     }
  
  =cut
  
  #
  # All these $_ are required to emulate read().
  #
  sub read {
      my $self = $_[0];
      my $size = $_[2];
      my ( $temp, $status, $ret );
  
      ( $temp, $status ) = $self->{member}->readChunk($size);
      if ( $status != AZ_OK && $status != AZ_STREAM_END ) {
          $_[1] = undef;
          $ret = undef;
      }
      else {
          $_[1] = $$temp;
          $ret = length($$temp);
      }
      return $ret;
  }
  
  1;
  
  =back
  
  =head1 AUTHOR
  
  Sreeji K. Das, <sreeji_k@yahoo.com>
  See L<Archive::Zip> by Ned Konz without which this module does not make
  any sense! 
  
  Minor mods by Ned Konz.
  
  =head1 COPYRIGHT
  
  Copyright 2002 Sreeji K. Das.
  
  This program is free software; you can redistribute it and/or modify it under
  the same terms as Perl itself.
  
  =cut
ARCHIVE_ZIP_MEMBERREAD

$fatpacked{"Archive/Zip/MockFileHandle.pm"} = <<'ARCHIVE_ZIP_MOCKFILEHANDLE';
  package Archive::Zip::MockFileHandle;
  
  # Output file handle that calls a custom write routine
  # Ned Konz, March 2000
  # This is provided to help with writing zip files
  # when you have to process them a chunk at a time.
  
  use strict;
  
  use vars qw{$VERSION};
  
  BEGIN {
      $VERSION = '1.30';
      $VERSION = eval $VERSION;
  }
  
  sub new {
      my $class = shift || __PACKAGE__;
      $class = ref($class) || $class;
      my $self = bless(
          {
              'position' => 0,
              'size'     => 0
          },
          $class
      );
      return $self;
  }
  
  sub eof {
      my $self = shift;
      return $self->{'position'} >= $self->{'size'};
  }
  
  # Copy given buffer to me
  sub print {
      my $self         = shift;
      my $bytes        = join( '', @_ );
      my $bytesWritten = $self->writeHook($bytes);
      if ( $self->{'position'} + $bytesWritten > $self->{'size'} ) {
          $self->{'size'} = $self->{'position'} + $bytesWritten;
      }
      $self->{'position'} += $bytesWritten;
      return $bytesWritten;
  }
  
  # Called on each write.
  # Override in subclasses.
  # Return number of bytes written (0 on error).
  sub writeHook {
      my $self  = shift;
      my $bytes = shift;
      return length($bytes);
  }
  
  sub binmode { 1 }
  
  sub close { 1 }
  
  sub clearerr { 1 }
  
  # I'm write-only!
  sub read { 0 }
  
  sub tell { return shift->{'position'} }
  
  sub opened { 1 }
  
  1;
ARCHIVE_ZIP_MOCKFILEHANDLE

$fatpacked{"Archive/Zip/NewFileMember.pm"} = <<'ARCHIVE_ZIP_NEWFILEMEMBER';
  package Archive::Zip::NewFileMember;
  
  use strict;
  use vars qw( $VERSION @ISA );
  
  BEGIN {
      $VERSION = '1.30';
      @ISA     = qw ( Archive::Zip::FileMember );
  }
  
  use Archive::Zip qw(
    :CONSTANTS
    :ERROR_CODES
    :UTILITY_METHODS
  );
  
  # Given a file name, set up for eventual writing.
  sub _newFromFileNamed {
      my $class    = shift;
      my $fileName = shift;    # local FS format
      my $newName  = shift;
      $newName = _asZipDirName($fileName) unless defined($newName);
      return undef unless ( stat($fileName) && -r _ && !-d _ );
      my $self = $class->new(@_);
      $self->{'fileName'} = $newName;
      $self->{'externalFileName'}  = $fileName;
      $self->{'compressionMethod'} = COMPRESSION_STORED;
      my @stat = stat(_);
      $self->{'compressedSize'} = $self->{'uncompressedSize'} = $stat[7];
      $self->desiredCompressionMethod(
          ( $self->compressedSize() > 0 )
          ? COMPRESSION_DEFLATED
          : COMPRESSION_STORED
      );
      $self->unixFileAttributes( $stat[2] );
      $self->setLastModFileDateTimeFromUnix( $stat[9] );
      $self->isTextFile( -T _ );
      return $self;
  }
  
  sub rewindData {
      my $self = shift;
  
      my $status = $self->SUPER::rewindData(@_);
      return $status unless $status == AZ_OK;
  
      return AZ_IO_ERROR unless $self->fh();
      $self->fh()->clearerr();
      $self->fh()->seek( 0, IO::Seekable::SEEK_SET )
        or return _ioError( "rewinding", $self->externalFileName() );
      return AZ_OK;
  }
  
  # Return bytes read. Note that first parameter is a ref to a buffer.
  # my $data;
  # my ( $bytesRead, $status) = $self->readRawChunk( \$data, $chunkSize );
  sub _readRawChunk {
      my ( $self, $dataRef, $chunkSize ) = @_;
      return ( 0, AZ_OK ) unless $chunkSize;
      my $bytesRead = $self->fh()->read( $$dataRef, $chunkSize )
        or return ( 0, _ioError("reading data") );
      return ( $bytesRead, AZ_OK );
  }
  
  # If I already exist, extraction is a no-op.
  sub extractToFileNamed {
      my $self = shift;
      my $name = shift;    # local FS name
      if ( File::Spec->rel2abs($name) eq
          File::Spec->rel2abs( $self->externalFileName() ) and -r $name )
      {
          return AZ_OK;
      }
      else {
          return $self->SUPER::extractToFileNamed( $name, @_ );
      }
  }
  
  1;
ARCHIVE_ZIP_NEWFILEMEMBER

$fatpacked{"Archive/Zip/StringMember.pm"} = <<'ARCHIVE_ZIP_STRINGMEMBER';
  package Archive::Zip::StringMember;
  
  use strict;
  use vars qw( $VERSION @ISA );
  
  BEGIN {
      $VERSION = '1.30';
      @ISA     = qw( Archive::Zip::Member );
  }
  
  use Archive::Zip qw(
    :CONSTANTS
    :ERROR_CODES
  );
  
  # Create a new string member. Default is COMPRESSION_STORED.
  # Can take a ref to a string as well.
  sub _newFromString {
      my $class  = shift;
      my $string = shift;
      my $name   = shift;
      my $self   = $class->new(@_);
      $self->contents($string);
      $self->fileName($name) if defined($name);
  
      # Set the file date to now
      $self->setLastModFileDateTimeFromUnix( time() );
      $self->unixFileAttributes( $self->DEFAULT_FILE_PERMISSIONS );
      return $self;
  }
  
  sub _become {
      my $self     = shift;
      my $newClass = shift;
      return $self if ref($self) eq $newClass;
      delete( $self->{'contents'} );
      return $self->SUPER::_become($newClass);
  }
  
  # Get or set my contents. Note that we do not call the superclass
  # version of this, because it calls us.
  sub contents {
      my $self   = shift;
      my $string = shift;
      if ( defined($string) ) {
          $self->{'contents'} =
            pack( 'C0a*', ( ref($string) eq 'SCALAR' ) ? $$string : $string );
          $self->{'uncompressedSize'} = $self->{'compressedSize'} =
            length( $self->{'contents'} );
          $self->{'compressionMethod'} = COMPRESSION_STORED;
      }
      return $self->{'contents'};
  }
  
  # Return bytes read. Note that first parameter is a ref to a buffer.
  # my $data;
  # my ( $bytesRead, $status) = $self->readRawChunk( \$data, $chunkSize );
  sub _readRawChunk {
      my ( $self, $dataRef, $chunkSize ) = @_;
      $$dataRef = substr( $self->contents(), $self->_readOffset(), $chunkSize );
      return ( length($$dataRef), AZ_OK );
  }
  
  1;
ARCHIVE_ZIP_STRINGMEMBER

$fatpacked{"Archive/Zip/Tree.pm"} = <<'ARCHIVE_ZIP_TREE';
  package Archive::Zip::Tree;
  
  use strict;
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '1.30';
  }
  
  use Archive::Zip;
  
  warn(
  "Archive::Zip::Tree is deprecated; its methods have been moved into Archive::Zip."
  ) if $^W;
  
  1;
  
  __END__
  
  =head1 NAME
  
  Archive::Zip::Tree - (DEPRECATED) methods for adding/extracting trees using Archive::Zip
  
  =head1 SYNOPSIS
  
  =head1 DESCRIPTION
  
  This module is deprecated, because all its methods were moved into the main
  Archive::Zip module.
  
  It is included in the distribution merely to avoid breaking old code.
  
  See L<Archive::Zip>.
  
  =head1 AUTHOR
  
  Ned Konz, perl@bike-nomad.com
  
  =head1 COPYRIGHT
  
  Copyright (c) 2000-2002 Ned Konz. All rights reserved.  This program is free
  software; you can redistribute it and/or modify it under the same terms
  as Perl itself.
  
  =head1 SEE ALSO
  
  L<Archive::Zip>
  
  =cut
  
ARCHIVE_ZIP_TREE

$fatpacked{"Archive/Zip/ZipFileMember.pm"} = <<'ARCHIVE_ZIP_ZIPFILEMEMBER';
  package Archive::Zip::ZipFileMember;
  
  use strict;
  use vars qw( $VERSION @ISA );
  
  BEGIN {
      $VERSION = '1.30';
      @ISA     = qw ( Archive::Zip::FileMember );
  }
  
  use Archive::Zip qw(
    :CONSTANTS
    :ERROR_CODES
    :PKZIP_CONSTANTS
    :UTILITY_METHODS
  );
  
  # Create a new Archive::Zip::ZipFileMember
  # given a filename and optional open file handle
  #
  sub _newFromZipFile {
      my $class              = shift;
      my $fh                 = shift;
      my $externalFileName   = shift;
      my $possibleEocdOffset = shift;    # normally 0
  
      my $self = $class->new(
          'crc32'                     => 0,
          'diskNumberStart'           => 0,
          'localHeaderRelativeOffset' => 0,
          'dataOffset' => 0,    # localHeaderRelativeOffset + header length
          @_
      );
      $self->{'externalFileName'}   = $externalFileName;
      $self->{'fh'}                 = $fh;
      $self->{'possibleEocdOffset'} = $possibleEocdOffset;
      return $self;
  }
  
  sub isDirectory {
      my $self = shift;
      return (
          substr( $self->fileName, -1, 1 ) eq '/'
          and
          $self->uncompressedSize == 0
      );
  }
  
  # Seek to the beginning of the local header, just past the signature.
  # Verify that the local header signature is in fact correct.
  # Update the localHeaderRelativeOffset if necessary by adding the possibleEocdOffset.
  # Returns status.
  
  sub _seekToLocalHeader {
      my $self          = shift;
      my $where         = shift;    # optional
      my $previousWhere = shift;    # optional
  
      $where = $self->localHeaderRelativeOffset() unless defined($where);
  
      # avoid loop on certain corrupt files (from Julian Field)
      return _formatError("corrupt zip file")
        if defined($previousWhere) && $where == $previousWhere;
  
      my $status;
      my $signature;
  
      $status = $self->fh()->seek( $where, IO::Seekable::SEEK_SET );
      return _ioError("seeking to local header") unless $status;
  
      ( $status, $signature ) =
        _readSignature( $self->fh(), $self->externalFileName(),
          LOCAL_FILE_HEADER_SIGNATURE );
      return $status if $status == AZ_IO_ERROR;
  
      # retry with EOCD offset if any was given.
      if ( $status == AZ_FORMAT_ERROR && $self->{'possibleEocdOffset'} ) {
          $status = $self->_seekToLocalHeader(
              $self->localHeaderRelativeOffset() + $self->{'possibleEocdOffset'},
              $where
          );
          if ( $status == AZ_OK ) {
              $self->{'localHeaderRelativeOffset'} +=
                $self->{'possibleEocdOffset'};
              $self->{'possibleEocdOffset'} = 0;
          }
      }
  
      return $status;
  }
  
  # Because I'm going to delete the file handle, read the local file
  # header if the file handle is seekable. If it isn't, I assume that
  # I've already read the local header.
  # Return ( $status, $self )
  
  sub _become {
      my $self     = shift;
      my $newClass = shift;
      return $self if ref($self) eq $newClass;
  
      my $status = AZ_OK;
  
      if ( _isSeekable( $self->fh() ) ) {
          my $here = $self->fh()->tell();
          $status = $self->_seekToLocalHeader();
          $status = $self->_readLocalFileHeader() if $status == AZ_OK;
          $self->fh()->seek( $here, IO::Seekable::SEEK_SET );
          return $status unless $status == AZ_OK;
      }
  
      delete( $self->{'eocdCrc32'} );
      delete( $self->{'diskNumberStart'} );
      delete( $self->{'localHeaderRelativeOffset'} );
      delete( $self->{'dataOffset'} );
  
      return $self->SUPER::_become($newClass);
  }
  
  sub diskNumberStart {
      shift->{'diskNumberStart'};
  }
  
  sub localHeaderRelativeOffset {
      shift->{'localHeaderRelativeOffset'};
  }
  
  sub dataOffset {
      shift->{'dataOffset'};
  }
  
  # Skip local file header, updating only extra field stuff.
  # Assumes that fh is positioned before signature.
  sub _skipLocalFileHeader {
      my $self = shift;
      my $header;
      my $bytesRead = $self->fh()->read( $header, LOCAL_FILE_HEADER_LENGTH );
      if ( $bytesRead != LOCAL_FILE_HEADER_LENGTH ) {
          return _ioError("reading local file header");
      }
      my $fileNameLength;
      my $extraFieldLength;
      my $bitFlag;
      (
          undef,    # $self->{'versionNeededToExtract'},
          $bitFlag,
          undef,    # $self->{'compressionMethod'},
          undef,    # $self->{'lastModFileDateTime'},
          undef,    # $crc32,
          undef,    # $compressedSize,
          undef,    # $uncompressedSize,
          $fileNameLength,
          $extraFieldLength
      ) = unpack( LOCAL_FILE_HEADER_FORMAT, $header );
  
      if ($fileNameLength) {
          $self->fh()->seek( $fileNameLength, IO::Seekable::SEEK_CUR )
            or return _ioError("skipping local file name");
      }
  
      if ($extraFieldLength) {
          $bytesRead =
            $self->fh()->read( $self->{'localExtraField'}, $extraFieldLength );
          if ( $bytesRead != $extraFieldLength ) {
              return _ioError("reading local extra field");
          }
      }
  
      $self->{'dataOffset'} = $self->fh()->tell();
  
      if ( $bitFlag & GPBF_HAS_DATA_DESCRIPTOR_MASK ) {
  
          # Read the crc32, compressedSize, and uncompressedSize from the
          # extended data descriptor, which directly follows the compressed data.
          #
          # Skip over the compressed file data (assumes that EOCD compressedSize
          # was correct)
          $self->fh()->seek( $self->{'compressedSize'}, IO::Seekable::SEEK_CUR )
            or return _ioError("seeking to extended local header");
  
          # these values should be set correctly from before.
          my $oldCrc32            = $self->{'eocdCrc32'};
          my $oldCompressedSize   = $self->{'compressedSize'};
          my $oldUncompressedSize = $self->{'uncompressedSize'};
  
          my $status = $self->_readDataDescriptor();
          return $status unless $status == AZ_OK;
  
          return _formatError(
              "CRC or size mismatch while skipping data descriptor")
            if ( $oldCrc32 != $self->{'crc32'}
              || $oldUncompressedSize != $self->{'uncompressedSize'} );
      }
  
      return AZ_OK;
  }
  
  # Read from a local file header into myself. Returns AZ_OK if successful.
  # Assumes that fh is positioned after signature.
  # Note that crc32, compressedSize, and uncompressedSize will be 0 if
  # GPBF_HAS_DATA_DESCRIPTOR_MASK is set in the bitFlag.
  
  sub _readLocalFileHeader {
      my $self = shift;
      my $header;
      my $bytesRead = $self->fh()->read( $header, LOCAL_FILE_HEADER_LENGTH );
      if ( $bytesRead != LOCAL_FILE_HEADER_LENGTH ) {
          return _ioError("reading local file header");
      }
      my $fileNameLength;
      my $crc32;
      my $compressedSize;
      my $uncompressedSize;
      my $extraFieldLength;
      (
          $self->{'versionNeededToExtract'}, $self->{'bitFlag'},
          $self->{'compressionMethod'},      $self->{'lastModFileDateTime'},
          $crc32,                            $compressedSize,
          $uncompressedSize,                 $fileNameLength,
          $extraFieldLength
      ) = unpack( LOCAL_FILE_HEADER_FORMAT, $header );
  
      if ($fileNameLength) {
          my $fileName;
          $bytesRead = $self->fh()->read( $fileName, $fileNameLength );
          if ( $bytesRead != $fileNameLength ) {
              return _ioError("reading local file name");
          }
          $self->fileName($fileName);
      }
  
      if ($extraFieldLength) {
          $bytesRead =
            $self->fh()->read( $self->{'localExtraField'}, $extraFieldLength );
          if ( $bytesRead != $extraFieldLength ) {
              return _ioError("reading local extra field");
          }
      }
  
      $self->{'dataOffset'} = $self->fh()->tell();
  
      if ( $self->hasDataDescriptor() ) {
  
          # Read the crc32, compressedSize, and uncompressedSize from the
          # extended data descriptor.
          # Skip over the compressed file data (assumes that EOCD compressedSize
          # was correct)
          $self->fh()->seek( $self->{'compressedSize'}, IO::Seekable::SEEK_CUR )
            or return _ioError("seeking to extended local header");
  
          my $status = $self->_readDataDescriptor();
          return $status unless $status == AZ_OK;
      }
      else {
          return _formatError(
              "CRC or size mismatch after reading data descriptor")
            if ( $self->{'crc32'} != $crc32
              || $self->{'uncompressedSize'} != $uncompressedSize );
      }
  
      return AZ_OK;
  }
  
  # This will read the data descriptor, which is after the end of compressed file
  # data in members that that have GPBF_HAS_DATA_DESCRIPTOR_MASK set in their
  # bitFlag.
  # The only reliable way to find these is to rely on the EOCD compressedSize.
  # Assumes that file is positioned immediately after the compressed data.
  # Returns status; sets crc32, compressedSize, and uncompressedSize.
  sub _readDataDescriptor {
      my $self = shift;
      my $signatureData;
      my $header;
      my $crc32;
      my $compressedSize;
      my $uncompressedSize;
  
      my $bytesRead = $self->fh()->read( $signatureData, SIGNATURE_LENGTH );
      return _ioError("reading header signature")
        if $bytesRead != SIGNATURE_LENGTH;
      my $signature = unpack( SIGNATURE_FORMAT, $signatureData );
  
      # unfortunately, the signature appears to be optional.
      if ( $signature == DATA_DESCRIPTOR_SIGNATURE
          && ( $signature != $self->{'crc32'} ) )
      {
          $bytesRead = $self->fh()->read( $header, DATA_DESCRIPTOR_LENGTH );
          return _ioError("reading data descriptor")
            if $bytesRead != DATA_DESCRIPTOR_LENGTH;
  
          ( $crc32, $compressedSize, $uncompressedSize ) =
            unpack( DATA_DESCRIPTOR_FORMAT, $header );
      }
      else {
          $bytesRead =
            $self->fh()->read( $header, DATA_DESCRIPTOR_LENGTH_NO_SIG );
          return _ioError("reading data descriptor")
            if $bytesRead != DATA_DESCRIPTOR_LENGTH_NO_SIG;
  
          $crc32 = $signature;
          ( $compressedSize, $uncompressedSize ) =
            unpack( DATA_DESCRIPTOR_FORMAT_NO_SIG, $header );
      }
  
      $self->{'eocdCrc32'} = $self->{'crc32'}
        unless defined( $self->{'eocdCrc32'} );
      $self->{'crc32'}            = $crc32;
      $self->{'compressedSize'}   = $compressedSize;
      $self->{'uncompressedSize'} = $uncompressedSize;
  
      return AZ_OK;
  }
  
  # Read a Central Directory header. Return AZ_OK on success.
  # Assumes that fh is positioned right after the signature.
  
  sub _readCentralDirectoryFileHeader {
      my $self      = shift;
      my $fh        = $self->fh();
      my $header    = '';
      my $bytesRead = $fh->read( $header, CENTRAL_DIRECTORY_FILE_HEADER_LENGTH );
      if ( $bytesRead != CENTRAL_DIRECTORY_FILE_HEADER_LENGTH ) {
          return _ioError("reading central dir header");
      }
      my ( $fileNameLength, $extraFieldLength, $fileCommentLength );
      (
          $self->{'versionMadeBy'},
          $self->{'fileAttributeFormat'},
          $self->{'versionNeededToExtract'},
          $self->{'bitFlag'},
          $self->{'compressionMethod'},
          $self->{'lastModFileDateTime'},
          $self->{'crc32'},
          $self->{'compressedSize'},
          $self->{'uncompressedSize'},
          $fileNameLength,
          $extraFieldLength,
          $fileCommentLength,
          $self->{'diskNumberStart'},
          $self->{'internalFileAttributes'},
          $self->{'externalFileAttributes'},
          $self->{'localHeaderRelativeOffset'}
      ) = unpack( CENTRAL_DIRECTORY_FILE_HEADER_FORMAT, $header );
  
      $self->{'eocdCrc32'} = $self->{'crc32'};
  
      if ($fileNameLength) {
          $bytesRead = $fh->read( $self->{'fileName'}, $fileNameLength );
          if ( $bytesRead != $fileNameLength ) {
              _ioError("reading central dir filename");
          }
      }
      if ($extraFieldLength) {
          $bytesRead = $fh->read( $self->{'cdExtraField'}, $extraFieldLength );
          if ( $bytesRead != $extraFieldLength ) {
              return _ioError("reading central dir extra field");
          }
      }
      if ($fileCommentLength) {
          $bytesRead = $fh->read( $self->{'fileComment'}, $fileCommentLength );
          if ( $bytesRead != $fileCommentLength ) {
              return _ioError("reading central dir file comment");
          }
      }
  
      # NK 10/21/04: added to avoid problems with manipulated headers
      if (    $self->{'uncompressedSize'} != $self->{'compressedSize'}
          and $self->{'compressionMethod'} == COMPRESSION_STORED )
      {
          $self->{'uncompressedSize'} = $self->{'compressedSize'};
      }
  
      $self->desiredCompressionMethod( $self->compressionMethod() );
  
      return AZ_OK;
  }
  
  sub rewindData {
      my $self = shift;
  
      my $status = $self->SUPER::rewindData(@_);
      return $status unless $status == AZ_OK;
  
      return AZ_IO_ERROR unless $self->fh();
  
      $self->fh()->clearerr();
  
      # Seek to local file header.
      # The only reason that I'm doing this this way is that the extraField
      # length seems to be different between the CD header and the LF header.
      $status = $self->_seekToLocalHeader();
      return $status unless $status == AZ_OK;
  
      # skip local file header
      $status = $self->_skipLocalFileHeader();
      return $status unless $status == AZ_OK;
  
      # Seek to beginning of file data
      $self->fh()->seek( $self->dataOffset(), IO::Seekable::SEEK_SET )
        or return _ioError("seeking to beginning of file data");
  
      return AZ_OK;
  }
  
  # Return bytes read. Note that first parameter is a ref to a buffer.
  # my $data;
  # my ( $bytesRead, $status) = $self->readRawChunk( \$data, $chunkSize );
  sub _readRawChunk {
      my ( $self, $dataRef, $chunkSize ) = @_;
      return ( 0, AZ_OK ) unless $chunkSize;
      my $bytesRead = $self->fh()->read( $$dataRef, $chunkSize )
        or return ( 0, _ioError("reading data") );
      return ( $bytesRead, AZ_OK );
  }
  
  1;
ARCHIVE_ZIP_ZIPFILEMEMBER

$fatpacked{"Attribute/Abstract.pm"} = <<'ATTRIBUTE_ABSTRACT';
  package Attribute::Abstract;
  
  use warnings;
  use strict;
  use Attribute::Handlers;
  
  our $VERSION = sprintf "%d.%02d", q$Revision: 1.1 $ =~ /(\d+)/g;
  
  sub UNIVERSAL::Abstract :ATTR(CODE) {
  	my ($pkg, $symbol) = @_;
  	no strict 'refs';
  	my $sub = $pkg . '::' . *{$symbol}{NAME};
  	*{$sub} = sub {
  		my ($file, $line) = (caller)[1,2];
  		die "call to abstract method $sub at $file line $line.\n";
  	};
  }
  
  "Rosebud"; # for MARCEL's sake, not 1 -- dankogai
  
  __END__
  
  =head1 NAME
  
  Attribute::Abstract - An Abstract attribute
  
  =head1 SYNOPSIS
  
    use Attribute::Abstract;
  
    package MyObj;
    sub new { ... }
    sub somesub: Abstract;
  
    package MyObj::Better;
    use base 'MyObj';
    sub somesub { return "I'm implemented!" }
  
  =head1 DESCRIPTION
  
  This attribute declares a subroutine to be abstract using this
  attribute causes a call to it to die with a suitable
  exception. Subclasses are expected to implement the abstract method.
  
  Using the attribute makes it visually distinctive that a method is
  abstract, as opposed to declaring it without any attribute or method
  body, or providing a method body that might make it look as though
  it was implemented after all.
  
  =head1 BUGS
  
  None known so far. If you find any bugs or oddities, please do inform the
  author.
  
  =head1 AUTHOR
  
  Marcel Grunauer, <marcel@codewerk.com>
  
  Dan Kogai, <dankogai@dan.co.jp>
  
  =head1 COPYRIGHT
  
  Copyright 2001 Marcel Grunauer.  All rights reserved.
  
  Copyright 2006 Dan Kogai.  All rights reserved.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  perl(1), L<Attribute::Handlers>
  
  =cut
ATTRIBUTE_ABSTRACT

$fatpacked{"Attribute/Alias.pm"} = <<'ATTRIBUTE_ALIAS';
  package Attribute::Alias;
  
  use warnings;
  use strict;
  use Attribute::Handlers;
  
  our $VERSION = sprintf "%d.%02d", q$Revision: 1.1 $ =~ /(\d+)/g;
  
  sub UNIVERSAL::Alias : ATTR {
  	my ($pkg, $symbol, $data) = @_[0,1,4];
  	no strict 'refs';
  	*{"$pkg\::$_"} = $symbol for ref $data eq 'ARRAY' ? @$data : $data;
  }
  
  "Rosebud"; # for MARCEL's sake, not 1 -- dankogai
  
  __END__
  
  =head1 NAME
  
  Attribute::Alias - An Alias attribute
  
  =head1 SYNOPSIS
  
    use Attribute::Alias;
  
    sub color : Alias(colour) { return 'red' }
  
  =head1 DESCRIPTION
  
  If you need a variable or subroutine to be known by another name,
  use this attribute. Internally, the attribute's handler assigns
  typeglobs to each other. As such, the C<Alias> attribute provides
  a layer of abstraction. If the underlying mechanism changes in a
  future version of Perl (say, one that might not have the concept
  of typeglobs anymore :), a new version of this module will take
  care of that, but your C<Alias> declarations are going to stay the
  same.
  
  Note that assigning typeglobs means that you can't specify a synonym
  for one element of the glob and use the same synonym for a different
  target name in a different slot. I.e.,
  
    sub color :Alias(colour) { ... }
    my $farbe :Alias(colour);
  
  doesn't make sense, since the sub declaration aliases the whole
  C<colour> glob to C<color>, but then the scalar declaration aliases
  the whole C<colour> glob to C<farbe>, so the first alias is lost.
  
  =head1 BUGS
  
  None known so far. If you find any bugs or oddities, please do inform the
  author.
  
  =head1 AUTHOR
  
  Marcel Grunauer, <marcel@codewerk.com>
  
  Dan Kogai, <dankogai@dan.co.jp>
  
  =head1 COPYRIGHT
  
  Copyright 2001 Marcel Grunauer.  All rights reserved.
  
  Copyright 2006 Dan Kogai.  All rights reserved.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  perl(1), L<Attribute::Handlers>
  
  =cut
ATTRIBUTE_ALIAS

$fatpacked{"Attribute/Memoize.pm"} = <<'ATTRIBUTE_MEMOIZE';
  package Attribute::Memoize;
  
  use warnings;
  use strict;
  use Attribute::Handlers;
  
  our $VERSION = sprintf "%d.%02d", q$Revision: 1.1 $ =~ /(\d+)/g;
  
  sub UNIVERSAL::Memoize :ATTR(CODE) {
  	my ($pkg, $symbol, $options) = @_[0,1,4];
  	$options = [ $options || () ] unless ref $options eq 'ARRAY';
  	require Memoize;
  	Memoize::memoize($pkg . '::' . *{$symbol}{NAME}, @$options);
  }
  
  "Rosebud"; # for MARCEL's sake, not 1 -- dankogai
  
  __END__
  
  =head1 NAME
  
  Attribute::Memoize - A Memoize attribute
  
  =head1 SYNOPSIS
  
    use Attribute::Memoize;
  
    sub fib :Memoize {
            my $n = shift;
            return $n if $n < 2;
            fib($n-1) + fib($n-2);
    }
    $|++;
    print fib($_),"\n" for 1..50;
  
  =head1 DESCRIPTION
  
  This attribute makes it slightly easier (and modern) to memoize a
  function by providing an attribute, C<:Memoize> that makes it
  unnecessary for you to explicitly call C<Memoize::memoize()>.
  Options can be passed via the attribute per usual (see the
  C<Attribute::Handlers> manpage for details, and the C<Memoize>
  manpage for information on memoizing options):
  
    sub f :Memoize(NORMALIZER => 'main::normalize_f') {
    	...
    }
  
  However, since the call to C<memoize()> is now done in a different
  package, it is necessary to include the package name in any function
  names passed as options to the attribute, as shown above.
  
  =head1 BUGS
  
  None known so far. If you find any bugs or oddities, please do inform the
  author.
  
  =head1 AUTHOR
  
  Marcel Grunauer, <marcel@codewerk.com>
  
  Dan Kogai, <dankogai@dan.co.jp>
  
  =head1 COPYRIGHT
  
  Copyright 2001 Marcel Grunauer.  All rights reserved.
  
  Copyright 2006 Dan Kogai.  All rights reserved.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  perl(1), L<Attribute::Handlers>, L<Memoize>
  
  =cut
ATTRIBUTE_MEMOIZE

$fatpacked{"Attribute/Method.pm"} = <<'ATTRIBUTE_METHOD';
  package Attribute::Method;
  
  use warnings;
  use strict;
  use Attribute::Handlers;
  use B::Deparse;
  
  our $VERSION = sprintf "%d.%02d", q$Revision: 1.3 $ =~ /(\d+)/g;
  
  my $dp        = B::Deparse->new('-l');
  my %sigil2ref = (
      '$' => \undef,
      '@' => [],
      '%' => {},
  );
  
  sub import {
      my ( $class, @vars ) = @_;
      my $pkg = caller();
      push @vars, '$self';
      for my $var (@vars) {
          my $sigil = substr( $var, 0, 1, '' );
          no strict 'refs';
          *{ $pkg . '::' . $var } = $sigil2ref{$sigil};
      }
  }
  
  sub UNIVERSAL::Method : ATTR(RAWDATA) {
      my ( $pkg, $sym, $ref, undef, $args ) = @_;
      my $src = $dp->coderef2text($ref);
      if ($args) {
          $src =~ s/\{/{\nmy \$self = shift; my ($args) = \@_;\n/;
      }
      else {
          $src =~ s/\{/{\nmy \$self = shift;\n/;
      }
      no warnings 'redefine';
      my $sub_name = *{$sym}{NAME};
      eval qq{ package $pkg; sub $sub_name $src };
  }
  
  "Rosebud"; # for MARCEL's sake, not 1 -- dankogai
  
  __END__
  
  =head1 NAME
  
  Attribute::Method - No more 'my $self = shift;'
  
  =head1 SYNOPSIS
  
    package Lazy;
    use strict;
    use warnings;
    use Attribute::Method qw( $val );
  	                # pass all parameter names here
                          # to make strict.pm happy
    sub new : Method { 
        bless { @_ }, $self 
    }
    sub set_foo : Method( $val ){
        $self->{foo} = $val;
    }
    sub get_foo : Method {
        $self->{foo};
    }
    #....
  
  =head1 DESCRIPTION
  
  This Attribute makes your subroutine a method -- $self is
  automagically set and the parameter list is supported.
  
  This trick is actually introduced in "Perl Hacks", hack #47.
  But the code sample therein is a little  buggy so have a look at this
  module instead.
  
  =head1 BUGS
  
  None known so far. If you find any bugs or oddities, please do inform the
  author.
  
  =head1 CAVEAT
  
  The following does not work.
  
  =over 2
  
  =item foo.pl
  
    use Attribute::Memoize;
    use strict;
    use warnings;
    use lib '.';
    print "loading bar ...\n";
    require bar; # should have been 'use bar;'
    print "bar is loaded\n";
    print bar::func(),"\n";
    print bar::func(),"\n";
    exit 0;
  
  =item bar.pm
  
    package bar;
    use strict;
    use warnings;
    use Attribute::Memoize;
  
    sub func : Memoize {
      print "func runs\n";
      return 123;
    }
    1;
  
  =back
  
  To use modules that use L<Attribute::Memoize>, don't C<require>;
  C<use> it.  That holds true for most Attribute::* modules.
  
  =head1 AUTHOR
  
  Dan Kogai, E<lt>dankogai@dan.co.jpE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2008 Dan Kogai.  All rights reserved.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  perl(1), L<Attribute::Handlers>
  
  Perl Hacks, isbn:0596526741
  
  =cut
ATTRIBUTE_METHOD

$fatpacked{"Attribute/SigHandler.pm"} = <<'ATTRIBUTE_SIGHANDLER';
  package Attribute::SigHandler;
  
  use warnings;
  use strict;
  use Attribute::Handlers;
  
  our $VERSION = sprintf "%d.%02d", q$Revision: 1.1 $ =~ /(\d+)/g;
  
  sub UNIVERSAL::SigHandler : ATTR(CODE) {
  	my ($symbol, $data) = @_[1,4];
  	$SIG{$_} = *{$symbol}{NAME} for ref $data eq 'ARRAY' ? @$data : $data;
  }
  
  "Rosebud"; # for MARCEL's sake, not 1 -- dankogai
  
  __END__
  
  =head1 NAME
  
  Attribute::SigHandler - A Signal Handler Attribute
  
  =head1 SYNOPSIS
  
    use Attribute::SigHandler;
  
    sub myalrm : SigHandler(ALRM, VTALRM) { ...  }
    sub mywarn : SigHandler(__WARN__) { ... }
  
  =head1 DESCRIPTION
  
  When used on a subroutine, this attribute declares that subroutine
  to be a signal handler for the signal(s) given as options for this
  attribute. It thereby frees you from the implementation details of
  defining sig handlers and keeps the handler definitions where they
  belong, namely with the handler subroutine.
  
  =head1 BUGS
  
  None known so far. If you find any bugs or oddities, please do inform the
  author.
  
  =head1 AUTHOR
  
  Marcel Grunauer, <marcel@codewerk.com>
  
  Dan Kogai, <dankogai@dan.co.jp>
  
  =head1 COPYRIGHT
  
  Copyright 2001 Marcel Grunauer.  All rights reserved.
  
  Copyright 2006 Dan Kogai.  All rights reserved.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  perl(1), L<Attribute::Handlers>
  
  =cut
ATTRIBUTE_SIGHANDLER

$fatpacked{"Attribute/Util.pm"} = <<'ATTRIBUTE_UTIL';
  package Attribute::Util;
  
  use warnings;
  use strict;
  use Attribute::Handlers;
  use Carp ();
  
  our $VERSION = sprintf "%d.%02d", q$Revision: 1.6 $ =~ /(\d+)/g;
  our @DEFAULT_ATTRIBUTES = qw(Abstract Alias Memoize Method SigHandler);
  
  sub import{
      my $pkg = shift;
      my @attrs = @_ ? @_ : @DEFAULT_ATTRIBUTES;
      for my $attr (@attrs){
  	eval qq{ require Attribute::$attr; };
  	$@ and Carp::croak $@;
  	# import is not neccessary for Attribute modules.
      }
  }
  
  "Rosebud"; # for MARCEL's sake, not 1 -- dankogai
  
  __END__
  
  =head1 NAME
  
  Attribute::Util - Assorted general utility attributes
  
  =head1 SYNOPSIS
  
    # makes all attributes available
    use  Attribute::Util;
  
    # or you can load individual attributes 
    use Attribute::Util qw(Memoize SigHandler);
  
  =head1 DESCRIPTION
  
  When used without argument, this module provides four universally
  accessible attributes of general interest as follows:
  
  =over 4
  
  =item Abstract
  
  See L<Attribute::Abstract>.
  
  =item Alias
  
  See L<Attribute::Alias>.
  
  =item Memoize
  
  See L<Attribute::Memoize>.
  
  =item Method
  
  See L<Attribute::Method>.
  
  =item SigHandler
  
  See L<Attribute::SigHandler>.
  
  =back
  
  When used with arguments, this module acts as an attributes loader.
  
    use Attribute::Util qw/Memoize SigHandler/;
  
  Is exactly the same as
  
    use Attribute::Memoize; use Attribute::SigHandler;
  
  Theoretically, you can load any other attribute handlers so long as it
  is named I<Attribute::AnyThing>.
  
  =head1 BUGS
  
  None known so far. If you find any bugs or oddities, please do inform
  the author.
  
  =head1 AUTHOR
  
  Marcel Grunauer, <marcel@codewerk.com>
  
  Dan Kogai, <dankogai@dan.co.jp>
  
  =head1 COPYRIGHT
  
  Copyright 2001 Marcel Grunauer. All rights reserved.
  
  Copyright 2006 Dan Kogai. All rights reserved.
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  perl(1), L<Attribute::Handlers>
  
  =cut
ATTRIBUTE_UTIL

$fatpacked{"CPAN/DistnameInfo.pm"} = <<'CPAN_DISTNAMEINFO';
  
  package CPAN::DistnameInfo;
  
  $VERSION = "0.11";
  use strict;
  
  sub distname_info {
    my $file = shift or return;
  
    my ($dist, $version) = $file =~ /^
      ((?:[-+.]*(?:[A-Za-z0-9]+|(?<=\D)_|_(?=\D))*
       (?:
  	[A-Za-z](?=[^A-Za-z]|$)
  	|
  	\d(?=-)
       )(?<![._-][vV])
      )+)(.*)
    $/xs or return ($file,undef,undef);
  
    if ($dist =~ /-undef\z/ and ! length $version) {
      $dist =~ s/-undef\z//;
    }
  
    # Remove potential -withoutworldwriteables suffix
    $version =~ s/-withoutworldwriteables$//;
  
    if ($version =~ /^(-[Vv].*)-(\d.*)/) {
     
      # Catch names like Unicode-Collate-Standard-V3_1_1-0.1
      # where the V3_1_1 is part of the distname
      $dist .= $1;
      $version = $2;
    }
  
    # Normalize the Dist.pm-1.23 convention which CGI.pm and
    # a few others use.
    $dist =~ s{\.pm$}{};
  
    $version = $1
      if !length $version and $dist =~ s/-(\d+\w)$//;
  
    $version = $1 . $version
      if $version =~ /^\d+$/ and $dist =~ s/-(\w+)$//;
  
    if ($version =~ /\d\.\d/) {
      $version =~ s/^[-_.]+//;
    }
    else {
      $version =~ s/^[-_]+//;
    }
  
    my $dev;
    if (length $version) {
      if ($file =~ /^perl-?\d+\.(\d+)(?:\D(\d+))?(-(?:TRIAL|RC)\d+)?$/) {
        $dev = 1 if (($1 > 6 and $1 & 1) or ($2 and $2 >= 50)) or $3;
      }
      elsif ($version =~ /\d\D\d+_\d/ or $version =~ /-TRIAL/) {
        $dev = 1;
      }
    }
    else {
      $version = undef;
    }
  
    ($dist, $version, $dev);
  }
  
  sub new {
    my $class = shift;
    my $distfile = shift;
  
    $distfile =~ s,//+,/,g;
  
    my %info = ( pathname => $distfile );
  
    ($info{filename} = $distfile) =~ s,^(((.*?/)?authors/)?id/)?([A-Z])/(\4[A-Z])/(\5[-A-Z0-9]*)/,,
      and $info{cpanid} = $6;
  
    if ($distfile =~ m,([^/]+)\.(tar\.(?:g?z|bz2)|zip|tgz)$,i) { # support more ?
      $info{distvname} = $1;
      $info{extension} = $2;
    }
  
    @info{qw(dist version beta)} = distname_info($info{distvname});
    $info{maturity} = delete $info{beta} ? 'developer' : 'released';
  
    return bless \%info, $class;
  }
  
  sub dist      { shift->{dist} }
  sub version   { shift->{version} }
  sub maturity  { shift->{maturity} }
  sub filename  { shift->{filename} }
  sub cpanid    { shift->{cpanid} }
  sub distvname { shift->{distvname} }
  sub extension { shift->{extension} }
  sub pathname  { shift->{pathname} }
  
  sub properties { %{ $_[0] } }
  
  1;
  
  __END__
  
  =head1 NAME
  
  CPAN::DistnameInfo - Extract distribution name and version from a distribution filename
  
  =head1 SYNOPSIS
  
    my $pathname = "authors/id/G/GB/GBARR/CPAN-DistnameInfo-0.02.tar.gz";
  
    my $d = CPAN::DistnameInfo->new($pathname);
  
    my $dist      = $d->dist;      # "CPAN-DistnameInfo"
    my $version   = $d->version;   # "0.02"
    my $maturity  = $d->maturity;  # "released"
    my $filename  = $d->filename;  # "CPAN-DistnameInfo-0.02.tar.gz"
    my $cpanid    = $d->cpanid;    # "GBARR"
    my $distvname = $d->distvname; # "CPAN-DistnameInfo-0.02"
    my $extension = $d->extension; # "tar.gz"
    my $pathname  = $d->pathname;  # "authors/id/G/GB/GBARR/..."
  
    my %prop = $d->properties;
  
  =head1 DESCRIPTION
  
  Many online services that are centered around CPAN attempt to
  associate multiple uploads by extracting a distribution name from
  the filename of the upload. For most distributions this is easy as
  they have used ExtUtils::MakeMaker or Module::Build to create the
  distribution, which results in a uniform name. But sadly not all
  uploads are created in this way.
  
  C<CPAN::DistnameInfo> uses heuristics that have been learnt by
  L<http://search.cpan.org/> to extract the distribution name and
  version from filenames and also report if the version is to be
  treated as a developer release
  
  The constructor takes a single pathname, returning an object with the following methods
  
  =over
  
  =item cpanid
  
  If the path given looked like a CPAN authors directory path, then this will be the
  the CPAN id of the author.
  
  =item dist
  
  The name of the distribution
  
  =item distvname
  
  The file name with any suffix and leading directory names removed
  
  =item filename
  
  If the path given looked like a CPAN authors directory path, then this will be the
  path to the file relative to the detected CPAN author directory. Otherwise it is the path
  that was passed in.
  
  =item maturity
  
  The maturity of the distribution. This will be either C<released> or C<developer>
  
  =item extension
  
  The extension of the distribution, often used to denote the archive type (e.g. 'tar.gz')
  
  =item pathname
  
  The pathname that was passed to the constructor when creating the object.
  
  =item properties
  
  This will return a list of key-value pairs, suitable for assigning to a hash,
  for the known properties.
  
  =item version
  
  The extracted version
  
  =back
  
  =head1 AUTHOR
  
  Graham Barr <gbarr@pobox.com>
  
  =head1 COPYRIGHT 
  
  Copyright (c) 2003 Graham Barr. All rights reserved. This program is
  free software; you can redistribute it and/or modify it under the same
  terms as Perl itself.
  
  =cut
  
CPAN_DISTNAMEINFO

$fatpacked{"CPAN/PackageDetails.pm"} = <<'CPAN_PACKAGEDETAILS';
  package CPAN::PackageDetails;
  use strict;
  use warnings;
  
  use subs qw();
  use vars qw($VERSION);
  
  use Carp qw(carp croak cluck confess);
  use Cwd;
  use File::Basename;
  use File::Spec::Functions;
  
  BEGIN {
  	$VERSION = '0.25';
  	}
  
  =head1 NAME
  
  CPAN::PackageDetails - Create or read 02packages.details.txt.gz
  
  =head1 SYNOPSIS
  
  	use CPAN::PackageDetails;
  
  	# read an existing file #####################
  	my $package_details = CPAN::PackageDetails->read( $filename );
  	
  	my $count      = $package_details->count;
  	
  	my $records    = $package_details->entries;
  	
  	foreach my $record ( @$records )
  		{
  		# See CPAN::PackageDetails::Entry too
  		print join "\t", map { $record->$_() } ('package name', 'version', 'path')
  		print join "\t", map { $record->$_() } $package_details->columns_as_list;
  		}
  		
  	# not yet implemented, but would be really, really cool eh?
  	my $records    = $package_details->entries(
  		logic   => 'OR',  # but that could be AND, which is the default
  		package => qr/^Test::/, # or a string
  		author  => 'OVID',      # case insenstive
  		path    =>  qr/foo/,
  		);
  	
  	# create a new file #####################
  	my $package_details = CPAN::PackageDetails->new( 
  		file         => "02packages.details.txt",
  		url          => "http://example.com/MyCPAN/modules/02packages.details.txt",
  		description  => "Package names for my private CPAN",
  		columns      => "package name, version, path",
  		intended_for => "My private CPAN",
  		written_by   => "$0 using CPAN::PackageDetails $CPAN::PackageDetails::VERSION",
  		last_updated => CPAN::PackageDetails->format_date,
  		allow_packages_only_once => 1,
  		);
  
  	$package_details->add_entry(
  		package_name => $package,
  		version      => $package->VERSION;
  		path         => $path,
  		);
  		
  	print "About to write ", $package_details->count, " entries\n";
  	
  	$package_details->write_file( $file );
  	
  	 # OR ...
  	 
  	$package_details->write_fh( \*STDOUT )
  	
  =head1 DESCRIPTION
  
  CPAN uses an index file, F<02packages.details.txt.gz>, to map package names to
  distribution files. Using this module, you can get a data structure of that
  file, or create your own.
  
  There are two parts to the F<02packages.details.txt.g>z: a header and the index.
  This module uses a top-level C<CPAN::PackageDetails> object to control
  everything and comprise an C<CPAN::PackageDetails::Header> and
  C<CPAN::PackageDetails::Entries> object. The C<CPAN::PackageDetails::Entries>
  object is a collection of C<CPAN::PackageDetails::Entry> objects.
  
  For the most common uses, you don't need to worry about the insides
  of what class is doing what. You'll call most of the methods on
  the top-level  C<CPAN::PackageDetails> object and it will make sure
  that it gets to the right place.
  
  =head2 Methods
  
  These methods are in the top-level object, and there are more methods
  for this class in the sections that cover the Header, Entries, and
  Entry objects.
  
  =over 4
  
  =item new
  
  Create a new F<02packages.details.txt.gz> file. The C<default_headers>
  method shows you which values you can pass to C<new>. For instance:
  
  	my $package_details = CPAN::PackageDetails->new(
  		url     => $url,
  		columns => 'author, package name, version, path',
  		)
  
  If you specify the C<allow_packages_only_once> option with a true value
  and you try to add that package twice, the object will die. See C<add_entry>.
  
  =cut
  
  sub new
  	{
  	my( $class, %args ) = @_;
  
  	my $self = bless {}, $class;
  	
  	$self->init( %args );
  	
  	$self;
  	}
  	
  =item init
  
  Sets up the object. C<new> calls this automatically for you.
  
  =item default_headers
  
  Returns the hash of header fields and their default values:
  
  	file            "02packages.details.txt"
  	url             "http://example.com/MyCPAN/modules/02packages.details.txt"
  	description     "Package names for my private CPAN"
  	columns         "package name, version, path"
  	intended_for    "My private CPAN"
  	written_by      "$0 using CPAN::PackageDetails $CPAN::PackageDetails::VERSION"
  	last_updated    format_date()
  
  In the header, these fields show up with the underscores turned into hyphens,
  and the letters at the beginning or after a hyphen are uppercase.
  
  =cut
  
  BEGIN {
  # These methods live in the top level and delegate interfaces
  # so I need to intercept them at the top-level and redirect
  # them to the right delegate
  my %Dispatch = (
  		header  => { map { $_, 1 } qw(default_headers get_header set_header header_exists columns_as_list) },
  		entries => { map { $_, 1 } qw(add_entry count as_unique_sorted_list already_added allow_packages_only_once) },
  	#	entry   => { map { $_, 1 } qw() },
  		);
  		
  my %Dispatchable = map { #inverts %Dispatch
  	my $class = $_; 
  	map { $_, $class } keys %{$Dispatch{$class}} 
  	} keys %Dispatch;
  
  sub can
  	{
  	my( $self, @methods ) = @_;
  
  	my $class = ref $self || $self; # class or instance
  
  	foreach my $method ( @methods )
  		{
  		next if 
  			defined &{"${class}::$method"} || 
  			exists $Dispatchable{$method}  ||
  			$self->header_exists( $method );
  		return 0;
  		}
  
  	return 1;
  	}
  
  sub AUTOLOAD
  	{
  	my $self = shift;
  	
  	
  	our $AUTOLOAD;
  	carp "There are no AUTOLOADable class methods: $AUTOLOAD" unless ref $self;
  	( my $method = $AUTOLOAD ) =~ s/.*:://;
  	
  	if( exists $Dispatchable{$method} )
  		{
  		my $delegate = $Dispatchable{$method};	
  		return $self->$delegate()->$method(@_)
  		}
  	elsif( $self->header_exists( $method ) )
  		{
  		return $self->header->get_header( $method );
  		}
  	else
  		{
  		carp "No such method as $method!";
  		return;
  		}
  	}
  }
  
  BEGIN {
  my %defaults = (
  	file            => "02packages.details.txt",
  	url             => "http://example.com/MyCPAN/modules/02packages.details.txt",
  	description     => "Package names for my private CPAN",
  	columns         => "package name, version, path",
  	intended_for    => "My private CPAN",
  	written_by      => "$0 using CPAN::PackageDetails $CPAN::PackageDetails::VERSION",
  
  	header_class    => 'CPAN::PackageDetails::Header',
  	entries_class   => 'CPAN::PackageDetails::Entries',
  	entry_class     => 'CPAN::PackageDetails::Entry',
  
  	allow_packages_only_once => 1,
  	);
  	
  sub init
  	{
  	my( $self, %args ) = @_;
  
  	my %config = ( %defaults, %args );
  
  	# we'll delegate everything, but also try to hide the mess from the user
  	foreach my $key ( map { "${_}_class" } qw(header entries entry) )
  		{
  		$self->{$key}  = $config{$key};
  		delete $config{$key};
  		}
  	
  	foreach my $class ( map { $self->$_ } qw(header_class entries_class entry_class) )
  		{
  		eval "require $class";
  		}
  	
  	$self->{entries} = $self->entries_class->new(
  		entry_class              => $self->entry_class,
  		columns                  => [ split /,\s+/, $config{columns} ],
  		allow_packages_only_once => $config{allow_packages_only_once},
  		);
  	
  	$self->{header}  = $self->header_class->new(
  		_entries => $self->entries,
  		);
  	
  	
  	foreach my $key ( keys %config )
  		{
  		$self->header->set_header( $key, $config{$key} );
  		}
  
  	$self->header->set_header( 
  		'last_updated', 
  		$self->header->format_date 
  		);
  		
  	}
  
  }
  
  =item read( FILE )
  
  Read an existing 02packages.details.txt.gz file.
  
  While parsing, it modifies the field names to map them to Perly
  identifiers. The field is lowercased, and then hyphens become
  underscores. For instance:
  
  	Written-By ---> written_by
  	
  =cut
  
  sub read
  	{
  	my( $class, $file ) = @_;
  
  	unless( defined $file )
  		{
  		carp "Missing argument!";
  		return;
  		}
  		
  	require IO::Uncompress::Gunzip;
  
  	my $fh = IO::Uncompress::Gunzip->new( $file ) or do {	
  		carp "Could not open $file: $IO::Compress::Gunzip::GunzipError";
  		return;
  		};
  	
  	my $self = $class->_parse( $fh );
  	
  	$self->{source_file} = $file;
  	
  	$self;	
  	}
  	
  =item source_file
  
  Returns the original file path for objects created through the
  C<read> method.
  
  =cut
  
  sub source_file { $_[0]->{source_file} }
  
  sub _parse
  	{
  	my( $class, $fh ) = @_;
  
  	my $package_details = $class->new;
  		
  	while( <$fh> ) # header processing
  		{
  		chomp;
  		my( $field, $value ) = split /\s*:\s*/, $_, 2;
  		
  		$field = lc $field;
  		$field =~ tr/-/_/;
  		
  		carp "Unknown field value [$field] at line $.! Skipping..."
  			unless 1; # XXX should there be field name restrictions?
  		$package_details->set_header( $field, $value );
  		last if /^\s*$/;
  		}
  	
  	my @columns = $package_details->columns_as_list;
  	while( <$fh> ) # entry processing
  		{
  		chomp;
  		my @values = split; # this could be in any order based on columns field.
  		$package_details->add_entry( 
  			map { $columns[$_], $values[$_] } 0 .. $#columns
  			)
  		}
  	
  	$package_details;	
  	}
  
  =item write_file( OUTPUT_FILE )
  
  Formats the object as a string and writes it to a temporary file and
  gzips the output. When everything is complete, it renames the temporary
  file to its final name.
  
  C<write_file> carps and returns nothing if you pass it no arguments, if 
  it cannot open OUTPUT_FILE for writing, or if it cannot rename the file.
  
  =cut
  
  sub write_file
  	{
  	my( $self, $output_file ) = @_;
  
  	unless( defined $output_file )
  		{
  		carp "Missing argument!";
  		return;
  		}
  	
  	require IO::Compress::Gzip;
  	
  	my $fh = IO::Compress::Gzip->new( "$output_file.$$" ) or do {
  		carp "Could not open $output_file.$$ for writing: $IO::Compress::Gzip::GzipError";
  		return;
  		};
  	
  	$self->write_fh( $fh );
  	$fh->close;
  	
  	unless( rename "$output_file.$$", $output_file )
  		{
  		carp "Could not rename temporary file to $output_file!\n";
  		return;
  		}
  		
  	return 1;
  	}
  
  =item write_fh( FILEHANDLE )
  
  Formats the object as a string and writes it to FILEHANDLE
  
  =cut
  
  sub write_fh
  	{
  	my( $self, $fh ) = @_;
  	
  	print $fh $self->header->as_string, $self->entries->as_string;
  	}
  	
  =item check_file( FILE, CPAN_PATH )
  
  This method takes an existing F<02packages.details.txt.gz> named in FILE and
  the the CPAN root at CPAN_PATH (to append to the relative paths in the
  index), then checks the file for several things:
  
  	1. That there are entries in the file
  	2. The number of entries matches those declared in the Line-Count header
  	3. All paths listed in the file exist under CPAN_PATH
  	4. All distributions under CPAN_PATH have an entry (not counting older versions)
  
  If any of these checks fail, C<check_file> croaks with a hash reference
  with these keys:
  
  	# present in every error object
  	filename                the FILE you passed in
  	cpan_path               the CPAN_PATH you passed in
  	cwd                     the current working directory
  	error_count             
  
  	# if FILE is missing
  	missing_file          exists and true if FILE doesn't exist
  
  	# if the entry count in the file is wrong
  	# that is, the actual line count and header disagree
  	entry_count_mismatch    true 
  	line_count              the line count declared in the header   
  	entry_count             the actual count
  
  	# if some distros in CPAN_HOME are missing in FILE		
  	missing_in_file         anonymous array of missing paths
  	
  	# if some entries in FILE are missing the file in CPAN_HOME
  	missing_in_repo         anonymous array of missing paths
  
  =cut
  
  sub ENTRY_COUNT_MISMATCH () { 1 }
  sub MISSING_IN_REPO      () { 2 }
  sub MISSING_IN_FILE      () { 3 }
  
  sub check_file
  	{
  	my( $either, $file, $cpan_path ) = @_;
  
  	# works with a class or an instance. We have to create a new
  	# instance, so we need the class. However, I'm concerned about
  	# subclasses, so if the higher level application just has the
  	# object, and maybe from a class I don't know about, they should
  	# be able to call this method and have it end up here if they
  	# didn't override it. That is, don't encourage them to hard code 
  	# a class name
  	my $class = ref $either || $either;
  	
  	# file exists
  	my $error = { 
  		error_count => 0, 
  		cpan_path   => $cpan_path, 
  		filename    => $file,
  		cwd         => cwd(),
  		};
  	unless( -e $file )
  		{
  		$error->{missing_file}         = 1;
  		$error->{error_count}         +=  1;
  		}
  		
  	# file is gzipped
  
  	# check header # # # # # # # # # # # # # # # # # # #
  	my $packages = $class->read( $file );
  	
  	# count of entries in non-zero # # # # # # # # # # # # # # # # # # #
  
  	my $header_count = $packages->get_header( 'line_count' );
  	my $entries_count = $packages->count;
  	
  	unless( $header_count )
  		{
  		$error->{entry_count_mismatch} = 1;
  		$error->{line_count}           = $header_count;
  		$error->{entry_count}          = $entries_count;
  		$error->{error_count}         +=  1;
  		}
  
  	unless( $header_count == $entries_count )
  		{
  		$error->{entry_count_mismatch} = 1;
  		$error->{line_count}           = $header_count;
  		$error->{entry_count}          = $entries_count;
  		$error->{error_count}         +=  1;
  		}
  
  	if( $cpan_path )
  		{
  		my $missing_in_file = $packages->check_for_missing_dists_in_file( $cpan_path );
  		my $missing_in_repo = $packages->check_for_missing_dists_in_repo( $cpan_path );
  		
  		$error->{missing_in_file}  =  $missing_in_file if @$missing_in_file;
  		$error->{missing_in_repo}  =  $missing_in_repo if @$missing_in_repo;
  		$error->{error_count}     += @$missing_in_file  + @$missing_in_repo;
  		}
  
  	croak $error if $error->{error_count};
  	
  	return 1;
  	}
  
  
  
  =item check_for_missing_dists_in_repo( CPAN_PATH )
  
  Given an object and a CPAN_PATH, return an anonymous array of the 
  distributions in the object that are not in CPAN_PATH. That is,
  complain when the object has extra distributions.
  
  C<check_file> calls this for you and adds the result to its
  error output.
  
  =cut
  
  sub check_for_missing_dists_in_repo
  	{
  	my( $packages, $cpan_path ) = @_;
  
  	my @missing;
  	my( $entries ) = $packages->as_unique_sorted_list;
  	foreach my $entry ( @$entries )
  		{
  		my $path = $entry->path;
  		
  		my $native_path = catfile( $cpan_path, split m|/|, $path );
  		
  		push @missing, $path unless -e $native_path;
  		}
  		
  	return \@missing;
  	}
  
  =item check_for_missing_dists_in_file( CPAN_PATH )
  
  Given an object and a CPAN_PATH, return an anonymous array of the 
  distributions in CPAN_PATH that do not show up in the object. That is,
  complain when the object doesn't have all the dists.
  
  C<check_file> calls this for you and adds the result to its
  error output.
  
  =cut
  
  sub check_for_missing_dists_in_file
  	{
  	my( $packages, $cpan_path ) = @_;
  	
  	my $dists = $packages->_get_repo_dists( $cpan_path );
  	
  	$packages->_filter_older_dists( $dists );
  	
  	my %files = map { $_, 1 } @$dists;
  	use Data::Dumper;
  	
  	my( $entries ) = $packages->as_unique_sorted_list;
  
  	foreach my $entry ( @$entries )
  		{
  		my $path = $entry->path;
  		my $native_path = catfile( $cpan_path, split m|/|, $path );			
  		delete $files{$native_path};
  		}
  	
  	[ keys %files ];
  	}
  
  sub _filter_older_dists
  	{
  	my( $self, $array ) = @_;
  	
  	my %Seen;
  	my @order;
  	require  CPAN::DistnameInfo;
  	foreach my $path ( @$array )
  		{
  		my( $basename, $directory, $suffix ) = fileparse( $path, qw(.tar.gz .tgz .zip .tar.bz2) );
  		my( $name, $version, $developer ) = CPAN::DistnameInfo::distname_info( $basename );
  		my $tuple = [ $path, $name, $version ];
  		push @order, $name;
  		
  		   # first branch, haven't seen the distro yet
  		   if( ! exists $Seen{ $name } )        { $Seen{ $name } = $tuple }
  		   # second branch, the version we see now is greater than before
  		elsif( $Seen{ $name }[2] lt $version )  { $Seen{ $name } = $tuple }
  		   # third branch, nothing. Really? Are you sure there's not another case?
  		else                                   { () }
  		}
  		
  	@$array = map { 
  		if( exists $Seen{$_} )
  			{
  			my $dist = $Seen{$_}[0];
  			delete $Seen{$_};
  			$dist;
  			}
  		else
  			{
  			()
  			}
  		} @order;
  	
  	return 1;
  	}
  
  
  sub _distname_info 
  	{
  	my $file = shift or return;
  	
  	my ($dist, $version) = $file =~ /^
  		(                          # start of dist name
  			(?:
  				[-+.]*
  
  				(?:
  					[A-Za-z0-9]+
  						|
  					(?<=\D)_
  						|
  					_(?=\D)
  				)*
  	 			
  	 			(?:
  					[A-Za-z]
  					(?=
  						[^A-Za-z]
  						|
  						$
  					)
  						|
  					\d
  					(?=-)
  	 			)
  	 			
  	 			(?<!
  	 				[._-][vV]
  	 			)
  			)+
  		)                          # end of dist name
  
  		(                          # start of version
  		.*
  		)                          # end of version
  	$/xs or return ($file, undef, undef );
  
  	$dist =~ s/-undef\z// if ($dist =~ /-undef\z/ and ! length $version);
  
  	# Catch names like Unicode-Collate-Standard-V3_1_1-0.1
  	# where the V3_1_1 is part of the distname
  	if ($version =~ /^(-[Vv].*)-(\d.*)/) {
  		$dist    .= $1;
  		$version  = $2;
  		}
  
  	$version = $1            if !length $version and $dist =~ s/-(\d+\w)$//;
  
  	$version = $1 . $version if $version =~ /^\d+$/ and $dist =~ s/-(\w+)$//;
  
  	if( $version =~ /\d\.\d/ ) { $version =~ s/^[-_.]+// }
  	else                       { $version =~ s/^[-_]+//  }
  
  	# deal with versions with extra information
  	$version =~ s/-build\d+.*//;
  	$version =~ s/-DRW.*//;
  	
  	# deal with perl versions, merely to see if it is a dev version
  	my $dev;
  	if( length $version ) 
  		{
  		$dev = do {
  			if ($file =~ /^perl-?\d+\.(\d+)(?:\D(\d+))?(-(?:TRIAL|RC)\d+)?$/) 
  				{
  				 1 if (($1 > 6 and $1 & 1) or ($2 and $2 >= 50)) or $3;
  				}
  			elsif ($version =~ /\d\D\d+_\d/) 
  				{
  				1;
  				}
  			};
  		}
  	else 
  		{
  		$version = undef;
  		}
  
  	($dist, $version, $dev);
  	}
  
  sub _get_repo_dists
  	{	
  	my( $self, $cpan_home ) = @_;
  				   
  	my @files = ();
  	
  	use File::Find;
  	
  	my $wanted = sub { 
  		push @files, 
  			File::Spec::Functions::canonpath( $File::Find::name ) 
  				if m/\.(?:tar\.gz|tgz|zip)\z/ 
  			};
  	
  	find( $wanted, $cpan_home );
  	
  	return \@files;
  	}
          
  sub DESTROY {}
  
  =back
  
  
  =head3 Methods in CPAN::PackageDetails
  
  =over 4
  
  =item header_class
  
  Returns the class that C<CPAN::PackageDetails> uses to create
  the header object.
  
  =cut
  
  sub header_class { $_[0]->{header_class} }
  
  =item header
  
  Returns the header object.
  
  =cut
  	
  sub header { $_[0]->{header} }
  
  =back
  
  =head3 Methods in CPAN::PackageDetails::Header
  
  =over 4
  
  =cut
  
  =back
  	
  =head2 Entries
  
  Entries are the collection of the items describing the package details.
  It comprises all of the Entry object. 
  
  =head3 Methods is CPAN::PackageDetails
  
  =over 4
  
  =item entries_class
  
  Returns the class to use for the Entries object.
  
  To use a different Entries class, tell C<new> which class you want to use
  by passing the C<entries_class> option:
  
  	CPAN::PackageDetails->new(
  		...,
  		entries_class => $class,
  		);
  
  Note that you are responsible for loading the right class yourself.
  
  =item count
  
  Returns the number of entries.
  
  This dispatches to the C<count> in CPAN::PackageDetails::Entries. These
  are the same:
  
  	$package_details->count;
  	
  	$package_details->entries->count;
  
  =cut
  
  sub entries_class { $_[0]->{entries_class} }
  
  =item entries
  
  Returns the entries object.
  
  =cut
  
  sub entries { $_[0]->{entries} }
  
  =item entry_class
  
  Returns the class to use for each Entry object.
  
  To use a different Entry class, tell C<new> which class you want to use
  by passing the C<entry_class> option:
  
  	CPAN::PackageDetails->new(
  		...,
  		entry_class => $class,
  		)
  
  Note that you are responsible for loading the right class yourself.
  
  =cut
  
  sub entry_class { $_[0]->{entry_class} }
  
  sub _entries { $_[0]->{_entries} }
  
  =back
  
  =head1 TO DO
  
  
  =head1 SEE ALSO
  
  
  =head1 SOURCE AVAILABILITY
  
  This source is in Github:
  
  	http://github.com/briandfoy/cpan-packagedetails
  	
  =head1 AUTHOR
  
  brian d foy, C<< <bdfoy@cpan.org> >>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (c) 2009, brian d foy, All Rights Reserved.
  
  You may redistribute this under the same terms as Perl itself.
  
  =cut
  
  1;
CPAN_PACKAGEDETAILS

$fatpacked{"CPAN/PackageDetails/Entries.pm"} = <<'CPAN_PACKAGEDETAILS_ENTRIES';
  package CPAN::PackageDetails::Entries;
  use strict;
  use warnings;
  
  use vars qw($VERSION);
  $VERSION = '0.25';
  
  use Carp;
  
  sub DESTROY { }
  
  =head1 NAME
  
  CPAN::PackageDetails::Entries - Handle the collection of records of 02packages.details.txt.gz
  
  =head1 SYNOPSIS
  
  Used internally by CPAN::PackageDetails
  	
  =head1 DESCRIPTION
  
  =head2 Methods
  
  =over 4
  
  =item new
  
  Creates a new Entries object. This doesn't do anything fancy. To add
  to it, use C<add_entry>.
  
  	entry_class => the class to use for each entry object
  	columns     => the column names, in order that you want them in the output
  
  If you specify the C<allow_packages_only_once> option with a true value
  and you try to add that package twice, the object will die. See C<add_entry>.
  
  =cut
  
  sub new { 
  	my( $class, %args ) = @_;
  	
  	my %hash = ( 
  		entry_class              => 'CPAN::PackageDetails::Entry',
  		allow_packages_only_once => 1,
  		columns                  => [],
  		entries                  => {},
  		%args
  		);
  		
  	$hash{max_widths} = [ (0) x @{ $hash{columns} } ];
  	
  	bless \%hash, $_[0] 
  	}
  
  =item entry_class
  
  Returns the class that Entries uses to make a new Entry object.
  
  =cut
  
  sub entry_class { $_[0]->{entry_class} }
  
  =item columns
  
  Returns a list of the column names in the entry
  
  =cut
  
  sub columns { @{ $_[0]->{columns} } };
  
  =item column_index_for( COLUMN )
  
  Returns the list position of the named COLUMN.
  
  =cut
  
  sub column_index_for
  	{
  	my( $self, $column ) = @_;
  	
  	
  	my $index = grep {  
  		$self->{columns}[$_] eq $column
  		} 0 .. @{ $self->columns };
  		
  	return unless defined $index;
  	return $index;
  	}
  	
  =item count
  
  Returns the number of entries. This is not the same as the number of
  lines that would show up in the F<02packages.details.txt> file since
  this method counts duplicates as well. 
  
  =cut
  
  sub count 
  	{ 
  	my $self = shift;
  	
  	my $count = 0;
  	foreach my $package ( keys %{ $self->{entries} } )
  		{
  		$count += keys %{ $self->{entries}{$package} };
  		}
  		
  	return $count;
  	}
  
  =item entries
  
  Returns the list of entries as an array reference.
  
  =cut
  
  sub entries { $_[0]->{entries} }
  
  =item allow_packages_only_once( [ARG] )
  
  =cut
  
  sub allow_packages_only_once
  	{	
  	$_[0]->{allow_packages_only_once} = $_[1] if defined $_[1];
  	
  	$_[0]->{allow_packages_only_once};
  	}
  	
  =item add_entry
  
  Add an entry to the collection. Call this on the C<CPAN::PackageDetails>
  object and it will take care of finding the right handler.
  
  If you've set C<allow_packages_only_once> to a true value (which is the
  default, too), C<add_entry> will die if you try to add another entry with
  the same package name even if it has a different or greater version. You can
  set this to a false value and add as many entries as you like then use
  C<as_unqiue_sorted_list> to get just the entries with the highest 
  versions for each package.
  
  =cut
  
  sub add_entry
  	{
  	my( $self, %args ) = @_;
  
  	$self->_mark_as_dirty;
  	
  	# The column name has a space in it, but that looks weird in a 
  	# hash constructor and I keep doing it wrong. If I type "package_name"
  	# I'll just make it work.
  	if( exists $args{package_name} )
  		{
  		$args{'package name'} = $args{package_name};
  		delete $args{package_name};
  		}
  	
  	$args{'version'} = 'undef' unless defined $args{'version'};
  	
  	unless( defined $args{'package name'} )
  		{
  		croak "No 'package name' parameter!";
  		return;
  		}
  
  	unless( $args{'package name'} =~ m/
  		^
  		[A-Za-z0-9_]+
  		(?: 
  			(?:\::|')
  			[A-Za-z0-9_]+
  		)*
  		\z
  		/x )
  		{
  		croak "Package name [$args{'package name'}] looks suspicious. Not adding it!";
  		return;
  		}
  		
  	if( $self->allow_packages_only_once and $self->already_added( $args{'package name'} ) )
  		{
  		croak "$args{'package name'} was already added to CPAN::PackageDetails!";
  		return;
  		}
  	
  	# should check for allowed columns here
  	$self->{entries}{
  		$args{'package name'}
  		}{$args{'version'}
  			} = $self->entry_class->new( %args );
  	}
  
  sub _mark_as_dirty
  	{
  	delete $_[0]->{sorted};
  	}
  
  =item already_added( PACKAGE )
  
  Returns true if there is already an entry for PACKAGE.
  
  =cut
  
  sub already_added { exists $_[0]->{entries}{$_[1]} }
  
  =item as_string
  
  Returns a text version of the Entries object. This calls C<as_string>
  on each Entry object, and concatenates the results for all Entry objects.
  
  =cut
  
  sub as_string
  	{
  	my( $self ) = @_;
  	
  	my $string;
  	
  	my( $return ) = $self->as_unique_sorted_list;
  	
  	foreach my $entry ( @$return )
  		{
  		$string .= $entry->as_string( $self->columns );
  		}
  	
  	$string || '';
  	}
  
  =item as_unique_sorted_list
  
  In list context, this returns a list of entries sorted by package name
  and version. Each package exists exactly once in the list and with the
  largest version number seen.
  
  In scalar context this returns the count of the number of unique entries.
  
  Once called, it caches its result until you add more entries.
  
  =cut
  
  sub VERSION_PM () { 9 }
  sub as_unique_sorted_list
  	{
  	my( $self ) = @_;
  
  	unless( ref $self->{sorted} eq ref [] )
  		{
  		$self->{sorted} = [];
  		
  		my %Seen;
  
  		my( $k1, $k2 ) = ( $self->columns )[0,1];
  
  		my $e = $self->entries;
  
  		# We only want the latest versions of everything:
  		foreach my $package ( sort keys %$e )
  			{
  			my $entries = $e->{$package};
  			eval {
  				eval { require version } or die "Could not load version.pm!";
  				die "Your version of the version module doesn't handle the parse method!"
  					unless version->can('parse');
  				} or croak( {
  					message         => $@,
  					have_version    => eval { version->VERSION },
  					need_version    => 0.74,
  					inc             => [ @INC ],
  					error           => VERSION_PM,
  					} 
  				);
  				
  			my( $highest_version ) =
  				sort { version->parse($b) <=> version->parse($a) }
  				keys %$entries;
  
  			push @{ $self->{sorted} }, $entries->{$highest_version};
  			}
  		}
  	
  	my $return = wantarray ? 
  		$self->{sorted} 
  			:
  		scalar  @{ $self->{sorted} };
  	
  	return $return;
  	}
  
  =back
  
  =head1 TO DO
  
  =head1 SEE ALSO
  
  
  =head1 SOURCE AVAILABILITY
  
  This source is in Github:
  
  	http://github.com/briandfoy/cpan-packagedetails
  	
  =head1 AUTHOR
  
  brian d foy, C<< <bdfoy@cpan.org> >>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (c) 2009, brian d foy, All Rights Reserved.
  
  You may redistribute this under the same terms as Perl itself.
  
  =cut
  
  1;
  
CPAN_PACKAGEDETAILS_ENTRIES

$fatpacked{"CPAN/PackageDetails/Entry.pm"} = <<'CPAN_PACKAGEDETAILS_ENTRY';
  package CPAN::PackageDetails::Entry;	
  use strict;
  use warnings;
  
  use vars qw($VERSION);
  $VERSION = '0.25';
  
  use Carp;
  
  =head1 NAME
  
  CPAN::PackageDetails::Entry - Handle a single record of 02packages.details.txt.gz
  
  =head1 SYNOPSIS
  
  Used internally by CPAN::PackageDetails
  	
  =head1 DESCRIPTION
  
  An entry is a single line from F<02packages.details.txt> that maps a
  package name to a source. It's a whitespace-separated list that
  has the values for the column identified in the "columns" field
  in the header.
  
  By default, there are three columns: package name, version, and path.
  
  Inside a CPAN::PackageDetails object, the actual work and 
  manipulation of the entries are handled by delegate classes specified
  in C<entries_class> and C<entry_class>). At the moment these are
  immutable, so you'd have to subclass this module to change them.
  
  =head2 Methods
  
  =over 4
  
  =item new( FIELD1 => VALUE1 [, FIELD2 => VALUE2] )
  
  Create a new entry
  
  =cut
  
  sub new
  	{
  	my( $class, %args ) = @_;
  	
  	bless { %args }, $class
  	}
  
  =item path
  
  =item version
  
  =item package_name
  
  Access values of the entry.
  
  =cut
  
  sub path         { $_[0]->{path} }
  sub version      { $_[0]->{version} }
  sub package_name { $_[0]->{'package name'} }
  	
  =item as_string( @column_names )
  
  Formats the Entry as text. It joins with whitespace the values for the 
  column names you pass it. You get the newline automatically.
  
  Any values that are not defined (or the empty string) turn into the
  literal string 'undef' to preserve the columns in the output.
  
  =cut
  
  sub as_string
  	{
  	my( $self, @columns ) = @_;
  	
  	no warnings 'uninitialized';
  	# can't check defined() because that let's the empty string through
  	return join( "\t", 
  		map { length $self->{$_} ? $self->{$_} : 'undef' } @columns 
  		) . "\n";
  	}
  
  =back
  
  =head1 TO DO
  
  =head1 SEE ALSO
  
  
  =head1 SOURCE AVAILABILITY
  
  This source is in Github:
  
  	http://github.com/briandfoy/cpan-packagedetails
  	
  =head1 AUTHOR
  
  brian d foy, C<< <bdfoy@cpan.org> >>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (c) 2009, brian d foy, All Rights Reserved.
  
  You may redistribute this under the same terms as Perl itself.
  
  =cut
  
  1;
  
  
CPAN_PACKAGEDETAILS_ENTRY

$fatpacked{"CPAN/PackageDetails/Header.pm"} = <<'CPAN_PACKAGEDETAILS_HEADER';
  package CPAN::PackageDetails::Header;
  use strict;
  use warnings;
  
  use vars qw($VERSION);
  $VERSION = '0.25';
  
  use Carp;
  
  =head1 NAME
  
  CPAN::PackageDetails::Header - Handle the header of 02packages.details.txt.gz
  
  =head1 SYNOPSIS
  
  Used internally by CPAN::PackageDetails
  	
  =head1 DESCRIPTION
  
  The 02packages.details.txt.gz header is a short preamble that give information
  about the creation of the file, its intended use, and the number of entries in
  the file. It looks something like:
  
  	File:         02packages.details.txt
  	URL:          http://www.perl.com/CPAN/modules/02packages.details.txt
  	Description:  Package names found in directory $CPAN/authors/id/
  	Columns:      package name, version, path
  	Intended-For: Automated fetch routines, namespace documentation.
  	Written-By:   Id: mldistwatch.pm 1063 2008-09-23 05:23:57Z k 
  	Line-Count:   59754
  	Last-Updated: Thu, 23 Oct 2008 02:27:36 GMT
  
  Note that there is a Columns field. This module tries to respect the ordering
  of columns in there. The usual CPAN tools expect only three columns and in the
  order in this example, but C<CPAN::PackageDetails> tries to handle any number
  of columns in any order.
  
  =head2 Methods
  
  =over 4
  
  =item new( HASH ) 
  
  Create a new Header object. Unless you want a lot of work so you
  get more control, just let C<CPAN::PackageDetails>'s C<new> or C<read>
  handle this for you.
  
  In most cases, you'll want to create the Entries object first then
  pass a reference the the Entries object to C<new> since the header 
  object needs to know how to get the count of the number of entries
  so it can put it in the "Line-Count" header.
  
  	CPAN::PackageDetails::Header->new(
  		_entries => $entries_object,
  		)
  
  =cut
  
  sub new 
  	{ 
  	my( $class, %args ) = @_;
  	
  	my %hash = ( 
  		_entries => undef,
  		%args
  		);
  			
  	bless \%hash, $_[0] 
  	}
  
  =item format_date
  
  Write the date in PAUSE format. For example:
  
  	Thu, 23 Oct 2008 02:27:36 GMT
  	
  =cut
  
  sub format_date 
  	{ 
  	my( $second, $minute, $hour, $date, $monnum, $year, $wday )  = gmtime;
  	$year += 1900;
  
  	my $day   = ( qw(Sun Mon Tue Wed Thu Fri Sat) )[$wday];
  	my $month = ( qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec) )[$monnum];
  
  	sprintf "%s, %02d %s %4d %02d:%02d:%02d GMT",
  		$day, $date, $month, $year, $hour, $minute, $second;
  	}
  
  =item default_headers
  
  Returns a list of the the headers that should show up in the file. This
  excludes various fake headers stored in the object.
  
  =cut
  
  sub default_headers
  	{ 
  	map { $_, $_[0]->{$_} } 
  		grep ! /^_|_class|allow/, keys %{ $_[0] } 
  	}
  
  sub can
  	{
  	my( $self, @methods ) = @_;
  	
  	my $class = ref $self || $self; # class or instance
  	
  	foreach my $method ( @methods )
  		{
  		next if 
  			defined &{"${class}::$method"} || 
  			$self->header_exists( $method );
  		return 0;
  		}
  		
  	return 1;
  	}
  
  =item set_header
  
  Add an entry to the collection. Call this on the C<CPAN::PackageDetails>
  object and it will take care of finding the right handler.
  
  =cut
  
  sub set_header
  	{
  	my( $self, $field, $value ) = @_;
  	
  	$self->{$field} = $value;
  	}
  
  =item header_exists( FIELD )
  
  Returns true if the header has a field named FIELD, regardless of
  its value.
  
  =cut
  
  sub header_exists 
  	{
  	my( $self, $field ) = @_;
  	
  	exists $self->{$field}
  	}
  	
  =item get_header( FIELD )
  
  Returns the value for the named header FIELD. Carps and returns nothing
  if the named header is not in the object. This method is available from
  the C<CPAN::PackageDetails> or C<CPAN::PackageDetails::Header> object:
  
  	$package_details->get_header( 'url' );
  	
  	$package_details->header->get_header( 'url' );
  	
  The header names in the Perl code are in a different format than they
  are in the file. See C<default_headers> for an explanation of the
  difference.
  
  For most headers, you can also use the header name as the method name:
  	
  	$package_details->header->url;
  
  =cut
  
  sub get_header 
  	{
  	my( $self, $field ) = @_;
  	
  	if( $self->header_exists( $field ) ) { $self->{$field} }
  	else { carp "No such header as $field!"; return }
  	}
  
  =item columns_as_list
  
  Returns the columns name as a list (rather than a comma-joined string). The
  list is in the order of the columns in the output.
  
  =cut
  
  sub columns_as_list { split /,\s+/, $_[0]->{columns} }
  
  =item as_string
  
  Return the header formatted as a string.
  
  =cut
  
  BEGIN {
  my %internal_field_name_mapping = (
  	url => 'URL',
  	);
  	
  my %external_field_name_mapping = reverse %internal_field_name_mapping;
  
  sub _internal_name_to_external_name
  	{
  	my( $self, $internal ) = @_;
  	
  	return $internal_field_name_mapping{$internal} 
  		if exists $internal_field_name_mapping{$internal};
  		
  	(my $external = $internal) =~ s/_/-/g;
  	$external =~ s/^(.)/ uc $1 /eg;
  	$external =~ s/-(.)/ "-" . uc $1 /eg;
  		
  	return $external;
  	}
  	
  sub _external_name_to_internal_name
  	{
  	my( $self, $external ) = @_;
  
  	return $external_field_name_mapping{$external} 
  		if exists $external_field_name_mapping{$external};
  	
  	(my $internal = $external) =~ s/-/_/g;
  
  	lc $internal;
  	}
  	
  sub as_string
  	{
  	my( $self, $line_count ) = @_;
  	
  	# XXX: need entry count
  	my @lines;
  	foreach my $field ( keys %$self )
  		{
  		next if substr( $field, 0, 1 ) eq '_';
  		my $value = $self->get_header( $field );
  		
  		my $out_field = $self->_internal_name_to_external_name( $field );
  		
  		push @lines, "$out_field: $value";
  		}
  		
  	push @lines, "Line-Count: " . $self->_entries->as_unique_sorted_list;
  	
  	join "\n", sort( @lines ), "\n";
  	}
  }
  	
  sub AUTOLOAD
  	{
  	my $self = shift;
  	
  	( my $method = $CPAN::PackageDetails::Header::AUTOLOAD ) =~ s/.*:://;
  	
  	carp "No such method as $method!" unless $self->can( $method );
  	
  	$self->get_header( $method );
  	}
  
  sub DESTROY { }
  
  =back
  
  =head1 TO DO
  
  
  =head1 SEE ALSO
  
  
  =head1 SOURCE AVAILABILITY
  
  This source is in Github:
  
  	http://github.com/briandfoy/cpan-packagedetails
  	
  =head1 AUTHOR
  
  brian d foy, C<< <bdfoy@cpan.org> >>
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (c) 2009, brian d foy, All Rights Reserved.
  
  You may redistribute this under the same terms as Perl itself.
  
  =cut
  
  1;
CPAN_PACKAGEDETAILS_HEADER

$fatpacked{"CPAN/ParseDistribution.pm"} = <<'CPAN_PARSEDISTRIBUTION';
  package CPAN::ParseDistribution;
  
  use strict;
  use warnings;
  
  use vars qw($VERSION);
  
  $VERSION = '1.3';
  
  use Cwd qw(getcwd abs_path);
  use File::Temp qw(tempdir);
  use File::Find::Rule;
  use File::Path;
  use Data::Dumper;
  use Archive::Tar;
  use Archive::Zip;
  use YAML qw(LoadFile);
  use Safe;
  # safe to load, load now because it's commonly used for $VERSION
  # use version;
  
  $Archive::Tar::DO_NOT_USE_PREFIX = 1;
  $Archive::Tar::CHMOD = 0;
  
  =head1 NAME
  
  CPAN::ParseDistribution - index a file from the BackPAN
  
  =head1 DESCRIPTION
  
  Given a file from the BackPAN, this will let you find out what versions
  of what modules it contains, the distribution name and version
  
  =head1 SYNOPSIS
  
      my $dist = CPAN::ParseDistribution->new(
          'A/AU/AUTHORID/subdirectory/Some-Distribution-1.23.tar.gz',
          use_tar => '/bin/tar',
          ...
      );
      my $modules     = $dist->modules(); # hashref of modname => version
      my $distname    = $dist->dist();
      my $distversion = $dist->distversion();
  
  =head1 METHODS
  
  =head2 new
  
  Constructor, takes a single mandatory argument, which should be a tarball
  or zip file from the CPAN or BackPAN, and some optional named arguments:
  
  =over
  
  =item use_tar
  
  The full path to 'tar'.  This is assumed to be GNU tar, and to be
  sufficiently well-endowed as to be able to support bzip2 files.
  Maybe I'll fix that at some point.  If this isn't specified, then
  Archive::Tar is used instead.
  
  You might want to use this if dealing with very large files, as
  Archive::Tar is rather profligate with memory.
  
  =back
  
  =cut
  
  sub new {
      my($class, $file, %extra_params) = @_;
      die("file parameter is mandatory\n") unless($file);
      die("$file doesn't exist\n") if(!-e $file);
      die("$file looks like a ppm\n")
          if($file =~ /\.ppm\.(tar(\.gz|\.bz2)?|tbz|tgz|zip)$/i);
      die("$file isn't the right type\n")
          if($file !~ /\.(tar(\.gz|\.bz2)?|tbz|tgz|zip)$/i);
      $file = abs_path($file);
  
      # dist name and version
      (my $dist = $file) =~ s{(^.*/|\.(tar(\.gz|\.bz2)?|tbz|tgz|zip)$)}{}gi;
      $dist =~ /^(.*)-(\d.*)$/;
      ($dist, my $distversion) = ($1, $2);
      die("Can't index perl itself ($dist-$distversion)\n")
          if($dist =~ /^(perl|ponie|kurila|parrot|Perl6-Pugs|v6-pugs)$/);
  
      bless {
          file    => $file,
          modules => {},
          dist    => $dist,
          distversion => $distversion,
          extra_params => \%extra_params,
      }, $class;
  }
  
  # takes a filename, unarchives it, returns the directory it's been
  # unarchived into
  sub _unarchive {
      my($file, %extra_params) = @_;
      my $olddir = getcwd();
      my $tempdir = tempdir(TMPDIR => 1);
      chdir($tempdir);
      if($file =~ /\.zip$/i) {
          my $zip = Archive::Zip->new($file);
          $zip->extractTree() if($zip);
      } elsif($file =~ /\.(tar(\.gz)?|tgz)$/i) {
          if($extra_params{use_tar}) {
              system(
                  $extra_params{use_tar},
                  (($file =~ /gz$/) ? 'xzf' : 'xf'),
                  $file
              );
              system("chmod -R u+r *"); # tar might preserve unreadable perms
          } else {
              my $tar = Archive::Tar->new($file, 1);
              $tar->extract() if($tar);
          }
      } else {
          if($extra_params{use_tar}) {
              system( $extra_params{use_tar}, 'xjf', $file);
              system("chmod -R u+r *");
          } else {
              open(my $fh, '-|', qw(bzip2 -dc), $file) || die("Can't unbzip2\n");
              my $tar = Archive::Tar->new($fh);
              $tar->extract() if($tar);
          }
      }
      chdir($olddir);
      return $tempdir;
  }
  
  # adapted from PAUSE::pmfile::parse_version_safely in mldistwatch.pm
  sub _parse_version_safely {
      my($parsefile) = @_;
      my $result;
      my $eval;
      local $/ = "\n";
      open(my $fh, $parsefile) or die "Could not open '$parsefile': $!";
      my $inpod = 0;
      while (<$fh>) {
          $inpod = /^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;
          next if $inpod || /^\s*#/;
          chop;
          next unless /([\$*])(([\w\:\']*)\bVERSION)\b.*\=/;
          my($sigil, $var) = ($1, $2);
          my $current_parsed_line = $_;
          {
              local $^W = 0;
              no strict;
              my $c = Safe->new();
              $c->deny(qw(
                   tie untie tied chdir flock ioctl socket getpeername
                   ssockopt bind connect listen accept shutdown gsockopt
                   getsockname sleep alarm entereval reset dbstate
                   readline rcatline getc read formline enterwrite
                   leavewrite print sysread syswrite send recv eof
                   tell seek sysseek readdir telldir seekdir rewinddir
                   lock stat lstat readlink ftatime ftblk ftchr ftctime
                   ftdir fteexec fteowned fteread ftewrite ftfile ftis
                   ftlink ftmtime ftpipe ftrexec ftrowned ftrread ftsgid
                   ftsize ftsock ftsuid fttty ftzero ftrwrite ftsvtx
                   fttext ftbinary fileno ghbyname ghbyaddr ghostent
                   shostent ehostent gnbyname gnbyaddr gnetent snetent
                   enetent gpbyname gpbynumber gprotoent sprotoent
                   eprotoent gsbyname gsbyport gservent sservent
                   eservent  gpwnam gpwuid gpwent spwent epwent
                   getlogin ggrnam ggrgid ggrent sgrent egrent msgctl
                   msgget msgrcv msgsnd semctl semget semop shmctl
                   shmget shmread shmwrite require dofile caller
                   syscall dump chroot link unlink rename symlink
                   truncate backtick system fork wait waitpid glob
                   exec exit kill time tms mkdir rmdir utime chmod
                   chown fcntl sysopen open close umask binmode
                   open_dir closedir 
              ), ($] >= 5.010 ? qw(say) : ()));
              $c->share_from(__PACKAGE__, [qw(qv)]);
              s/\buse\s+version\b.*?;//gs;
              # qv broke some time between version.pm 0.74 and 0.82
              # so just extract it and hope for the best
              s/\bqv\s*\(\s*(["']?)([\d\.]+)\1\s*\)\s*/"$2"/;
              s/\buse\s+vars\b//g;
              $eval = qq{
                  local ${sigil}${var};
                  \$$var = undef; do {
                      $_
                  }; \$$var
              };
              eval {
                  local $SIG{ALRM} = sub { die("Safe compartment timed out\n"); };
                  alarm(5); # Safe compartment can't turn this off
                  $result = $c->reval($eval);
                  alarm(0);
                  die($@) if($@);
              };
          };
          # stuff that's my fault because of the Safe compartment
          # warn($eval) if($@);
          if($@ =~ /trapped by operation mask|safe compartment timed out/i) {
              warn("Unsafe code in \$VERSION\n$@\n$parsefile\n$eval");
              $result = undef;
          } elsif($@) {
              warn "_parse_version_safely: ".Dumper({
                  eval => $eval,
                  line => $current_parsed_line,
                  file => $parsefile,
                  err => $@,
              });
          }
          last;
      }
      close $fh;
  
      # # version.pm objects come out as Safe::...::version objects,
      # # which breaks weirdly
      # bless($result, 'version') if(ref($result) =~ /::version$/);
      return $result;
  }
  
  =head2 isdevversion
  
  Returns true or false depending on whether this is a developer-only
  or trial release of a distribution.  This is determined by looking for
  an underscore in the distribution version or the string '-TRIAL' at the
  end of the distribution version.
  
  =cut
  
  sub isdevversion {
      my $self = shift;
      return 1 if($self->distversion() =~ /(_|-TRIAL$)/);
      return 0;
  }
  
  =head2 modules
  
  Returns a hashref whose keys are module names, and their values are
  the versions of the modules.  The version number is retrieved by
  eval()ing what looks like a $VERSION line in the code.  This is done
  in a C<Safe> compartment, but may be a security risk if you do this
  with untrusted code.  Caveat user!
  
  =cut
  
  sub modules {
      my $self = shift;
      if(!(keys %{$self->{modules}})) {
          $self->{_modules_runs}++;
          my $tempdir = _unarchive($self->{file}, %{$self->{extra_params}});
  
          my $meta = (File::Find::Rule->file()->name('META.yml')->in($tempdir))[0];
          my $ignore = join('|', qw(t inc xt));
          my %ignorefiles;
          my %ignorepackages;
          my %ignorenamespaces;
          if($meta && -e $meta) {
              my $yaml = eval { LoadFile($meta); };
              if(!$@ &&
                  UNIVERSAL::isa($yaml, 'HASH') &&
                  exists($yaml->{no_index}) &&
                  UNIVERSAL::isa($yaml->{no_index}, 'HASH')
              ) {
                  if(exists($yaml->{no_index}->{directory})) {
                      if(eval { @{$yaml->{no_index}->{directory}} }) {
                          $ignore = join('|', $ignore,
                              @{$yaml->{no_index}->{directory}}
                          );
                      } elsif(!ref($yaml->{no_index}->{directory})) {
                           $ignore .= '|'.$yaml->{no_index}->{directory}
                      }
                  }
                  if(exists($yaml->{no_index}->{file})) {
                      if(eval { @{$yaml->{no_index}->{file}} }) {
                          %ignorefiles = map { $_, 1 }
                              @{$yaml->{no_index}->{file}};
                      } elsif(!ref($yaml->{no_index}->{file})) {
                           $ignorefiles{$yaml->{no_index}->{file}} = 1;
                      }
                  }
                  if(exists($yaml->{no_index}->{package})) {
                      if(eval { @{$yaml->{no_index}->{package}} }) {
                          %ignorepackages = map { $_, 1 }
                              @{$yaml->{no_index}->{package}};
                      } elsif(!ref($yaml->{no_index}->{package})) {
                           $ignorepackages{$yaml->{no_index}->{package}} = 1;
                      }
                  }
                  if(exists($yaml->{no_index}->{namespace})) {
                      if(eval { @{$yaml->{no_index}->{namespace}} }) {
                          %ignorenamespaces = map { $_, 1 }
                              @{$yaml->{no_index}->{namespace}};
                      } elsif(!ref($yaml->{no_index}->{namespace})) {
                           $ignorenamespaces{$yaml->{no_index}->{namespace}} = 1;
                      }
                  }
              }
          }
          # find modules
          my @PMs = grep {
              my $pm = $_;
              $pm !~ m{^\Q$tempdir\E/[^/]+/($ignore)} &&
              !grep { $pm =~ m{^\Q$tempdir\E/[^/]+/$_$} } (keys %ignorefiles)
          } File::Find::Rule->file()->name('*.pm')->in($tempdir);
          foreach my $PM (@PMs) {
              local $/ = undef;
              my $version = _parse_version_safely($PM);
              open(my $fh, $PM) || die("Can't read $PM\n");
              $PM = <$fh>;
              close($fh);
  
              # from PAUSE::pmfile::packages_per_pmfile in mldistwatch.pm
              if($PM =~ /\bpackage[ \t]+([\w\:\']+)\s*($|[};])/) {
                  my $module = $1;
                  $self->{modules}->{$module} = $version unless(
                      exists($ignorepackages{$module}) ||
                      (grep { $module =~ /${_}::/ } keys %ignorenamespaces)
                  );
              }
          }
          rmtree($tempdir);
      }
      return $self->{modules};
  }
  
  =head2 dist
  
  Return the name of the distribution. eg, in the synopsis above, it would
  return 'Some-Distribution'.
  
  =cut
  
  sub dist {
      my $self = shift;
      return $self->{dist};
  }
  
  =head2 distversion
  
  Return the version of the distribution. eg, in the synopsis above, it would
  return 1.23.
  
  Strictly speaking, the CPAN doesn't have distribution versions -
  Foo-Bar-1.23.tar.gz is not considered to have any relationship to
  Foo-Bar-1.24.tar.gz, they just happen to coincidentally have rather
  similar contents.  But other tools, such as those used by the CPAN testers,
  do treat distributions as being versioned.
  
  =cut
  
  sub distversion{
      my $self = shift;
      return $self->{distversion};
  }
  
  =head1 SECURITY
  
  This module executes a very small amount of code from each module that
  it finds in a distribution.  While every effort has been made to do
  this safely, there are no guarantees that it won't let the distributions
  you're examining do horrible things to your machine, such as email your
  password file to strangers.  You are strongly advised to read the source
  code and to run it in a very heavily restricted user account.
  
  =head1 LIMITATIONS, BUGS and FEEDBACK
  
  I welcome feedback about my code, including constructive criticism.
  Bug reports should be made using L<http://rt.cpan.org/> or by email,
  and should include the smallest possible chunk of code, along with
  any necessary data, which demonstrates the bug.  Ideally, this
  will be in the form of files which I can drop in to the module's
  test suite.
  
  =cut
  
  =head1 SEE ALSO
  
  L<http://pause.perl.org/>
  
  L<dumpcpandist>
  
  =head1 AUTHOR, COPYRIGHT and LICENCE
  
  Copyright 2009-2011 David Cantrell E<lt>david@cantrell.org.ukE<gt>
  
  Contains code originally from the PAUSE by Andreas Koenig.
  
  This software is free-as-in-speech software, and may be used,
  distributed, and modified under the terms of either the GNU
  General Public Licence version 2 or the Artistic Licence.  It's
  up to you which one you use.  The full text of the licences can
  be found in the files GPL2.txt and ARTISTIC.txt, respectively.
  
  =head1 CONSPIRACY
  
  This module is also free-as-in-mason software.
  
  =cut
  
  1;
CPAN_PARSEDISTRIBUTION

$fatpacked{"Class/Load.pm"} = <<'CLASS_LOAD';
  package Class::Load;
  use strict;
  use warnings;
  use base 'Exporter';
  use File::Spec;
  use Scalar::Util 'reftype';
  
  our $VERSION = '0.06';
  
  our @EXPORT_OK = qw/load_class load_optional_class try_load_class is_class_loaded/;
  our %EXPORT_TAGS = (
      all => \@EXPORT_OK,
  );
  
  our $ERROR;
  
  BEGIN {
      *IS_RUNNING_ON_5_10 = ($] < 5.009_005)
          ? sub () { 0 }
          : sub () { 1 };
  }
  
  sub load_class {
      my $class = shift;
  
      my ($res, $e) = try_load_class($class);
      return 1 if $res;
  
      require Carp;
      Carp::croak $e;
  }
  
  sub load_optional_class {
      my $class = shift;
      # If success, then we report "Its there"
      return 1 if try_load_class($class);
  
      # My testing says that if its in INC, the file definately exists
      # on disk. In all versions of Perl. The value isn't reliable,
      # but it existing is.
      my $file = _mod2pm( $class );
      return 0 unless exists $INC{$file};
  
      require Carp;
      Carp::croak $ERROR;
  }
  
  sub _mod2pm {
      my $class = shift;
      # see rt.perl.org #19213
      my @parts = split '::', $class;
      my $file = $^O eq 'MSWin32'
               ? join '/', @parts
               : File::Spec->catfile(@parts);
      $file .= '.pm';
      return $file;
  }
  
  sub try_load_class {
      my $class = shift;
  
      local $@;
      undef $ERROR;
  
      return 1 if is_class_loaded($class);
  
      my $file = _mod2pm($class);
      # This says "our diagnostics of the package
      # say perl's INC status about the file being loaded are
      # wrong", so we delete it from %INC, so when we call require(),
      # perl will *actually* try reloading the file.
      #
      # If the file is already in %INC, it won't retry,
      # And on 5.8, it won't fail either!
      #
      # The extra benefit of this trick, is it helps even on
      # 5.10, as instead of dying with "Compilation failed",
      # it will die with the actual error, and thats a win-win.
      delete $INC{$file};
      return 1 if eval {
          local $SIG{__DIE__} = 'DEFAULT';
          require $file;
          1;
      };
  
      $ERROR = $@;
      return 0 unless wantarray;
      return 0, $@;
  }
  
  sub _is_valid_class_name {
      my $class = shift;
  
      return 0 if ref($class);
      return 0 unless defined($class);
      return 0 unless length($class);
  
      return 1 if $class =~ /^\w+(?:::\w+)*$/;
  
      return 0;
  }
  
  sub is_class_loaded {
      my $class = shift;
  
      return 0 unless _is_valid_class_name($class);
  
      # walk the symbol table tree to avoid autovififying
      # \*{${main::}{"Foo::"}} == \*main::Foo::
  
      my $pack = \*::;
      foreach my $part (split('::', $class)) {
          return 0 unless exists ${$$pack}{"${part}::"};
          $pack = \*{${$$pack}{"${part}::"}};
      }
  
      # We used to check in the package stash, but it turns out that
      # *{${$$package}{VERSION}{SCALAR}} can end up pointing to a
      # reference to undef. It looks
  
      my $version = do {
          no strict 'refs';
          ${$class . '::VERSION'};
      };
  
      return 1 if ! ref $version && defined $version;
      # Sometimes $VERSION ends up as a reference to undef (weird)
      return 1 if ref $version && reftype $version eq 'SCALAR' && defined ${$version};
  
      return 1 if exists ${$$pack}{ISA}
               && defined *{${$$pack}{ISA}}{ARRAY};
  
      # check for any method
      foreach ( keys %{$$pack} ) {
          next if substr($_, -2, 2) eq '::';
  
          my $glob = ${$$pack}{$_} || next;
  
          # constant subs
          if ( IS_RUNNING_ON_5_10 ) {
              my $ref = ref($glob);
              return 1 if $ref eq 'SCALAR' || $ref eq 'REF';
          }
  
          # stubs
          my $refref = ref(\$glob);
          return 1 if $refref eq 'SCALAR';
  
          return 1 if defined *{$glob}{CODE};
      }
  
      # fail
      return 0;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Class::Load - a working (require "Class::Name") and more
  
  =head1 SYNOPSIS
  
      use Class::Load ':all';
  
      try_load_class('Class::Name')
          or plan skip_all => "Class::Name required to run these tests";
  
      load_class('Class::Name');
  
      is_class_loaded('Class::Name');
  
      my $baseclass = load_optional_class('Class::Name::MightExist')
          ? 'Class::Name::MightExist'
          : 'Class::Name::Default';
  
  =head1 DESCRIPTION
  
  C<require EXPR> only accepts C<Class/Name.pm> style module names, not
  C<Class::Name>. How frustrating! For that, we provide
  C<load_class 'Class::Name'>.
  
  It's often useful to test whether a module can be loaded, instead of throwing
  an error when it's not available. For that, we provide
  C<try_load_class 'Class::Name'>.
  
  Finally, sometimes we need to know whether a particular class has been loaded.
  Asking C<%INC> is an option, but that will miss inner packages and any class
  for which the filename does not correspond to the package name. For that, we
  provide C<is_class_loaded 'Class::Name'>.
  
  =head1 FUNCTIONS
  
  =head2 load_class Class::Name
  
  C<load_class> will load C<Class::Name> or throw an error, much like C<require>.
  
  If C<Class::Name> is already loaded (checked with C<is_class_loaded>) then it
  will not try to load the class. This is useful when you have inner packages
  which C<require> does not check.
  
  =head2 try_load_class Class::Name -> 0|1
  =head2 try_load_class Class::Name -> (0|1, error message)
  
  Returns 1 if the class was loaded, 0 if it was not. If the class was not
  loaded, the error will be returned as a second return value in list context.
  
  Again, if C<Class::Name> is already loaded (checked with C<is_class_loaded>)
  then it will not try to load the class. This is useful when you have inner
  packages which C<require> does not check.
  
  =head2 is_class_loaded Class::Name -> 0|1
  
  This uses a number of heuristics to determine if the class C<Class::Name> is
  loaded. There heuristics were taken from L<Class::MOP>'s old pure-perl
  implementation.
  
  =head2 load_optional_class Class::Name -> 0|1
  
  C<load_optional_class> is a lot like C<try_load_class>, but also a lot like
  C<load_class>.
  
  If the class exists, and it works, then it will return 1.
  
  If the class doesn't exist, and it appears to not exist on disk either, it
  will return 0.
  
  If the class exists on disk, but loading from disk results in an error
  ( ie: a syntax error ), then it will C<croak> with that error.
  
  This is useful for using if you want a fallback module system, ie:
  
      my $class = load_optional_class($foo) ? $foo : $default;
  
  That way, if $foo does exist, but can't be loaded due to error, you won't
  get the behaviour of it simply not existing.
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<UNIVERSAL::require>
  
  Adds a C<require> method to C<UNIVERSAL> so that you can say
  C<< Class::Name->require >>. I personally dislike the pollution.
  
  =item L<Module::Load>
  
  Supports C<Class::Name> and C<< Class/Name.pm >> formats, no C<try_to_load> or
  C<is_class_loaded>.
  
  =item L<Moose>, L<Jifty>, L<Prophet>, etc
  
  This module was designed to be used anywhere you have
  C<if (eval "require $module"; 1)>, which occurs in many large projects.
  
  =back
  
  =head1 AUTHOR
  
  Shawn M Moore, C<< <sartak at bestpractical.com> >>
  
  The implementation of C<is_class_loaded> has been taken from L<Class::MOP>.
  
  =head1 BUGS
  
  Please report any bugs or feature requests to
  C<bug-class-load at rt.cpan.org>, or through the web interface at
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Class-Load>.
  
  =head1 COPYRIGHT & LICENSE
  
  Copyright 2008-2009 Best Practical Solutions.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
CLASS_LOAD

$fatpacked{"Data/OptList.pm"} = <<'DATA_OPTLIST';
  
  package Data::OptList;
  use strict;
  use warnings;
  
  use List::Util ();
  use Params::Util ();
  use Sub::Install 0.921 ();
  
  =head1 NAME
  
  Data::OptList - parse and validate simple name/value option pairs
  
  =head1 VERSION
  
  version 0.106
  
  =cut
  
  our $VERSION = '0.106';
  
  =head1 SYNOPSIS
  
    use Data::OptList;
  
    my $options = Data::OptList::mkopt([
      qw(key1 key2 key3 key4),
      key5 => { ... },
      key6 => [ ... ],
      key7 => sub { ... },
      key8 => { ... },
      key8 => [ ... ],
    ]);
  
  ...is the same thing, more or less, as:
  
    my $options = [
      [ key1 => undef,        ],
      [ key2 => undef,        ],
      [ key3 => undef,        ],
      [ key4 => undef,        ],
      [ key5 => { ... },      ],
      [ key6 => [ ... ],      ],
      [ key7 => sub { ... },  ],
      [ key8 => { ... },      ],
      [ key8 => [ ... ],      ],
    ]);
  
  =head1 DESCRIPTION
  
  Hashes are great for storing named data, but if you want more than one entry
  for a name, you have to use a list of pairs.  Even then, this is really boring
  to write:
  
    $values = [
      foo => undef,
      bar => undef,
      baz => undef,
      xyz => { ... },
    ];
  
  Just look at all those undefs!  Don't worry, we can get rid of those:
  
    $values = [
      map { $_ => undef } qw(foo bar baz),
      xyz => { ... },
    ];
  
  Aaaauuugh!  We've saved a little typing, but now it requires thought to read,
  and thinking is even worse than typing... and it's got a bug!  It looked right,
  didn't it?  Well, the C<< xyz => { ... } >> gets consumed by the map, and we
  don't get the data we wanted.
  
  With Data::OptList, you can do this instead:
  
    $values = Data::OptList::mkopt([
      qw(foo bar baz),
      xyz => { ... },
    ]);
  
  This works by assuming that any defined scalar is a name and any reference
  following a name is its value.
  
  =head1 FUNCTIONS
  
  =head2 mkopt
  
    my $opt_list = Data::OptList::mkopt(
      $input,
      $moniker,
      $require_unique,
      $must_be,
    );
  
  This produces an array of arrays; the inner arrays are name/value pairs.
  Values will be either "undef" or a reference.
  
  Valid values for C<$input>:
  
   undef    -> []
   hashref  -> [ [ key1 => value1 ] ... ] # non-ref values become undef
   arrayref -> every value followed by a ref becomes a pair: [ value => ref   ]
               every value followed by undef becomes a pair: [ value => undef ]
               otherwise, it becomes [ value => undef ] like so:
               [ "a", "b", [ 1, 2 ] ] -> [ [ a => undef ], [ b => [ 1, 2 ] ] ]
  
  C<$moniker> is a name describing the data, which will be used in error
  messages.
  
  If C<$require_unique> is true, an error will be thrown if any name is given
  more than once.
  
  C<$must_be> is either a scalar or array of scalars; it defines what kind(s) of
  refs may be values.  If an invalid value is found, an exception is thrown.  If
  no value is passed for this argument, any reference is valid.  If C<$must_be>
  specifies that values must be CODE, HASH, ARRAY, or SCALAR, then Params::Util
  is used to check whether the given value can provide that interface.
  Otherwise, it checks that the given value is an object of the kind.
  
  In other words:
  
    [ qw(SCALAR HASH Object::Known) ]
  
  Means:
  
    _SCALAR0($value) or _HASH($value) or _INSTANCE($value, 'Object::Known')
  
  =cut
  
  my %test_for;
  BEGIN {
    %test_for = (
      CODE   => \&Params::Util::_CODELIKE,  ## no critic
      HASH   => \&Params::Util::_HASHLIKE,  ## no critic
      ARRAY  => \&Params::Util::_ARRAYLIKE, ## no critic
      SCALAR => \&Params::Util::_SCALAR0,   ## no critic
    );
  }
  
  sub __is_a {
    my ($got, $expected) = @_;
  
    return List::Util::first { __is_a($got, $_) } @$expected if ref $expected;
  
    return defined (
      exists($test_for{$expected})
      ? $test_for{$expected}->($got)
      : Params::Util::_INSTANCE($got, $expected) ## no critic
    );
  }
  
  sub mkopt {
    my ($opt_list, $moniker, $require_unique, $must_be) = @_;
  
    return [] unless $opt_list;
  
    $opt_list = [
      map { $_ => (ref $opt_list->{$_} ? $opt_list->{$_} : ()) } keys %$opt_list
    ] if ref $opt_list eq 'HASH';
  
    my @return;
    my %seen;
  
    for (my $i = 0; $i < @$opt_list; $i++) { ## no critic
      my $name = $opt_list->[$i];
      my $value;
  
      if ($require_unique) {
        Carp::croak "multiple definitions provided for $name" if $seen{$name}++;
      }
  
      if    ($i == $#$opt_list)             { $value = undef;            }
      elsif (not defined $opt_list->[$i+1]) { $value = undef; $i++       }
      elsif (ref $opt_list->[$i+1])         { $value = $opt_list->[++$i] }
      else                                  { $value = undef;            }
  
      if ($must_be and defined $value) {
        unless (__is_a($value, $must_be)) {
          my $ref = ref $value;
          Carp::croak "$ref-ref values are not valid in $moniker opt list";
        }
      }
  
      push @return, [ $name => $value ];
    }
  
    return \@return;
  }
  
  =head2 mkopt_hash
  
    my $opt_hash = Data::OptList::mkopt_hash($input, $moniker, $must_be);
  
  Given valid C<L</mkopt>> input, this routine returns a reference to a hash.  It
  will throw an exception if any name has more than one value.
  
  =cut
  
  sub mkopt_hash {
    my ($opt_list, $moniker, $must_be) = @_;
    return {} unless $opt_list;
  
    $opt_list = mkopt($opt_list, $moniker, 1, $must_be);
    my %hash = map { $_->[0] => $_->[1] } @$opt_list;
    return \%hash;
  }
  
  =head1 EXPORTS
  
  Both C<mkopt> and C<mkopt_hash> may be exported on request.
  
  =cut
  
  BEGIN {
    *import = Sub::Install::exporter {
      exports => [qw(mkopt mkopt_hash)],
    };
  }
  
  =head1 AUTHOR
  
  Ricardo SIGNES, C<< <rjbs@cpan.org> >>
  
  =head1 BUGS
  
  Please report any bugs or feature requests at L<http://rt.cpan.org>. I will be
  notified, and then you'll automatically be notified of progress on your bug as
  I make changes.
  
  =head1 COPYRIGHT
  
  Copyright 2006-2007, Ricardo SIGNES.  This program is free software;  you can
  redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  1;
DATA_OPTLIST

$fatpacked{"File/Find/Rule.pm"} = <<'FILE_FIND_RULE';
  #       $Id$
  
  package File::Find::Rule;
  use strict;
  use File::Spec;
  use Text::Glob 'glob_to_regex';
  use Number::Compare;
  use Carp qw/croak/;
  use File::Find (); # we're only wrapping for now
  
  our $VERSION = '0.32';
  
  # we'd just inherit from Exporter, but I want the colon
  sub import {
      my $pkg = shift;
      my $to  = caller;
      for my $sym ( qw( find rule ) ) {
          no strict 'refs';
          *{"$to\::$sym"} = \&{$sym};
      }
      for (grep /^:/, @_) {
          my ($extension) = /^:(.*)/;
          eval "require File::Find::Rule::$extension";
          croak "couldn't bootstrap File::Find::Rule::$extension: $@" if $@;
      }
  }
  
  =head1 NAME
  
  File::Find::Rule - Alternative interface to File::Find
  
  =head1 SYNOPSIS
  
    use File::Find::Rule;
    # find all the subdirectories of a given directory
    my @subdirs = File::Find::Rule->directory->in( $directory );
  
    # find all the .pm files in @INC
    my @files = File::Find::Rule->file()
                                ->name( '*.pm' )
                                ->in( @INC );
  
    # as above, but without method chaining
    my $rule =  File::Find::Rule->new;
    $rule->file;
    $rule->name( '*.pm' );
    my @files = $rule->in( @INC );
  
  =head1 DESCRIPTION
  
  File::Find::Rule is a friendlier interface to File::Find.  It allows
  you to build rules which specify the desired files and directories.
  
  =cut
  
  # the procedural shim
  
  *rule = \&find;
  sub find {
      my $object = __PACKAGE__->new();
      my $not = 0;
  
      while (@_) {
          my $method = shift;
          my @args;
  
          if ($method =~ s/^\!//) {
              # jinkies, we're really negating this
              unshift @_, $method;
              $not = 1;
              next;
          }
          unless (defined prototype $method) {
              my $args = shift;
              @args = ref $args eq 'ARRAY' ? @$args : $args;
          }
          if ($not) {
              $not = 0;
              @args = $object->new->$method(@args);
              $method = "not";
          }
  
          my @return = $object->$method(@args);
          return @return if $method eq 'in';
      }
      $object;
  }
  
  
  =head1 METHODS
  
  =over
  
  =item C<new>
  
  A constructor.  You need not invoke C<new> manually unless you wish
  to, as each of the rule-making methods will auto-create a suitable
  object if called as class methods.
  
  =cut
  
  sub new {
      my $referent = shift;
      my $class = ref $referent || $referent;
      bless {
          rules    => [],
          subs     => {},
          iterator => [],
          extras   => {},
          maxdepth => undef,
          mindepth => undef,
      }, $class;
  }
  
  sub _force_object {
      my $object = shift;
      $object = $object->new()
        unless ref $object;
      $object;
  }
  
  =back
  
  =head2 Matching Rules
  
  =over
  
  =item C<name( @patterns )>
  
  Specifies names that should match.  May be globs or regular
  expressions.
  
   $set->name( '*.mp3', '*.ogg' ); # mp3s or oggs
   $set->name( qr/\.(mp3|ogg)$/ ); # the same as a regex
   $set->name( 'foo.bar' );        # just things named foo.bar
  
  =cut
  
  sub _flatten {
      my @flat;
      while (@_) {
          my $item = shift;
          ref $item eq 'ARRAY' ? push @_, @{ $item } : push @flat, $item;
      }
      return @flat;
  }
  
  sub name {
      my $self = _force_object shift;
      my @names = map { ref $_ eq "Regexp" ? $_ : glob_to_regex $_ } _flatten( @_ );
  
      push @{ $self->{rules} }, {
          rule => 'name',
          code => join( ' || ', map { "m($_)" } @names ),
          args => \@_,
      };
  
      $self;
  }
  
  =item -X tests
  
  Synonyms are provided for each of the -X tests. See L<perlfunc/-X> for
  details.  None of these methods take arguments.
  
    Test | Method               Test |  Method
   ------|-------------        ------|----------------
     -r  |  readable             -R  |  r_readable
     -w  |  writeable            -W  |  r_writeable
     -w  |  writable             -W  |  r_writable
     -x  |  executable           -X  |  r_executable
     -o  |  owned                -O  |  r_owned
         |                           |
     -e  |  exists               -f  |  file
     -z  |  empty                -d  |  directory
     -s  |  nonempty             -l  |  symlink
         |                       -p  |  fifo
     -u  |  setuid               -S  |  socket
     -g  |  setgid               -b  |  block
     -k  |  sticky               -c  |  character
         |                       -t  |  tty
     -M  |  modified                 |
     -A  |  accessed             -T  |  ascii
     -C  |  changed              -B  |  binary
  
  Though some tests are fairly meaningless as binary flags (C<modified>,
  C<accessed>, C<changed>), they have been included for completeness.
  
   # find nonempty files
   $rule->file,
        ->nonempty;
  
  =cut
  
  use vars qw( %X_tests );
  %X_tests = (
      -r  =>  readable           =>  -R  =>  r_readable      =>
      -w  =>  writeable          =>  -W  =>  r_writeable     =>
      -w  =>  writable           =>  -W  =>  r_writable      =>
      -x  =>  executable         =>  -X  =>  r_executable    =>
      -o  =>  owned              =>  -O  =>  r_owned         =>
  
      -e  =>  exists             =>  -f  =>  file            =>
      -z  =>  empty              =>  -d  =>  directory       =>
      -s  =>  nonempty           =>  -l  =>  symlink         =>
                                 =>  -p  =>  fifo            =>
      -u  =>  setuid             =>  -S  =>  socket          =>
      -g  =>  setgid             =>  -b  =>  block           =>
      -k  =>  sticky             =>  -c  =>  character       =>
                                 =>  -t  =>  tty             =>
      -M  =>  modified                                       =>
      -A  =>  accessed           =>  -T  =>  ascii           =>
      -C  =>  changed            =>  -B  =>  binary          =>
     );
  
  for my $test (keys %X_tests) {
      my $sub = eval 'sub () {
          my $self = _force_object shift;
          push @{ $self->{rules} }, {
              code => "' . $test . ' \$_",
              rule => "'.$X_tests{$test}.'",
          };
          $self;
      } ';
      no strict 'refs';
      *{ $X_tests{$test} } = $sub;
  }
  
  
  =item stat tests
  
  The following C<stat> based methods are provided: C<dev>, C<ino>,
  C<mode>, C<nlink>, C<uid>, C<gid>, C<rdev>, C<size>, C<atime>,
  C<mtime>, C<ctime>, C<blksize>, and C<blocks>.  See L<perlfunc/stat>
  for details.
  
  Each of these can take a number of targets, which will follow
  L<Number::Compare> semantics.
  
   $rule->size( 7 );         # exactly 7
   $rule->size( ">7Ki" );    # larger than 7 * 1024 * 1024 bytes
   $rule->size( ">=7" )
        ->size( "<=90" );    # between 7 and 90, inclusive
   $rule->size( 7, 9, 42 );  # 7, 9 or 42
  
  =cut
  
  use vars qw( @stat_tests );
  @stat_tests = qw( dev ino mode nlink uid gid rdev
                    size atime mtime ctime blksize blocks );
  {
      my $i = 0;
      for my $test (@stat_tests) {
          my $index = $i++; # to close over
          my $sub = sub {
              my $self = _force_object shift;
  
              my @tests = map { Number::Compare->parse_to_perl($_) } @_;
  
              push @{ $self->{rules} }, {
                  rule => $test,
                  args => \@_,
                  code => 'do { my $val = (stat $_)['.$index.'] || 0;'.
                    join ('||', map { "(\$val $_)" } @tests ).' }',
              };
              $self;
          };
          no strict 'refs';
          *$test = $sub;
      }
  }
  
  =item C<any( @rules )>
  
  =item C<or( @rules )>
  
  Allows shortcircuiting boolean evaluation as an alternative to the
  default and-like nature of combined rules.  C<any> and C<or> are
  interchangeable.
  
   # find avis, movs, things over 200M and empty files
   $rule->any( File::Find::Rule->name( '*.avi', '*.mov' ),
               File::Find::Rule->size( '>200M' ),
               File::Find::Rule->file->empty,
             );
  
  =cut
  
  sub any {
      my $self = _force_object shift;
      # compile all the subrules to code fragments
      push @{ $self->{rules} }, {
          rule => "any",
          code => '(' . join( ' || ', map '( ' . $_->_compile . ' )', @_ ). ')',
          args => \@_,
      };
      
      # merge all the subs hashes of the kids into ourself
      %{ $self->{subs} } = map { %{ $_->{subs} } } $self, @_;
      $self;
  }
  
  *or = \&any;
  
  =item C<none( @rules )>
  
  =item C<not( @rules )>
  
  Negates a rule.  (The inverse of C<any>.)  C<none> and C<not> are
  interchangeable.
  
    # files that aren't 8.3 safe
    $rule->file
         ->not( $rule->new->name( qr/^[^.]{1,8}(\.[^.]{0,3})?$/ ) );
  
  =cut
  
  sub not {
      my $self = _force_object shift;
  
      push @{ $self->{rules} }, {
          rule => 'not',
          args => \@_,
          code => '(' . join ( ' && ', map { "!(". $_->_compile . ")" } @_ ) . ")",
      };
      
      # merge all the subs hashes into us
      %{ $self->{subs} } = map { %{ $_->{subs} } } $self, @_;
      $self;
  }
  
  *none = \&not;
  
  =item C<prune>
  
  Traverse no further.  This rule always matches.
  
  =cut
  
  sub prune () {
      my $self = _force_object shift;
  
      push @{ $self->{rules} },
        {
         rule => 'prune',
         code => '$File::Find::prune = 1'
        };
      $self;
  }
  
  =item C<discard>
  
  Don't keep this file.  This rule always matches.
  
  =cut
  
  sub discard () {
      my $self = _force_object shift;
  
      push @{ $self->{rules} }, {
          rule => 'discard',
          code => '$discarded = 1',
      };
      $self;
  }
  
  =item C<exec( \&subroutine( $shortname, $path, $fullname ) )>
  
  Allows user-defined rules.  Your subroutine will be invoked with C<$_>
  set to the current short name, and with parameters of the name, the
  path you're in, and the full relative filename.
  
  Return a true value if your rule matched.
  
   # get things with long names
   $rules->exec( sub { length > 20 } );
  
  =cut
  
  sub exec {
      my $self = _force_object shift;
      my $code = shift;
  
      push @{ $self->{rules} }, {
          rule => 'exec',
          code => $code,
      };
      $self;
  }
  
  =item C<grep( @specifiers )>
  
  Opens a file and tests it each line at a time.
  
  For each line it evaluates each of the specifiers, stopping at the
  first successful match.  A specifier may be a regular expression or a
  subroutine.  The subroutine will be invoked with the same parameters
  as an ->exec subroutine.
  
  It is possible to provide a set of negative specifiers by enclosing
  them in anonymous arrays.  Should a negative specifier match the
  iteration is aborted and the clause is failed.  For example:
  
   $rule->grep( qr/^#!.*\bperl/, [ sub { 1 } ] );
  
  Is a passing clause if the first line of a file looks like a perl
  shebang line.
  
  =cut
  
  sub grep {
      my $self = _force_object shift;
      my @pattern = map {
          ref $_
            ? ref $_ eq 'ARRAY'
              ? map { [ ( ref $_ ? $_ : qr/$_/ ) => 0 ] } @$_
              : [ $_ => 1 ]
            : [ qr/$_/ => 1 ]
        } @_;
  
      $self->exec( sub {
          local *FILE;
          open FILE, $_ or return;
          local ($_, $.);
          while (<FILE>) {
              for my $p (@pattern) {
                  my ($rule, $ret) = @$p;
                  return $ret
                    if ref $rule eq 'Regexp'
                      ? /$rule/
                        : $rule->(@_);
              }
          }
          return;
      } );
  }
  
  =item C<maxdepth( $level )>
  
  Descend at most C<$level> (a non-negative integer) levels of directories
  below the starting point.
  
  May be invoked many times per rule, but only the most recent value is
  used.
  
  =item C<mindepth( $level )>
  
  Do not apply any tests at levels less than C<$level> (a non-negative
  integer).
  
  =item C<extras( \%extras )>
  
  Specifies extra values to pass through to C<File::File::find> as part
  of the options hash.
  
  For example this allows you to specify following of symlinks like so:
  
   my $rule = File::Find::Rule->extras({ follow => 1 });
  
  May be invoked many times per rule, but only the most recent value is
  used.
  
  =cut
  
  for my $setter (qw( maxdepth mindepth extras )) {
      my $sub = sub {
          my $self = _force_object shift;
          $self->{$setter} = shift;
          $self;
      };
      no strict 'refs';
      *$setter = $sub;
  }
  
  
  =item C<relative>
  
  Trim the leading portion of any path found
  
  =cut
  
  sub relative () {
      my $self = _force_object shift;
      $self->{relative} = 1;
      $self;
  }
  
  =item C<not_*>
  
  Negated version of the rule.  An effective shortand related to ! in
  the procedural interface.
  
   $foo->not_name('*.pl');
  
   $foo->not( $foo->new->name('*.pl' ) );
  
  =cut
  
  sub DESTROY {}
  sub AUTOLOAD {
      our $AUTOLOAD;
      $AUTOLOAD =~ /::not_([^:]*)$/
        or croak "Can't locate method $AUTOLOAD";
      my $method = $1;
  
      my $sub = sub {
          my $self = _force_object shift;
          $self->not( $self->new->$method(@_) );
      };
      {
          no strict 'refs';
          *$AUTOLOAD = $sub;
      }
      &$sub;
  }
  
  =back
  
  =head2 Query Methods
  
  =over
  
  =item C<in( @directories )>
  
  Evaluates the rule, returns a list of paths to matching files and
  directories.
  
  =cut
  
  sub in {
      my $self = _force_object shift;
  
      my @found;
      my $fragment = $self->_compile;
      my %subs = %{ $self->{subs} };
  
      warn "relative mode handed multiple paths - that's a bit silly\n"
        if $self->{relative} && @_ > 1;
  
      my $topdir;
      my $code = 'sub {
          (my $path = $File::Find::name)  =~ s#^(?:\./+)+##;
          my @args = ($_, $File::Find::dir, $path);
          my $maxdepth = $self->{maxdepth};
          my $mindepth = $self->{mindepth};
          my $relative = $self->{relative};
  
          # figure out the relative path and depth
          my $relpath = $File::Find::name;
          $relpath =~ s{^\Q$topdir\E/?}{};
          my $depth = scalar File::Spec->splitdir($relpath);
          #print "name: \'$File::Find::name\' ";
          #print "relpath: \'$relpath\' depth: $depth relative: $relative\n";
  
          defined $maxdepth && $depth >= $maxdepth
             and $File::Find::prune = 1;
  
          defined $mindepth && $depth < $mindepth
             and return;
  
          #print "Testing \'$_\'\n";
  
          my $discarded;
          return unless ' . $fragment . ';
          return if $discarded;
          if ($relative) {
              push @found, $relpath if $relpath ne "";
          }
          else {
              push @found, $path;
          }
      }';
  
      #use Data::Dumper;
      #print Dumper \%subs;
      #warn "Compiled sub: '$code'\n";
  
      my $sub = eval "$code" or die "compile error '$code' $@";
      for my $path (@_) {
          # $topdir is used for relative and maxdepth
          $topdir = $path;
          # slice off the trailing slash if there is one (the
          # maxdepth/mindepth code is fussy)
          $topdir =~ s{/?$}{}
            unless $topdir eq '/';
          $self->_call_find( { %{ $self->{extras} }, wanted => $sub }, $path );
      }
  
      return @found;
  }
  
  sub _call_find {
      my $self = shift;
      File::Find::find( @_ );
  }
  
  sub _compile {
      my $self = shift;
  
      return '1' unless @{ $self->{rules} };
      my $code = join " && ", map {
          if (ref $_->{code}) {
              my $key = "$_->{code}";
              $self->{subs}{$key} = $_->{code};
              "\$subs{'$key'}->(\@args) # $_->{rule}\n";
          }
          else {
              "( $_->{code} ) # $_->{rule}\n";
          }
      } @{ $self->{rules} };
  
      #warn $code;
      return $code;
  }
  
  =item C<start( @directories )>
  
  Starts a find across the specified directories.  Matching items may
  then be queried using L</match>.  This allows you to use a rule as an
  iterator.
  
   my $rule = File::Find::Rule->file->name("*.jpeg")->start( "/web" );
   while ( defined ( my $image = $rule->match ) ) {
       ...
   }
  
  =cut
  
  sub start {
      my $self = _force_object shift;
  
      $self->{iterator} = [ $self->in( @_ ) ];
      $self;
  }
  
  =item C<match>
  
  Returns the next file which matches, false if there are no more.
  
  =cut
  
  sub match {
      my $self = _force_object shift;
  
      return shift @{ $self->{iterator} };
  }
  
  1;
  
  __END__
  
  =back
  
  =head2 Extensions
  
  Extension modules are available from CPAN in the File::Find::Rule
  namespace.  In order to use these extensions either use them directly:
  
   use File::Find::Rule::ImageSize;
   use File::Find::Rule::MMagic;
  
   # now your rules can use the clauses supplied by the ImageSize and
   # MMagic extension
  
  or, specify that File::Find::Rule should load them for you:
  
   use File::Find::Rule qw( :ImageSize :MMagic );
  
  For notes on implementing your own extensions, consult
  L<File::Find::Rule::Extending>
  
  =head2 Further examples
  
  =over
  
  =item Finding perl scripts
  
   my $finder = File::Find::Rule->or
    (
     File::Find::Rule->name( '*.pl' ),
     File::Find::Rule->exec(
                            sub {
                                if (open my $fh, $_) {
                                    my $shebang = <$fh>;
                                    close $fh;
                                    return $shebang =~ /^#!.*\bperl/;
                                }
                                return 0;
                            } ),
    );
  
  Based upon this message http://use.perl.org/comments.pl?sid=7052&cid=10842
  
  =item ignore CVS directories
  
   my $rule = File::Find::Rule->new;
   $rule->or($rule->new
                  ->directory
                  ->name('CVS')
                  ->prune
                  ->discard,
             $rule->new);
  
  Note here the use of a null rule.  Null rules match anything they see,
  so the effect is to match (and discard) directories called 'CVS' or to
  match anything.
  
  =back
  
  =head1 TWO FOR THE PRICE OF ONE
  
  File::Find::Rule also gives you a procedural interface.  This is
  documented in L<File::Find::Rule::Procedural>
  
  =head1 EXPORTS
  
  L</find>, L</rule>
  
  =head1 TAINT MODE INTERACTION
  
  As of 0.32 File::Find::Rule doesn't capture the current working directory in
  a taint-unsafe manner.  File::Find itself still does operations that the taint
  system will flag as insecure but you can use the L</extras> feature to ask
  L<File::Find> to internally C<untaint> file paths with a regex like so:
  
      my $rule = File::Find::Rule->extras({ untaint => 1 });
      
  Please consult L<File::Find>'s documentation for C<untaint>,
  C<untaint_pattern>, and C<untaint_skip> for more information.
  
  =head1 BUGS
  
  The code makes use of the C<our> keyword and as such requires perl version
  5.6.0 or newer.
  
  Currently it isn't possible to remove a clause from a rule object.  If
  this becomes a significant issue it will be addressed.
  
  =head1 AUTHOR
  
  Richard Clamp <richardc@unixbeard.net> with input gained from this
  use.perl discussion: http://use.perl.org/~richardc/journal/6467
  
  Additional proofreading and input provided by Kake, Greg McCarroll,
  and Andy Lester andy@petdance.com.
  
  =head1 COPYRIGHT
  
  Copyright (C) 2002, 2003, 2004, 2006, 2009 Richard Clamp.  All Rights Reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<File::Find>, L<Text::Glob>, L<Number::Compare>, find(1)
  
  If you want to know about the procedural interface, see
  L<File::Find::Rule::Procedural>, and if you have an idea for a neat
  extension L<File::Find::Rule::Extending>
  
  =cut
  
  Implementation notes:
  
  $self->rules is an array of hashrefs.  it may be a code fragment or a call
  to a subroutine.
  
  Anonymous subroutines are stored in the $self->subs hashref keyed on the
  stringfied version of the coderef.
  
  When one File::Find::Rule object is combined with another, such as in the any
  and not operations, this entire hash is merged.
  
  The _compile method walks the rules element and simply glues the code
  fragments together so they can be compiled into an anyonymous File::Find
  match sub for speed
  
  
  [*] There's probably a win to be made with the current model in making
  stat calls use C<_>.  For
  
    find( file => size => "> 20M" => size => "< 400M" );
  
  up to 3 stats will happen for each candidate.  Adding a priming _
  would be a bit blind if the first operation was C< name => 'foo' >,
  since that can be tested by a single regex.  Simply checking what the
  next type of operation doesn't work since any arbritary exec sub may
  or may not stat.  Potentially worse, they could stat something else
  like so:
  
    # extract from the worlds stupidest make(1)
    find( exec => sub { my $f = $_; $f =~ s/\.c$/.o/ && !-e $f } );
  
  Maybe the best way is to treat C<_> as invalid after calling an exec,
  and doc that C<_> will only be meaningful after stat and -X tests if
  they're wanted in exec blocks.
FILE_FIND_RULE

$fatpacked{"File/Find/Upwards.pm"} = <<'FILE_FIND_UPWARDS';
  use 5.008;
  use strict;
  use warnings;
  
  package File::Find::Upwards;
  BEGIN {
    $File::Find::Upwards::VERSION = '1.102030';
  }
  # ABSTRACT: Look for a file in the current directory and upwards
  use Path::Class;
  use Attribute::Memoize;
  use Exporter qw(import);
  our @EXPORT = qw(file_find_upwards find_containing_dir_upwards);
  
  sub file_find_upwards : Memoize {
      my @wanted_files = @_;
      my $dir         = dir('.')->absolute;
      my %seen;
      my $result;    # left undef as we'll return undef if we didn't find it
    LOOP: {
          do {
              last if $seen{$dir}++;
              for my $wanted_file (@wanted_files) {
                  my $file = $dir->file($wanted_file);
                  if (-e $file) {
                      $result = $file->absolute;
                      last LOOP;
                  }
              }
          } while ($dir = $dir->parent);
      }
      $result;
  }
  
  sub find_containing_dir_upwards : Memoize {
      my @wanted_files = @_;
      my $dir         = dir('.')->absolute;
      my %seen;
      do {
          last if $seen{$dir}++;
          for my $wanted_file (@wanted_files) {
              return $dir if -e $dir->file($wanted_file);
          }
      } while ($dir = $dir->parent);
      undef;
  }
  1;
  
  
  __END__
  =pod
  
  =head1 NAME
  
  File::Find::Upwards - Look for a file in the current directory and upwards
  
  =head1 VERSION
  
  version 1.102030
  
  =head1 SYNOPSIS
  
      use File::Find::Upwards qw(file_find_upwards);
  
      my $filename = file_find_upwards('myconfig.yaml');
      if ($filename) { rand() }
  
  =head1 DESCRIPTION
  
  Provides functions that can find a file in the current or a parent directory.
  
  =head1 FUNCTIONS
  
  =head2 file_find_upwards
  
  Takes a list of filenames and looks for these file in the current directory.
  If there is no such file, it traverses up the directory hierarchy until it
  finds at least one of those files or until it reaches the topmost directory.
  If one of these files is found, the full path to the file is returned. The
  filenames are checked in the order they are given, so if several of those
  files exist, the first one will be returned. If none of the given files are
  found, undef is returned.
  
  The result is memoized, so repeated calls to the function with the same list
  of filenames will return the result of the first call for that filename.
  
  This function is exported automatically.
  
  =head2 find_containing_dir_upwards
  
  Like C<file_find_upwards()>, but reports the directory that contains one of
  the given filenames. A C<Path::Class::Dir> object is returned.
  
  This function is exported automatically.
  
  =head1 INSTALLATION
  
  See perlmodinstall for information and options on installing Perl modules.
  
  =head1 BUGS AND LIMITATIONS
  
  No bugs have been reported.
  
  Please report any bugs or feature requests through the web interface at
  L<http://rt.cpan.org>.
  
  =head1 AVAILABILITY
  
  The latest version of this module is available from the Comprehensive Perl
  Archive Network (CPAN). Visit L<http://www.perl.com/CPAN/> to find a CPAN
  site near you, or see
  L<http://search.cpan.org/dist/File-Find-Upwards/>.
  
  The development version lives at
  L<http://github.com/hanekomu/File-Find-Upwards/>.
  Instead of sending patches, please fork this project using the standard git
  and github infrastructure.
  
  =head1 AUTHOR
  
  Marcel Gruenauer <marcel@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2008 by Marcel Gruenauer.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
FILE_FIND_UPWARDS

$fatpacked{"File/Which.pm"} = <<'FILE_WHICH';
  package File::Which;
  
  use 5.004;
  use strict;
  use Exporter   ();
  use File::Spec ();
  
  use vars qw{$VERSION @ISA @EXPORT @EXPORT_OK};
  BEGIN {
  	$VERSION   = '1.09';
  	@ISA       = 'Exporter';
  	@EXPORT    = 'which';
  	@EXPORT_OK = 'where';
  }
  
  use constant IS_VMS => ($^O eq 'VMS');
  use constant IS_MAC => ($^O eq 'MacOS');
  use constant IS_DOS => ($^O eq 'MSWin32' or $^O eq 'dos' or $^O eq 'os2');
  
  # For Win32 systems, stores the extensions used for
  # executable files
  # For others, the empty string is used
  # because 'perl' . '' eq 'perl' => easier
  my @PATHEXT = ('');
  if ( IS_DOS ) {
  	# WinNT. PATHEXT might be set on Cygwin, but not used.
  	if ( $ENV{PATHEXT} ) {
  		push @PATHEXT, split ';', $ENV{PATHEXT};
  	} else {
  		# Win9X or other: doesn't have PATHEXT, so needs hardcoded.
  		push @PATHEXT, qw{.com .exe .bat};
  	}
  } elsif ( IS_VMS ) {
  	push @PATHEXT, qw{.exe .com};
  }
  
  sub which {
  	my ($exec) = @_;
  
  	return undef unless $exec;
  
  	my $all = wantarray;
  	my @results = ();
  
  	# check for aliases first
  	if ( IS_VMS ) {
  		my $symbol = `SHOW SYMBOL $exec`;
  		chomp($symbol);
  		unless ( $? ) {
  			return $symbol unless $all;
  			push @results, $symbol;
  		}
  	}
  	if ( IS_MAC ) {
  		my @aliases = split /\,/, $ENV{Aliases};
  		foreach my $alias ( @aliases ) {
  			# This has not been tested!!
  			# PPT which says MPW-Perl cannot resolve `Alias $alias`,
  			# let's just hope it's fixed
  			if ( lc($alias) eq lc($exec) ) {
  				chomp(my $file = `Alias $alias`);
  				last unless $file;  # if it failed, just go on the normal way
  				return $file unless $all;
  				push @results, $file;
  				# we can stop this loop as if it finds more aliases matching,
  				# it'll just be the same result anyway
  				last;
  			}
  		}
  	}
  
  	my @path = File::Spec->path;
  	if ( IS_DOS or IS_VMS or IS_MAC ) {
  		unshift @path, File::Spec->curdir;
  	}
  
  	foreach my $base ( map { File::Spec->catfile($_, $exec) } @path ) {
  		for my $ext ( @PATHEXT ) {
  			my $file = $base.$ext;
  
  			# We don't want dirs (as they are -x)
  			next if -d $file;
  
  			if (
  				# Executable, normal case
  				-x _
  				or (
  					# MacOS doesn't mark as executable so we check -e
  					IS_MAC
  					||
  					(
  						IS_DOS
  						and
  						grep {
  							$file =~ /$_\z/i
  						} @PATHEXT[1..$#PATHEXT]
  					)
  					# DOSish systems don't pass -x on
  					# non-exe/bat/com files. so we check -e.
  					# However, we don't want to pass -e on files
  					# that aren't in PATHEXT, like README.
  					and -e _
  				)
  			) {
  				return $file unless $all;
  				push @results, $file;
  			}
  		}
  	}
  
  	if ( $all ) {
  		return @results;
  	} else {
  		return undef;
  	}
  }
  
  sub where {
  	# force wantarray
  	my @res = which($_[0]);
  	return @res;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  File::Which - Portable implementation of the `which' utility
  
  =head1 SYNOPSIS
  
    use File::Which;                  # exports which()
    use File::Which qw(which where);  # exports which() and where()
    
    my $exe_path = which('perldoc');
    
    my @paths = where('perl');
    - Or -
    my @paths = which('perl'); # an array forces search for all of them
  
  =head1 DESCRIPTION
  
  C<File::Which> was created to be able to get the paths to executable programs
  on systems under which the `which' program wasn't implemented in the shell.
  
  C<File::Which> searches the directories of the user's C<PATH> (as returned by
  C<File::Spec-E<gt>path()>), looking for executable files having the name
  specified as a parameter to C<which()>. Under Win32 systems, which do not have a
  notion of directly executable files, but uses special extensions such as C<.exe>
  and C<.bat> to identify them, C<File::Which> takes extra steps to assure that
  you will find the correct file (so for example, you might be searching for
  C<perl>, it'll try F<perl.exe>, F<perl.bat>, etc.)
  
  =head1 Steps Used on Win32, DOS, OS2 and VMS
  
  =head2 Windows NT
  
  Windows NT has a special environment variable called C<PATHEXT>, which is used
  by the shell to look for executable files. Usually, it will contain a list in
  the form C<.EXE;.BAT;.COM;.JS;.VBS> etc. If C<File::Which> finds such an
  environment variable, it parses the list and uses it as the different
  extensions.
  
  =head2 Windows 9x and other ancient Win/DOS/OS2
  
  This set of operating systems don't have the C<PATHEXT> variable, and usually
  you will find executable files there with the extensions C<.exe>, C<.bat> and
  (less likely) C<.com>. C<File::Which> uses this hardcoded list if it's running
  under Win32 but does not find a C<PATHEXT> variable.
  
  =head2 VMS
  
  Same case as Windows 9x: uses C<.exe> and C<.com> (in that order).
  
  =head1 Functions
  
  =head2 which($short_exe_name)
  
  Exported by default.
  
  C<$short_exe_name> is the name used in the shell to call the program (for
  example, C<perl>).
  
  If it finds an executable with the name you specified, C<which()> will return
  the absolute path leading to this executable (for example, F</usr/bin/perl> or
  F<C:\Perl\Bin\perl.exe>).
  
  If it does I<not> find the executable, it returns C<undef>.
  
  If C<which()> is called in list context, it will return I<all> the
  matches.
  
  =head2 where($short_exe_name)
  
  Not exported by default.
  
  Same as C<which($short_exe_name)> in array context. Same as the
  C<`where'> utility, will return an array containing all the path names
  matching C<$short_exe_name>.
  
  =head1 BUGS AND CAVEATS
  
  Not tested on VMS or MacOS, although there is platform specific code
  for those. Anyone who haves a second would be very kind to send me a
  report of how it went.
  
  File::Spec adds the current directory to the front of PATH if on
  Win32, VMS or MacOS. I have no knowledge of those so don't know if the
  current directory is searced first or not. Could someone please tell
  me?
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker at
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=File-Which>
  
  For other issues, contact the maintainer.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Per Einar Ellefsen E<lt>pereinar@cpan.orgE<gt>
  
  Originated in F<modperl-2.0/lib/Apache/Build.pm>. Changed for use in DocSet
  (for the mod_perl site) and Win32-awareness by me, with slight modifications
  by Stas Bekman, then extracted to create C<File::Which>.
  
  Version 0.04 had some significant platform-related changes, taken from
  the Perl Power Tools C<`which'> implementation by Abigail with
  enhancements from Peter Prymmer. See
  L<http://www.perl.com/language/ppt/src/which/index.html> for more
  information.
  
  =head1 COPYRIGHT
  
  Copyright 2002 Per Einar Ellefsen.
  
  Some parts copyright 2009 Adam Kennedy.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<File::Spec>, L<which(1)>, Perl Power Tools:
  L<http://www.perl.com/language/ppt/index.html>.
  
  =cut
FILE_WHICH

$fatpacked{"IO/String.pm"} = <<'IO_STRING';
  package IO::String;
  
  # Copyright 1998-2005 Gisle Aas.
  #
  # This library is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
  
  require 5.005_03;
  use strict;
  use vars qw($VERSION $DEBUG $IO_CONSTANTS);
  $VERSION = "1.08";  # $Date: 2005/12/05 12:00:47 $
  
  use Symbol ();
  
  sub new
  {
      my $class = shift;
      my $self = bless Symbol::gensym(), ref($class) || $class;
      tie *$self, $self;
      $self->open(@_);
      return $self;
  }
  
  sub open
  {
      my $self = shift;
      return $self->new(@_) unless ref($self);
  
      if (@_) {
  	my $bufref = ref($_[0]) ? $_[0] : \$_[0];
  	$$bufref = "" unless defined $$bufref;
  	*$self->{buf} = $bufref;
      }
      else {
  	my $buf = "";
  	*$self->{buf} = \$buf;
      }
      *$self->{pos} = 0;
      *$self->{lno} = 0;
      return $self;
  }
  
  sub pad
  {
      my $self = shift;
      my $old = *$self->{pad};
      *$self->{pad} = substr($_[0], 0, 1) if @_;
      return "\0" unless defined($old) && length($old);
      return $old;
  }
  
  sub dump
  {
      require Data::Dumper;
      my $self = shift;
      print Data::Dumper->Dump([$self], ['*self']);
      print Data::Dumper->Dump([*$self{HASH}], ['$self{HASH}']);
      return;
  }
  
  sub TIEHANDLE
  {
      print "TIEHANDLE @_\n" if $DEBUG;
      return $_[0] if ref($_[0]);
      my $class = shift;
      my $self = bless Symbol::gensym(), $class;
      $self->open(@_);
      return $self;
  }
  
  sub DESTROY
  {
      print "DESTROY @_\n" if $DEBUG;
  }
  
  sub close
  {
      my $self = shift;
      delete *$self->{buf};
      delete *$self->{pos};
      delete *$self->{lno};
      undef *$self if $] eq "5.008";  # workaround for some bug
      return 1;
  }
  
  sub opened
  {
      my $self = shift;
      return defined *$self->{buf};
  }
  
  sub binmode
  {
      my $self = shift;
      return 1 unless @_;
      # XXX don't know much about layers yet :-(
      return 0;
  }
  
  sub getc
  {
      my $self = shift;
      my $buf;
      return $buf if $self->read($buf, 1);
      return undef;
  }
  
  sub ungetc
  {
      my $self = shift;
      $self->setpos($self->getpos() - 1);
      return 1;
  }
  
  sub eof
  {
      my $self = shift;
      return length(${*$self->{buf}}) <= *$self->{pos};
  }
  
  sub print
  {
      my $self = shift;
      if (defined $\) {
  	if (defined $,) {
  	    $self->write(join($,, @_).$\);
  	}
  	else {
  	    $self->write(join("",@_).$\);
  	}
      }
      else {
  	if (defined $,) {
  	    $self->write(join($,, @_));
  	}
  	else {
  	    $self->write(join("",@_));
  	}
      }
      return 1;
  }
  *printflush = \*print;
  
  sub printf
  {
      my $self = shift;
      print "PRINTF(@_)\n" if $DEBUG;
      my $fmt = shift;
      $self->write(sprintf($fmt, @_));
      return 1;
  }
  
  
  my($SEEK_SET, $SEEK_CUR, $SEEK_END);
  
  sub _init_seek_constants
  {
      if ($IO_CONSTANTS) {
  	require IO::Handle;
  	$SEEK_SET = &IO::Handle::SEEK_SET;
  	$SEEK_CUR = &IO::Handle::SEEK_CUR;
  	$SEEK_END = &IO::Handle::SEEK_END;
      }
      else {
  	$SEEK_SET = 0;
  	$SEEK_CUR = 1;
  	$SEEK_END = 2;
      }
  }
  
  
  sub seek
  {
      my($self,$off,$whence) = @_;
      my $buf = *$self->{buf} || return 0;
      my $len = length($$buf);
      my $pos = *$self->{pos};
  
      _init_seek_constants() unless defined $SEEK_SET;
  
      if    ($whence == $SEEK_SET) { $pos = $off }
      elsif ($whence == $SEEK_CUR) { $pos += $off }
      elsif ($whence == $SEEK_END) { $pos = $len + $off }
      else                         { die "Bad whence ($whence)" }
      print "SEEK(POS=$pos,OFF=$off,LEN=$len)\n" if $DEBUG;
  
      $pos = 0 if $pos < 0;
      $self->truncate($pos) if $pos > $len;  # extend file
      *$self->{pos} = $pos;
      return 1;
  }
  
  sub pos
  {
      my $self = shift;
      my $old = *$self->{pos};
      if (@_) {
  	my $pos = shift || 0;
  	my $buf = *$self->{buf};
  	my $len = $buf ? length($$buf) : 0;
  	$pos = $len if $pos > $len;
  	*$self->{pos} = $pos;
      }
      return $old;
  }
  
  sub getpos { shift->pos; }
  
  *sysseek = \&seek;
  *setpos  = \&pos;
  *tell    = \&getpos;
  
  
  
  sub getline
  {
      my $self = shift;
      my $buf  = *$self->{buf} || return;
      my $len  = length($$buf);
      my $pos  = *$self->{pos};
      return if $pos >= $len;
  
      unless (defined $/) {  # slurp
  	*$self->{pos} = $len;
  	return substr($$buf, $pos);
      }
  
      unless (length $/) {  # paragraph mode
  	# XXX slow&lazy implementation using getc()
  	my $para = "";
  	my $eol = 0;
  	my $c;
  	while (defined($c = $self->getc)) {
  	    if ($c eq "\n") {
  		$eol++;
  		next if $eol > 2;
  	    }
  	    elsif ($eol > 1) {
  		$self->ungetc($c);
  		last;
  	    }
  	    else {
  		$eol = 0;
  	    }
  	    $para .= $c;
  	}
  	return $para;   # XXX wantarray
      }
  
      my $idx = index($$buf,$/,$pos);
      if ($idx < 0) {
  	# return rest of it
  	*$self->{pos} = $len;
  	$. = ++ *$self->{lno};
  	return substr($$buf, $pos);
      }
      $len = $idx - $pos + length($/);
      *$self->{pos} += $len;
      $. = ++ *$self->{lno};
      return substr($$buf, $pos, $len);
  }
  
  sub getlines
  {
      die "getlines() called in scalar context\n" unless wantarray;
      my $self = shift;
      my($line, @lines);
      push(@lines, $line) while defined($line = $self->getline);
      return @lines;
  }
  
  sub READLINE
  {
      goto &getlines if wantarray;
      goto &getline;
  }
  
  sub input_line_number
  {
      my $self = shift;
      my $old = *$self->{lno};
      *$self->{lno} = shift if @_;
      return $old;
  }
  
  sub truncate
  {
      my $self = shift;
      my $len = shift || 0;
      my $buf = *$self->{buf};
      if (length($$buf) >= $len) {
  	substr($$buf, $len) = '';
  	*$self->{pos} = $len if $len < *$self->{pos};
      }
      else {
  	$$buf .= ($self->pad x ($len - length($$buf)));
      }
      return 1;
  }
  
  sub read
  {
      my $self = shift;
      my $buf = *$self->{buf};
      return undef unless $buf;
  
      my $pos = *$self->{pos};
      my $rem = length($$buf) - $pos;
      my $len = $_[1];
      $len = $rem if $len > $rem;
      return undef if $len < 0;
      if (@_ > 2) { # read offset
  	substr($_[0],$_[2]) = substr($$buf, $pos, $len);
      }
      else {
  	$_[0] = substr($$buf, $pos, $len);
      }
      *$self->{pos} += $len;
      return $len;
  }
  
  sub write
  {
      my $self = shift;
      my $buf = *$self->{buf};
      return unless $buf;
  
      my $pos = *$self->{pos};
      my $slen = length($_[0]);
      my $len = $slen;
      my $off = 0;
      if (@_ > 1) {
  	$len = $_[1] if $_[1] < $len;
  	if (@_ > 2) {
  	    $off = $_[2] || 0;
  	    die "Offset outside string" if $off > $slen;
  	    if ($off < 0) {
  		$off += $slen;
  		die "Offset outside string" if $off < 0;
  	    }
  	    my $rem = $slen - $off;
  	    $len = $rem if $rem < $len;
  	}
      }
      substr($$buf, $pos, $len) = substr($_[0], $off, $len);
      *$self->{pos} += $len;
      return $len;
  }
  
  *sysread = \&read;
  *syswrite = \&write;
  
  sub stat
  {
      my $self = shift;
      return unless $self->opened;
      return 1 unless wantarray;
      my $len = length ${*$self->{buf}};
  
      return (
       undef, undef,  # dev, ino
       0666,          # filemode
       1,             # links
       $>,            # user id
       $),            # group id
       undef,         # device id
       $len,          # size
       undef,         # atime
       undef,         # mtime
       undef,         # ctime
       512,           # blksize
       int(($len+511)/512)  # blocks
      );
  }
  
  sub FILENO {
      return undef;   # XXX perlfunc says this means the file is closed
  }
  
  sub blocking {
      my $self = shift;
      my $old = *$self->{blocking} || 0;
      *$self->{blocking} = shift if @_;
      return $old;
  }
  
  my $notmuch = sub { return };
  
  *fileno    = $notmuch;
  *error     = $notmuch;
  *clearerr  = $notmuch; 
  *sync      = $notmuch;
  *flush     = $notmuch;
  *setbuf    = $notmuch;
  *setvbuf   = $notmuch;
  
  *untaint   = $notmuch;
  *autoflush = $notmuch;
  *fcntl     = $notmuch;
  *ioctl     = $notmuch;
  
  *GETC   = \&getc;
  *PRINT  = \&print;
  *PRINTF = \&printf;
  *READ   = \&read;
  *WRITE  = \&write;
  *SEEK   = \&seek;
  *TELL   = \&getpos;
  *EOF    = \&eof;
  *CLOSE  = \&close;
  *BINMODE = \&binmode;
  
  
  sub string_ref
  {
      my $self = shift;
      return *$self->{buf};
  }
  *sref = \&string_ref;
  
  1;
  
  __END__
  
  =head1 NAME
  
  IO::String - Emulate file interface for in-core strings
  
  =head1 SYNOPSIS
  
   use IO::String;
   $io = IO::String->new;
   $io = IO::String->new($var);
   tie *IO, 'IO::String';
  
   # read data
   <$io>;
   $io->getline;
   read($io, $buf, 100);
  
   # write data
   print $io "string\n";
   $io->print(@data);
   syswrite($io, $buf, 100);
  
   select $io;
   printf "Some text %s\n", $str;
  
   # seek
   $pos = $io->getpos;
   $io->setpos(0);        # rewind
   $io->seek(-30, -1);
   seek($io, 0, 0);
  
  =head1 DESCRIPTION
  
  The C<IO::String> module provides the C<IO::File> interface for in-core
  strings.  An C<IO::String> object can be attached to a string, and
  makes it possible to use the normal file operations for reading or
  writing data, as well as for seeking to various locations of the string.
  This is useful when you want to use a library module that only
  provides an interface to file handles on data that you have in a string
  variable.
  
  Note that perl-5.8 and better has built-in support for "in memory"
  files, which are set up by passing a reference instead of a filename
  to the open() call. The reason for using this module is that it
  makes the code backwards compatible with older versions of Perl.
  
  The C<IO::String> module provides an interface compatible with
  C<IO::File> as distributed with F<IO-1.20>, but the following methods
  are not available: new_from_fd, fdopen, format_write,
  format_page_number, format_lines_per_page, format_lines_left,
  format_name, format_top_name.
  
  The following methods are specific to the C<IO::String> class:
  
  =over 4
  
  =item $io = IO::String->new
  
  =item $io = IO::String->new( $string )
  
  The constructor returns a newly-created C<IO::String> object.  It
  takes an optional argument, which is the string to read from or write
  into.  If no $string argument is given, then an internal buffer
  (initially empty) is allocated.
  
  The C<IO::String> object returned is tied to itself.  This means
  that you can use most Perl I/O built-ins on it too: readline, <>, getc,
  print, printf, syswrite, sysread, close.
  
  =item $io->open
  
  =item $io->open( $string )
  
  Attaches an existing IO::String object to some other $string, or
  allocates a new internal buffer (if no argument is given).  The
  position is reset to 0.
  
  =item $io->string_ref
  
  Returns a reference to the string that is attached to
  the C<IO::String> object.  Most useful when you let the C<IO::String>
  create an internal buffer to write into.
  
  =item $io->pad
  
  =item $io->pad( $char )
  
  Specifies the padding to use if
  the string is extended by either the seek() or truncate() methods.  It
  is a single character and defaults to "\0".
  
  =item $io->pos
  
  =item $io->pos( $newpos )
  
  Yet another interface for reading and setting the current read/write
  position within the string (the normal getpos/setpos/tell/seek
  methods are also available).  The pos() method always returns the
  old position, and if you pass it an argument it sets the new
  position.
  
  There is (deliberately) a difference between the setpos() and seek()
  methods in that seek() extends the string (with the specified
  padding) if you go to a location past the end, whereas setpos()
  just snaps back to the end.  If truncate() is used to extend the string,
  then it works as seek().
  
  =back
  
  =head1 BUGS
  
  In Perl versions < 5.6, the TIEHANDLE interface was incomplete.
  If you use such a Perl, then seek(), tell(), eof(), fileno(), binmode() will
  not do anything on an C<IO::String> handle.  See L<perltie> for
  details.
  
  =head1 SEE ALSO
  
  L<IO::File>, L<IO::Stringy>, L<perlfunc/open>
  
  =head1 COPYRIGHT
  
  Copyright 1998-2005 Gisle Aas.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  =cut
IO_STRING

$fatpacked{"Number/Compare.pm"} = <<'NUMBER_COMPARE';
  # $Id: Compare.pm 846 2002-10-25 15:46:01Z richardc $
  package Number::Compare;
  use strict;
  use Carp qw(croak);
  use vars qw/$VERSION/;
  $VERSION = '0.01';
  
  sub new  {
      my $referent = shift;
      my $class = ref $referent || $referent;
      my $expr = $class->parse_to_perl( shift );
  
      bless eval "sub { \$_[0] $expr }", $class;
  }
  
  sub parse_to_perl {
      shift;
      my $test = shift;
  
      $test =~ m{^
                 ([<>]=?)?   # comparison
                 (.*?)       # value
                 ([kmg]i?)?  # magnitude
                $}ix
         or croak "don't understand '$test' as a test";
  
      my $comparison = $1 || '==';
      my $target     = $2;
      my $magnitude  = $3;
      $target *=           1000 if lc $magnitude eq 'k';
      $target *=           1024 if lc $magnitude eq 'ki';
      $target *=        1000000 if lc $magnitude eq 'm';
      $target *=      1024*1024 if lc $magnitude eq 'mi';
      $target *=     1000000000 if lc $magnitude eq 'g';
      $target *= 1024*1024*1024 if lc $magnitude eq 'gi';
  
      return "$comparison $target";
  }
  
  sub test { $_[0]->( $_[1] ) }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Number::Compare - numeric comparisons
  
  =head1 SYNOPSIS
  
   Number::Compare->new(">1Ki")->test(1025); # is 1025 > 1024
  
   my $c = Number::Compare->new(">1M");
   $c->(1_200_000);                          # slightly terser invocation
  
  =head1 DESCRIPTION
  
  Number::Compare compiles a simple comparison to an anonymous
  subroutine, which you can call with a value to be tested again.
  
  Now this would be very pointless, if Number::Compare didn't understand
  magnitudes.
  
  The target value may use magnitudes of kilobytes (C<k>, C<ki>),
  megabytes (C<m>, C<mi>), or gigabytes (C<g>, C<gi>).  Those suffixed
  with an C<i> use the appropriate 2**n version in accordance with the
  IEC standard: http://physics.nist.gov/cuu/Units/binary.html
  
  =head1 METHODS
  
  =head2 ->new( $test )
  
  Returns a new object that compares the specified test.
  
  =head2 ->test( $value )
  
  A longhanded version of $compare->( $value ).  Predates blessed
  subroutine reference implementation.
  
  =head2 ->parse_to_perl( $test )
  
  Returns a perl code fragment equivalent to the test.
  
  =head1 AUTHOR
  
  Richard Clamp <richardc@unixbeard.net>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2002 Richard Clamp.  All Rights Reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  http://physics.nist.gov/cuu/Units/binary.html
  
  =cut
NUMBER_COMPARE

$fatpacked{"Path/Class.pm"} = <<'PATH_CLASS';
  package Path::Class;
  BEGIN {
    $Path::Class::VERSION = '0.23';
  }
  
  @ISA = qw(Exporter);
  @EXPORT    = qw(file dir);
  @EXPORT_OK = qw(file dir foreign_file foreign_dir);
  
  use strict;
  use Exporter;
  use Path::Class::File;
  use Path::Class::Dir;
  
  sub file { Path::Class::File->new(@_) }
  sub dir  { Path::Class::Dir ->new(@_) }
  sub foreign_file { Path::Class::File->new_foreign(@_) }
  sub foreign_dir  { Path::Class::Dir ->new_foreign(@_) }
  
  
  1;
  __END__
  
  =head1 NAME
  
  Path::Class - Cross-platform path specification manipulation
  
  =head1 VERSION
  
  version 0.23
  
  =head1 SYNOPSIS
  
    use Path::Class;
    
    my $dir  = dir('foo', 'bar');       # Path::Class::Dir object
    my $file = file('bob', 'file.txt'); # Path::Class::File object
    
    # Stringifies to 'foo/bar' on Unix, 'foo\bar' on Windows, etc.
    print "dir: $dir\n";
    
    # Stringifies to 'bob/file.txt' on Unix, 'bob\file.txt' on Windows
    print "file: $file\n";
    
    my $subdir  = $dir->subdir('baz');  # foo/bar/baz
    my $parent  = $subdir->parent;      # foo/bar
    my $parent2 = $parent->parent;      # foo
    
    my $dir2 = $file->dir;              # bob
  
    # Work with foreign paths
    use Path::Class qw(foreign_file foreign_dir);
    my $file = foreign_file('Mac', ':foo:file.txt');
    print $file->dir;                   # :foo:
    print $file->as_foreign('Win32');   # foo\file.txt
    
    # Interact with the underlying filesystem:
    
    # $dir_handle is an IO::Dir object
    my $dir_handle = $dir->open or die "Can't read $dir: $!";
    
    # $file_handle is an IO::File object
    my $file_handle = $file->open($mode) or die "Can't read $file: $!";
  
  =head1 DESCRIPTION
  
  C<Path::Class> is a module for manipulation of file and directory
  specifications (strings describing their locations, like
  C<'/home/ken/foo.txt'> or C<'C:\Windows\Foo.txt'>) in a cross-platform
  manner.  It supports pretty much every platform Perl runs on,
  including Unix, Windows, Mac, VMS, Epoc, Cygwin, OS/2, and NetWare.
  
  The well-known module C<File::Spec> also provides this service, but
  it's sort of awkward to use well, so people sometimes avoid it, or use
  it in a way that won't actually work properly on platforms
  significantly different than the ones they've tested their code on.
  
  In fact, C<Path::Class> uses C<File::Spec> internally, wrapping all
  the unsightly details so you can concentrate on your application code.
  Whereas C<File::Spec> provides functions for some common path
  manipulations, C<Path::Class> provides an object-oriented model of the
  world of path specifications and their underlying semantics.
  C<File::Spec> doesn't create any objects, and its classes represent
  the different ways in which paths must be manipulated on various
  platforms (not a very intuitive concept).  C<Path::Class> creates
  objects representing files and directories, and provides methods that
  relate them to each other.  For instance, the following C<File::Spec>
  code:
  
   my $absolute = File::Spec->file_name_is_absolute(
                    File::Spec->catfile( @dirs, $file )
                  );
  
  can be written using C<Path::Class> as
  
   my $absolute = Path::Class::File->new( @dirs, $file )->is_absolute;
  
  or even as 
  
   my $absolute = file( @dirs, $file )->is_absolute;
  
  Similar readability improvements should happen all over the place when
  using C<Path::Class>.
  
  Using C<Path::Class> can help solve real problems in your code too -
  for instance, how many people actually take the "volume" (like C<C:>
  on Windows) into account when writing C<File::Spec>-using code?  I
  thought not.  But if you use C<Path::Class>, your file and directory objects
  will know what volumes they refer to and do the right thing.
  
  The guts of the C<Path::Class> code live in the C<Path::Class::File>
  and C<Path::Class::Dir> modules, so please see those
  modules' documentation for more details about how to use them.
  
  =head2 EXPORT
  
  The following functions are exported by default.
  
  =over 4
  
  =item file
  
  A synonym for C<< Path::Class::File->new >>.
  
  =item dir
  
  A synonym for C<< Path::Class::Dir->new >>.
  
  =back
  
  If you would like to prevent their export, you may explicitly pass an
  empty list to perl's C<use>, i.e. C<use Path::Class ()>.
  
  The following are exported only on demand.
  
  =over 4
  
  =item foreign_file
  
  A synonym for C<< Path::Class::File->new_foreign >>.
  
  =item foreign_dir
  
  A synonym for C<< Path::Class::Dir->new_foreign >>.
  
  =back
  
  =head1 Notes on Cross-Platform Compatibility
  
  Although it is much easier to write cross-platform-friendly code with
  this module than with C<File::Spec>, there are still some issues to be
  aware of.
  
  =over 4
  
  =item *
  
  Some platforms, notably VMS and some older versions of DOS (I think),
  all filenames must have an extension.  Thus if you create a file
  called F<foo/bar> and then ask for a list of files in the directory
  F<foo>, you may find a file called F<bar.> instead of the F<bar> you
  were expecting.  Thus it might be a good idea to use an extension in
  the first place.
  
  =back
  
  =head1 AUTHOR
  
  Ken Williams, KWILLIAMS@cpan.org
  
  =head1 COPYRIGHT
  
  Copyright (c) Ken Williams.  All rights reserved.
  
  This library is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
  
  
  =head1 SEE ALSO
  
  Path::Class::Dir, Path::Class::File, File::Spec
  
  =cut
PATH_CLASS

$fatpacked{"Path/Class/Dir.pm"} = <<'PATH_CLASS_DIR';
  package Path::Class::Dir;
  BEGIN {
    $Path::Class::Dir::VERSION = '0.23';
  }
  
  use strict;
  use Path::Class::File;
  use Carp();
  use base qw(Path::Class::Entity);
  
  use IO::Dir ();
  use File::Path ();
  
  # updir & curdir on the local machine, for screening them out in
  # children().  Note that they don't respect 'foreign' semantics.
  my $Updir  = __PACKAGE__->_spec->updir;
  my $Curdir = __PACKAGE__->_spec->curdir;
  
  sub new {
    my $self = shift->SUPER::new();
  
    # If the only arg is undef, it's probably a mistake.  Without this
    # special case here, we'd return the root directory, which is a
    # lousy thing to do to someone when they made a mistake.  Return
    # undef instead.
    return if @_==1 && !defined($_[0]);
  
    my $s = $self->_spec;
    
    my $first = (@_ == 0     ? $s->curdir :
  	       $_[0] eq '' ? (shift, $s->rootdir) :
  	       shift()
  	      );
    
    ($self->{volume}, my $dirs) = $s->splitpath( $s->canonpath($first) , 1);
    $self->{dirs} = [$s->splitdir($s->catdir($dirs, @_))];
  
    return $self;
  }
  
  sub file_class { "Path::Class::File" }
  
  sub is_dir { 1 }
  
  sub as_foreign {
    my ($self, $type) = @_;
  
    my $foreign = do {
      local $self->{file_spec_class} = $self->_spec_class($type);
      $self->SUPER::new;
    };
    
    # Clone internal structure
    $foreign->{volume} = $self->{volume};
    my ($u, $fu) = ($self->_spec->updir, $foreign->_spec->updir);
    $foreign->{dirs} = [ map {$_ eq $u ? $fu : $_} @{$self->{dirs}}];
    return $foreign;
  }
  
  sub stringify {
    my $self = shift;
    my $s = $self->_spec;
    return $s->catpath($self->{volume},
  		     $s->catdir(@{$self->{dirs}}),
  		     '');
  }
  
  sub volume { shift()->{volume} }
  
  sub file {
    local $Path::Class::Foreign = $_[0]->{file_spec_class} if $_[0]->{file_spec_class};
    return $_[0]->file_class->new(@_);
  }
  
  sub basename { shift()->{dirs}[-1] }
  
  sub dir_list {
    my $self = shift;
    my $d = $self->{dirs};
    return @$d unless @_;
    
    my $offset = shift;
    if ($offset < 0) { $offset = $#$d + $offset + 1 }
    
    return wantarray ? @$d[$offset .. $#$d] : $d->[$offset] unless @_;
    
    my $length = shift;
    if ($length < 0) { $length = $#$d + $length + 1 - $offset }
    return @$d[$offset .. $length + $offset - 1];
  }
  
  sub subdir {
    my $self = shift;
    return $self->new($self, @_);
  }
  
  sub parent {
    my $self = shift;
    my $dirs = $self->{dirs};
    my ($curdir, $updir) = ($self->_spec->curdir, $self->_spec->updir);
  
    if ($self->is_absolute) {
      my $parent = $self->new($self);
      pop @{$parent->{dirs}};
      return $parent;
  
    } elsif ($self eq $curdir) {
      return $self->new($updir);
  
    } elsif (!grep {$_ ne $updir} @$dirs) {  # All updirs
      return $self->new($self, $updir); # Add one more
  
    } elsif (@$dirs == 1) {
      return $self->new($curdir);
  
    } else {
      my $parent = $self->new($self);
      pop @{$parent->{dirs}};
      return $parent;
    }
  }
  
  sub relative {
    # File::Spec->abs2rel before version 3.13 returned the empty string
    # when the two paths were equal - work around it here.
    my $self = shift;
    my $rel = $self->_spec->abs2rel($self->stringify, @_);
    return $self->new( length $rel ? $rel : $self->_spec->curdir );
  }
  
  sub open  { IO::Dir->new(@_) }
  sub mkpath { File::Path::mkpath(shift()->stringify, @_) }
  sub rmtree { File::Path::rmtree(shift()->stringify, @_) }
  
  sub remove {
    rmdir( shift() );
  }
  
  sub recurse {
    my $self = shift;
    my %opts = (preorder => 1, depthfirst => 0, @_);
    
    my $callback = $opts{callback}
      or Carp::croak( "Must provide a 'callback' parameter to recurse()" );
    
    my @queue = ($self);
    
    my $visit_entry;
    my $visit_dir = 
      $opts{depthfirst} && $opts{preorder}
      ? sub {
        my $dir = shift;
        $callback->($dir);
        unshift @queue, $dir->children;
      }
      : $opts{preorder}
      ? sub {
        my $dir = shift;
        $callback->($dir);
        push @queue, $dir->children;
      }
      : sub {
        my $dir = shift;
        $visit_entry->($_) foreach $dir->children;
        $callback->($dir);
      };
    
    $visit_entry = sub {
      my $entry = shift;
      if ($entry->is_dir) { $visit_dir->($entry) } # Will call $callback
      else { $callback->($entry) }
    };
    
    while (@queue) {
      $visit_entry->( shift @queue );
    }
  }
  
  sub children {
    my ($self, %opts) = @_;
    
    my $dh = $self->open or Carp::croak( "Can't open directory $self: $!" );
    
    my @out;
    while (defined(my $entry = $dh->read)) {
      next if !$opts{all} && $self->_is_local_dot_dir($entry);
      next if ($opts{no_hidden} && $entry =~ /^\./);
      push @out, $self->file($entry);
      $out[-1] = $self->subdir($entry) if -d $out[-1];
    }
    return @out;
  }
  
  sub _is_local_dot_dir {
    my $self = shift;
    my $dir  = shift;
  
    return ($dir eq $Updir or $dir eq $Curdir);
  }
  
  sub next {
    my $self = shift;
    unless ($self->{dh}) {
      $self->{dh} = $self->open or Carp::croak( "Can't open directory $self: $!" );
    }
    
    my $next = $self->{dh}->read;
    unless (defined $next) {
      delete $self->{dh};
      return undef;
    }
    
    # Figure out whether it's a file or directory
    my $file = $self->file($next);
    $file = $self->subdir($next) if -d $file;
    return $file;
  }
  
  sub subsumes {
    my ($self, $other) = @_;
    die "No second entity given to subsumes()" unless $other;
    
    $other = $self->new($other) unless UNIVERSAL::isa($other, __PACKAGE__);
    $other = $other->dir unless $other->is_dir;
    
    if ($self->is_absolute) {
      $other = $other->absolute;
    } elsif ($other->is_absolute) {
      $self = $self->absolute;
    }
  
    $self = $self->cleanup;
    $other = $other->cleanup;
  
    if ($self->volume) {
      return 0 unless $other->volume eq $self->volume;
    }
  
    # The root dir subsumes everything (but ignore the volume because
    # we've already checked that)
    return 1 if "@{$self->{dirs}}" eq "@{$self->new('')->{dirs}}";
    
    my $i = 0;
    while ($i <= $#{ $self->{dirs} }) {
      return 0 if $i > $#{ $other->{dirs} };
      return 0 if $self->{dirs}[$i] ne $other->{dirs}[$i];
      $i++;
    }
    return 1;
  }
  
  sub contains {
    my ($self, $other) = @_;
    return !!(-d $self and (-e $other or -l $other) and $self->subsumes($other));
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Path::Class::Dir - Objects representing directories
  
  =head1 VERSION
  
  version 0.23
  
  =head1 SYNOPSIS
  
    use Path::Class qw(dir);  # Export a short constructor
    
    my $dir = dir('foo', 'bar');       # Path::Class::Dir object
    my $dir = Path::Class::Dir->new('foo', 'bar');  # Same thing
    
    # Stringifies to 'foo/bar' on Unix, 'foo\bar' on Windows, etc.
    print "dir: $dir\n";
    
    if ($dir->is_absolute) { ... }
    if ($dir->is_relative) { ... }
    
    my $v = $dir->volume; # Could be 'C:' on Windows, empty string
                          # on Unix, 'Macintosh HD:' on Mac OS
    
    $dir->cleanup; # Perform logical cleanup of pathname
    $dir->resolve; # Perform physical cleanup of pathname
    
    my $file = $dir->file('file.txt'); # A file in this directory
    my $subdir = $dir->subdir('george'); # A subdirectory
    my $parent = $dir->parent; # The parent directory, 'foo'
    
    my $abs = $dir->absolute; # Transform to absolute path
    my $rel = $abs->relative; # Transform to relative path
    my $rel = $abs->relative('/foo'); # Relative to /foo
    
    print $dir->as_foreign('Mac');   # :foo:bar:
    print $dir->as_foreign('Win32'); #  foo\bar
  
    # Iterate with IO::Dir methods:
    my $handle = $dir->open;
    while (my $file = $handle->read) {
      $file = $dir->file($file);  # Turn into Path::Class::File object
      ...
    }
    
    # Iterate with Path::Class methods:
    while (my $file = $dir->next) {
      # $file is a Path::Class::File or Path::Class::Dir object
      ...
    }
  
  
  =head1 DESCRIPTION
  
  The C<Path::Class::Dir> class contains functionality for manipulating
  directory names in a cross-platform way.
  
  =head1 METHODS
  
  =over 4
  
  =item $dir = Path::Class::Dir->new( <dir1>, <dir2>, ... )
  
  =item $dir = dir( <dir1>, <dir2>, ... )
  
  Creates a new C<Path::Class::Dir> object and returns it.  The
  arguments specify names of directories which will be joined to create
  a single directory object.  A volume may also be specified as the
  first argument, or as part of the first argument.  You can use
  platform-neutral syntax:
  
    my $dir = dir( 'foo', 'bar', 'baz' );
  
  or platform-native syntax:
  
    my $dir = dir( 'foo/bar/baz' );
  
  or a mixture of the two:
  
    my $dir = dir( 'foo/bar', 'baz' );
  
  All three of the above examples create relative paths.  To create an
  absolute path, either use the platform native syntax for doing so:
  
    my $dir = dir( '/var/tmp' );
  
  or use an empty string as the first argument:
  
    my $dir = dir( '', 'var', 'tmp' );
  
  If the second form seems awkward, that's somewhat intentional - paths
  like C</var/tmp> or C<\Windows> aren't cross-platform concepts in the
  first place (many non-Unix platforms don't have a notion of a "root
  directory"), so they probably shouldn't appear in your code if you're
  trying to be cross-platform.  The first form is perfectly natural,
  because paths like this may come from config files, user input, or
  whatever.
  
  As a special case, since it doesn't otherwise mean anything useful and
  it's convenient to define this way, C<< Path::Class::Dir->new() >> (or
  C<dir()>) refers to the current directory (C<< File::Spec->curdir >>).
  To get the current directory as an absolute path, do C<<
  dir()->absolute >>.
  
  Finally, as another special case C<dir(undef)> will return undef,
  since that's usually an accident on the part of the caller, and
  returning the root directory would be a nasty surprise just asking for
  trouble a few lines later.
  
  =item $dir->stringify
  
  This method is called internally when a C<Path::Class::Dir> object is
  used in a string context, so the following are equivalent:
  
    $string = $dir->stringify;
    $string = "$dir";
  
  =item $dir->volume
  
  Returns the volume (e.g. C<C:> on Windows, C<Macintosh HD:> on Mac OS,
  etc.) of the directory object, if any.  Otherwise, returns the empty
  string.
  
  =item $dir->is_dir
  
  Returns a boolean value indicating whether this object represents a
  directory.  Not surprisingly, C<Path::Class::File> objects always
  return false, and C<Path::Class::Dir> objects always return true.
  
  =item $dir->is_absolute
  
  Returns true or false depending on whether the directory refers to an
  absolute path specifier (like C</usr/local> or C<\Windows>).
  
  =item $dir->is_relative
  
  Returns true or false depending on whether the directory refers to a
  relative path specifier (like C<lib/foo> or C<./dir>).
  
  =item $dir->cleanup
  
  Performs a logical cleanup of the file path.  For instance:
  
    my $dir = dir('/foo//baz/./foo')->cleanup;
    # $dir now represents '/foo/baz/foo';
  
  =item $dir->resolve
  
  Performs a physical cleanup of the file path.  For instance:
  
    my $dir = dir('/foo//baz/../foo')->resolve;
    # $dir now represents '/foo/foo', assuming no symlinks
  
  This actually consults the filesystem to verify the validity of the
  path.
  
  =item $file = $dir->file( <dir1>, <dir2>, ..., <file> )
  
  Returns a C<Path::Class::File> object representing an entry in C<$dir>
  or one of its subdirectories.  Internally, this just calls C<<
  Path::Class::File->new( @_ ) >>.
  
  =item $subdir = $dir->subdir( <dir1>, <dir2>, ... )
  
  Returns a new C<Path::Class::Dir> object representing a subdirectory
  of C<$dir>.
  
  =item $parent = $dir->parent
  
  Returns the parent directory of C<$dir>.  Note that this is the
  I<logical> parent, not necessarily the physical parent.  It really
  means we just chop off entries from the end of the directory list
  until we cain't chop no more.  If the directory is relative, we start
  using the relative forms of parent directories.
  
  The following code demonstrates the behavior on absolute and relative
  directories:
  
    $dir = dir('/foo/bar');
    for (1..6) {
      print "Absolute: $dir\n";
      $dir = $dir->parent;
    }
    
    $dir = dir('foo/bar');
    for (1..6) {
      print "Relative: $dir\n";
      $dir = $dir->parent;
    }
    
    ########### Output on Unix ################
    Absolute: /foo/bar
    Absolute: /foo
    Absolute: /
    Absolute: /
    Absolute: /
    Absolute: /
    Relative: foo/bar
    Relative: foo
    Relative: .
    Relative: ..
    Relative: ../..
    Relative: ../../..
  
  =item @list = $dir->children
  
  Returns a list of C<Path::Class::File> and/or C<Path::Class::Dir>
  objects listed in this directory, or in scalar context the number of
  such objects.  Obviously, it is necessary for C<$dir> to
  exist and be readable in order to find its children.
  
  Note that the children are returned as subdirectories of C<$dir>,
  i.e. the children of F<foo> will be F<foo/bar> and F<foo/baz>, not
  F<bar> and F<baz>.
  
  Ordinarily C<children()> will not include the I<self> and I<parent>
  entries C<.> and C<..> (or their equivalents on non-Unix systems),
  because that's like I'm-my-own-grandpa business.  If you do want all
  directory entries including these special ones, pass a true value for
  the C<all> parameter:
  
    @c = $dir->children(); # Just the children
    @c = $dir->children(all => 1); # All entries
  
  In addition, there's a C<no_hidden> parameter that will exclude all
  normally "hidden" entries - on Unix this means excluding all entries
  that begin with a dot (C<.>):
  
    @c = $dir->children(no_hidden => 1); # Just normally-visible entries
  
  
  =item $abs = $dir->absolute
  
  Returns a C<Path::Class::Dir> object representing C<$dir> as an
  absolute path.  An optional argument, given as either a string or a
  C<Path::Class::Dir> object, specifies the directory to use as the base
  of relativity - otherwise the current working directory will be used.
  
  =item $rel = $dir->relative
  
  Returns a C<Path::Class::Dir> object representing C<$dir> as a
  relative path.  An optional argument, given as either a string or a
  C<Path::Class::Dir> object, specifies the directory to use as the base
  of relativity - otherwise the current working directory will be used.
  
  =item $boolean = $dir->subsumes($other)
  
  Returns true if this directory spec subsumes the other spec, and false
  otherwise.  Think of "subsumes" as "contains", but we only look at the
  I<specs>, not whether C<$dir> actually contains C<$other> on the
  filesystem.
  
  The C<$other> argument may be a C<Path::Class::Dir> object, a
  C<Path::Class::File> object, or a string.  In the latter case, we
  assume it's a directory.
  
    # Examples:
    dir('foo/bar' )->subsumes(dir('foo/bar/baz'))  # True
    dir('/foo/bar')->subsumes(dir('/foo/bar/baz')) # True
    dir('foo/bar' )->subsumes(dir('bar/baz'))      # False
    dir('/foo/bar')->subsumes(dir('foo/bar'))      # False
  
  
  =item $boolean = $dir->contains($other)
  
  Returns true if this directory actually contains C<$other> on the
  filesystem.  C<$other> doesn't have to be a direct child of C<$dir>,
  it just has to be subsumed.
  
  =item $foreign = $dir->as_foreign($type)
  
  Returns a C<Path::Class::Dir> object representing C<$dir> as it would
  be specified on a system of type C<$type>.  Known types include
  C<Unix>, C<Win32>, C<Mac>, C<VMS>, and C<OS2>, i.e. anything for which
  there is a subclass of C<File::Spec>.
  
  Any generated objects (subdirectories, files, parents, etc.) will also
  retain this type.
  
  =item $foreign = Path::Class::Dir->new_foreign($type, @args)
  
  Returns a C<Path::Class::Dir> object representing C<$dir> as it would
  be specified on a system of type C<$type>.  Known types include
  C<Unix>, C<Win32>, C<Mac>, C<VMS>, and C<OS2>, i.e. anything for which
  there is a subclass of C<File::Spec>.
  
  The arguments in C<@args> are the same as they would be specified in
  C<new()>.
  
  =item @list = $dir->dir_list([OFFSET, [LENGTH]])
  
  Returns the list of strings internally representing this directory
  structure.  Each successive member of the list is understood to be an
  entry in its predecessor's directory list.  By contract, C<<
  Path::Class->new( $dir->dir_list ) >> should be equivalent to C<$dir>.
  
  The semantics of this method are similar to Perl's C<splice> or
  C<substr> functions; they return C<LENGTH> elements starting at
  C<OFFSET>.  If C<LENGTH> is omitted, returns all the elements starting
  at C<OFFSET> up to the end of the list.  If C<LENGTH> is negative,
  returns the elements from C<OFFSET> onward except for C<-LENGTH>
  elements at the end.  If C<OFFSET> is negative, it counts backward
  C<OFFSET> elements from the end of the list.  If C<OFFSET> and
  C<LENGTH> are both omitted, the entire list is returned.
  
  In a scalar context, C<dir_list()> with no arguments returns the
  number of entries in the directory list; C<dir_list(OFFSET)> returns
  the single element at that offset; C<dir_list(OFFSET, LENGTH)> returns
  the final element that would have been returned in a list context.
  
  =item $fh = $dir->open()
  
  Passes C<$dir> to C<< IO::Dir->open >> and returns the result as an
  C<IO::Dir> object.  If the opening fails, C<undef> is returned and
  C<$!> is set.
  
  =item $dir->mkpath($verbose, $mode)
  
  Passes all arguments, including C<$dir>, to C<< File::Path::mkpath()
  >> and returns the result (a list of all directories created).
  
  =item $dir->rmtree($verbose, $cautious)
  
  Passes all arguments, including C<$dir>, to C<< File::Path::rmtree()
  >> and returns the result (the number of files successfully deleted).
  
  =item $dir->remove()
  
  Removes the directory, which must be empty.  Returns a boolean value
  indicating whether or not the directory was successfully removed.
  This method is mainly provided for consistency with
  C<Path::Class::File>'s C<remove()> method.
  
  =item $dir_or_file = $dir->next()
  
  A convenient way to iterate through directory contents.  The first
  time C<next()> is called, it will C<open()> the directory and read the
  first item from it, returning the result as a C<Path::Class::Dir> or
  C<Path::Class::File> object (depending, of course, on its actual
  type).  Each subsequent call to C<next()> will simply iterate over the
  directory's contents, until there are no more items in the directory,
  and then the undefined value is returned.  For example, to iterate
  over all the regular files in a directory:
  
    while (my $file = $dir->next) {
      next unless -f $file;
      my $fh = $file->open('r') or die "Can't read $file: $!";
      ...
    }
  
  If an error occurs when opening the directory (for instance, it
  doesn't exist or isn't readable), C<next()> will throw an exception
  with the value of C<$!>.
  
  =item $dir->recurse( callback => sub {...} )
  
  Iterates through this directory and all of its children, and all of
  its children's children, etc., calling the C<callback> subroutine for
  each entry.  This is a lot like what the C<File::Find> module does,
  and of course C<File::Find> will work fine on C<Path::Class> objects,
  but the advantage of the C<recurse()> method is that it will also feed
  your callback routine C<Path::Class> objects rather than just pathname
  strings.
  
  The C<recurse()> method requires a C<callback> parameter specifying
  the subroutine to invoke for each entry.  It will be passed the
  C<Path::Class> object as its first argument.
  
  C<recurse()> also accepts two boolean parameters, C<depthfirst> and
  C<preorder> that control the order of recursion.  The default is a
  preorder, breadth-first search, i.e. C<< depthfirst => 0, preorder => 1 >>.
  At the time of this writing, all combinations of these two parameters
  are supported I<except> C<< depthfirst => 0, preorder => 0 >>.
  
  =item $st = $file->stat()
  
  Invokes C<< File::stat::stat() >> on this directory and returns a
  C<File::stat> object representing the result.
  
  =item $st = $file->lstat()
  
  Same as C<stat()>, but if C<$file> is a symbolic link, C<lstat()>
  stats the link instead of the directory the link points to.
  
  =item $class = $file->file_class()
  
  Returns the class which should be used to create file objects.
  
  Generally overridden whenever this class is subclassed.
  
  =back
  
  =head1 AUTHOR
  
  Ken Williams, kwilliams@cpan.org
  
  =head1 SEE ALSO
  
  Path::Class, Path::Class::File, File::Spec
  
  =cut
PATH_CLASS_DIR

$fatpacked{"Path/Class/Entity.pm"} = <<'PATH_CLASS_ENTITY';
  package Path::Class::Entity;
  BEGIN {
    $Path::Class::Entity::VERSION = '0.23';
  }
  
  use strict;
  use File::Spec;
  use File::stat ();
  use Cwd;
  
  use overload
    (
     q[""] => 'stringify',
     'bool' => 'boolify',
     fallback => 1,
    );
  
  sub new {
    my $from = shift;
    my ($class, $fs_class) = (ref($from)
  			    ? (ref $from, $from->{file_spec_class})
  			    : ($from, $Path::Class::Foreign));
    return bless {file_spec_class => $fs_class}, $class;
  }
  
  sub is_dir { 0 }
  
  sub _spec_class {
    my ($class, $type) = @_;
  
    die "Invalid system type '$type'" unless ($type) = $type =~ /^(\w+)$/;  # Untaint
    my $spec = "File::Spec::$type";
    eval "require $spec; 1" or die $@;
    return $spec;
  }
  
  sub new_foreign {
    my ($class, $type) = (shift, shift);
    local $Path::Class::Foreign = $class->_spec_class($type);
    return $class->new(@_);
  }
  
  sub _spec { (ref($_[0]) && $_[0]->{file_spec_class}) || 'File::Spec' }
  
  sub boolify { 1 }
    
  sub is_absolute { 
    # 5.6.0 has a bug with regexes and stringification that's ticked by
    # file_name_is_absolute().  Help it along with an explicit stringify().
    $_[0]->_spec->file_name_is_absolute($_[0]->stringify) 
  }
  
  sub is_relative { ! $_[0]->is_absolute }
  
  sub cleanup {
    my $self = shift;
    my $cleaned = $self->new( $self->_spec->canonpath($self) );
    %$self = %$cleaned;
    return $self;
  }
  
  sub resolve {
    my $self = shift;
    my $cleaned = $self->new( Cwd::realpath($self->stringify) );
  
    # realpath() always returns absolute path, kind of annoying
    $cleaned = $cleaned->relative if $self->is_relative;
  
    %$self = %$cleaned;
    return $self;
  }
  
  sub absolute {
    my $self = shift;
    return $self if $self->is_absolute;
    return $self->new($self->_spec->rel2abs($self->stringify, @_));
  }
  
  sub relative {
    my $self = shift;
    return $self->new($self->_spec->abs2rel($self->stringify, @_));
  }
  
  sub stat  { File::stat::stat("$_[0]") }
  sub lstat { File::stat::lstat("$_[0]") }
  
  1;
  __END__
  
  =head1 NAME
  
  Path::Class:Entity - Base class for files and directories
  
  =head1 VERSION
  
  version 0.23
  
  =head1 DESCRIPTION
  
  This class is the base class for C<Path::Class::File> and
  C<Path::Class::Dir>, it is not used directly by callers.
  
  =head1 AUTHOR
  
  Ken Williams, kwilliams@cpan.org
  
  =head1 SEE ALSO
  
  Path::Class
  
  =cut
PATH_CLASS_ENTITY

$fatpacked{"Path/Class/File.pm"} = <<'PATH_CLASS_FILE';
  package Path::Class::File;
  BEGIN {
    $Path::Class::File::VERSION = '0.23';
  }
  
  use strict;
  use Path::Class::Dir;
  use base qw(Path::Class::Entity);
  use Carp;
  
  use IO::File ();
  
  sub new {
    my $self = shift->SUPER::new;
    my $file = pop();
    my @dirs = @_;
  
    my ($volume, $dirs, $base) = $self->_spec->splitpath($file);
    
    if (length $dirs) {
      push @dirs, $self->_spec->catpath($volume, $dirs, '');
    }
    
    $self->{dir}  = @dirs ? $self->dir_class->new(@dirs) : undef;
    $self->{file} = $base;
    
    return $self;
  }
  
  sub dir_class { "Path::Class::Dir" }
  
  sub as_foreign {
    my ($self, $type) = @_;
    local $Path::Class::Foreign = $self->_spec_class($type);
    my $foreign = ref($self)->SUPER::new;
    $foreign->{dir} = $self->{dir}->as_foreign($type) if defined $self->{dir};
    $foreign->{file} = $self->{file};
    return $foreign;
  }
  
  sub stringify {
    my $self = shift;
    return $self->{file} unless defined $self->{dir};
    return $self->_spec->catfile($self->{dir}->stringify, $self->{file});
  }
  
  sub dir {
    my $self = shift;
    return $self->{dir} if defined $self->{dir};
    return $self->dir_class->new($self->_spec->curdir);
  }
  BEGIN { *parent = \&dir; }
  
  sub volume {
    my $self = shift;
    return '' unless defined $self->{dir};
    return $self->{dir}->volume;
  }
  
  sub basename { shift->{file} }
  sub open  { IO::File->new(@_) }
  
  sub openr { $_[0]->open('r') or croak "Can't read $_[0]: $!"  }
  sub openw { $_[0]->open('w') or croak "Can't write $_[0]: $!" }
  
  sub touch {
    my $self = shift;
    if (-e $self) {
      my $now = time();
      utime $now, $now, $self;
    } else {
      $self->openw;
    }
  }
  
  sub slurp {
    my ($self, %args) = @_;
    my $iomode = $args{iomode} || 'r';
    my $fh = $self->open($iomode) or croak "Can't read $self: $!";
  
    if ($args{chomped} or $args{chomp}) {
      chomp( my @data = <$fh> );
      return wantarray ? @data : join '', @data;
    }
  
    local $/ unless wantarray;
    return <$fh>;
  }
  
  sub remove {
    my $file = shift->stringify;
    return unlink $file unless -e $file; # Sets $! correctly
    1 while unlink $file;
    return not -e $file;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Path::Class::File - Objects representing files
  
  =head1 VERSION
  
  version 0.23
  
  =head1 SYNOPSIS
  
    use Path::Class qw(file);  # Export a short constructor
    
    my $file = file('foo', 'bar.txt');  # Path::Class::File object
    my $file = Path::Class::File->new('foo', 'bar.txt'); # Same thing
    
    # Stringifies to 'foo/bar.txt' on Unix, 'foo\bar.txt' on Windows, etc.
    print "file: $file\n";
    
    if ($file->is_absolute) { ... }
    if ($file->is_relative) { ... }
    
    my $v = $file->volume; # Could be 'C:' on Windows, empty string
                           # on Unix, 'Macintosh HD:' on Mac OS
    
    $file->cleanup; # Perform logical cleanup of pathname
    $file->resolve; # Perform physical cleanup of pathname
    
    my $dir = $file->dir;  # A Path::Class::Dir object
    
    my $abs = $file->absolute; # Transform to absolute path
    my $rel = $file->relative; # Transform to relative path
  
  =head1 DESCRIPTION
  
  The C<Path::Class::File> class contains functionality for manipulating
  file names in a cross-platform way.
  
  =head1 METHODS
  
  =over 4
  
  =item $file = Path::Class::File->new( <dir1>, <dir2>, ..., <file> )
  
  =item $file = file( <dir1>, <dir2>, ..., <file> )
  
  Creates a new C<Path::Class::File> object and returns it.  The
  arguments specify the path to the file.  Any volume may also be
  specified as the first argument, or as part of the first argument.
  You can use platform-neutral syntax:
  
    my $dir = file( 'foo', 'bar', 'baz.txt' );
  
  or platform-native syntax:
  
    my $dir = dir( 'foo/bar/baz.txt' );
  
  or a mixture of the two:
  
    my $dir = dir( 'foo/bar', 'baz.txt' );
  
  All three of the above examples create relative paths.  To create an
  absolute path, either use the platform native syntax for doing so:
  
    my $dir = dir( '/var/tmp/foo.txt' );
  
  or use an empty string as the first argument:
  
    my $dir = dir( '', 'var', 'tmp', 'foo.txt' );
  
  If the second form seems awkward, that's somewhat intentional - paths
  like C</var/tmp> or C<\Windows> aren't cross-platform concepts in the
  first place, so they probably shouldn't appear in your code if you're
  trying to be cross-platform.  The first form is perfectly fine,
  because paths like this may come from config files, user input, or
  whatever.
  
  =item $file->stringify
  
  This method is called internally when a C<Path::Class::File> object is
  used in a string context, so the following are equivalent:
  
    $string = $file->stringify;
    $string = "$file";
  
  =item $file->volume
  
  Returns the volume (e.g. C<C:> on Windows, C<Macintosh HD:> on Mac OS,
  etc.) of the object, if any.  Otherwise, returns the empty string.
  
  =item $file->basename
  
  Returns the name of the file as a string, without the directory
  portion (if any).
  
  =item $file->is_dir
  
  Returns a boolean value indicating whether this object represents a
  directory.  Not surprisingly, C<Path::Class::File> objects always
  return false, and C<Path::Class::Dir> objects always return true.
  
  =item $file->is_absolute
  
  Returns true or false depending on whether the file refers to an
  absolute path specifier (like C</usr/local/foo.txt> or C<\Windows\Foo.txt>).
  
  =item $file->is_relative
  
  Returns true or false depending on whether the file refers to a
  relative path specifier (like C<lib/foo.txt> or C<.\Foo.txt>).
  
  =item $file->cleanup
  
  Performs a logical cleanup of the file path.  For instance:
  
    my $file = file('/foo//baz/./foo.txt')->cleanup;
    # $file now represents '/foo/baz/foo.txt';
  
  =item $dir->resolve
  
  Performs a physical cleanup of the file path.  For instance:
  
    my $dir = dir('/foo/baz/../foo.txt')->resolve;
    # $dir now represents '/foo/foo.txt', assuming no symlinks
  
  This actually consults the filesystem to verify the validity of the
  path.
  
  =item $dir = $file->dir
  
  Returns a C<Path::Class::Dir> object representing the directory
  containing this file.
  
  =item $dir = $file->parent
  
  A synonym for the C<dir()> method.
  
  =item $abs = $file->absolute
  
  Returns a C<Path::Class::File> object representing C<$file> as an
  absolute path.  An optional argument, given as either a string or a
  C<Path::Class::Dir> object, specifies the directory to use as the base
  of relativity - otherwise the current working directory will be used.
  
  =item $rel = $file->relative
  
  Returns a C<Path::Class::File> object representing C<$file> as a
  relative path.  An optional argument, given as either a string or a
  C<Path::Class::Dir> object, specifies the directory to use as the base
  of relativity - otherwise the current working directory will be used.
  
  =item $foreign = $file->as_foreign($type)
  
  Returns a C<Path::Class::File> object representing C<$file> as it would
  be specified on a system of type C<$type>.  Known types include
  C<Unix>, C<Win32>, C<Mac>, C<VMS>, and C<OS2>, i.e. anything for which
  there is a subclass of C<File::Spec>.
  
  Any generated objects (subdirectories, files, parents, etc.) will also
  retain this type.
  
  =item $foreign = Path::Class::File->new_foreign($type, @args)
  
  Returns a C<Path::Class::File> object representing a file as it would
  be specified on a system of type C<$type>.  Known types include
  C<Unix>, C<Win32>, C<Mac>, C<VMS>, and C<OS2>, i.e. anything for which
  there is a subclass of C<File::Spec>.
  
  The arguments in C<@args> are the same as they would be specified in
  C<new()>.
  
  =item $fh = $file->open($mode, $permissions)
  
  Passes the given arguments, including C<$file>, to C<< IO::File->new >>
  (which in turn calls C<< IO::File->open >> and returns the result
  as an C<IO::File> object.  If the opening
  fails, C<undef> is returned and C<$!> is set.
  
  =item $fh = $file->openr()
  
  A shortcut for
  
   $fh = $file->open('r') or croak "Can't read $file: $!";
  
  =item $fh = $file->openw()
  
  A shortcut for
  
   $fh = $file->open('w') or croak "Can't write $file: $!";
  
  =item $file->touch
  
  Sets the modification and access time of the given file to right now,
  if the file exists.  If it doesn't exist, C<touch()> will I<make> it
  exist, and - YES! - set its modification and access time to now.
  
  =item $file->slurp()
  
  In a scalar context, returns the contents of C<$file> in a string.  In
  a list context, returns the lines of C<$file> (according to how C<$/>
  is set) as a list.  If the file can't be read, this method will throw
  an exception.
  
  If you want C<chomp()> run on each line of the file, pass a true value
  for the C<chomp> or C<chomped> parameters:
  
    my @lines = $file->slurp(chomp => 1);
  
  You may also use the C<iomode> parameter to pass in an IO mode to use
  when opening the file, usually IO layers (though anything accepted by
  the MODE argument of C<open()> is accepted here).  Just make sure it's
  a I<reading> mode.
  
    my @lines = $file->slurp(iomode => ':crlf');
    my $lines = $file->slurp(iomode => '<:encoding(UTF8)');
  
  The default C<iomode> is C<r>.
  
  =item $file->remove()
  
  This method will remove the file in a way that works well on all
  platforms, and returns a boolean value indicating whether or not the
  file was successfully removed.  
  
  C<remove()> is better than simply calling Perl's C<unlink()> function,
  because on some platforms (notably VMS) you actually may need to call
  C<unlink()> several times before all versions of the file are gone -
  the C<remove()> method handles this process for you.
  
  =item $st = $file->stat()
  
  Invokes C<< File::stat::stat() >> on this file and returns a
  C<File::stat> object representing the result.
  
  =item $st = $file->lstat()
  
  Same as C<stat()>, but if C<$file> is a symbolic link, C<lstat()>
  stats the link instead of the file the link points to.
  
  =item $class = $file->dir_class()
  
  Returns the class which should be used to create directory objects.
  
  Generally overridden whenever this class is subclassed.
  
  =back
  
  =head1 AUTHOR
  
  Ken Williams, kwilliams@cpan.org
  
  =head1 SEE ALSO
  
  Path::Class, Path::Class::Dir, File::Spec
  
  =cut
PATH_CLASS_FILE

$fatpacked{"String/RewritePrefix.pm"} = <<'STRING_REWRITEPREFIX';
  use strict;
  use warnings;
  package String::RewritePrefix;
  BEGIN {
    $String::RewritePrefix::VERSION = '0.006';
  }
  use Carp ();
  # ABSTRACT: rewrite strings based on a set of known prefixes
  
  # 0.972 allows \'method_name' form -- rjbs, 2010-10-25
  use Sub::Exporter 0.972 -setup => {
    exports => [ rewrite => \'_new_rewriter' ],
  };
  
  
  sub rewrite {
    my ($self, $arg, @rest) = @_;
    return $self->_new_rewriter(rewrite => { prefixes => $arg })->(@rest);
  }
  
  sub _new_rewriter {
    my ($self, $name, $arg) = @_;
    my $rewrites = $arg->{prefixes} || {};
  
    my @rewrites;
    for my $prefix (sort { length $b <=> length $a } keys %$rewrites) {
      push @rewrites, ($prefix, $rewrites->{$prefix});
    }
  
    return sub {
      my @result;
  
      Carp::cluck("string rewriter invoked in void context")
        unless defined wantarray;
  
      Carp::croak("attempt to rewrite multiple strings outside of list context")
        if @_ > 1 and ! wantarray;
  
      STRING: for my $str (@_) {
        for (my $i = 0; $i < @rewrites; $i += 2) {
          if (index($str, $rewrites[$i]) == 0) {
            if (ref $rewrites[$i+1]) {
              my $rest = substr $str, length($rewrites[$i]);
              my $str  = $rewrites[ $i+1 ]->($rest);
              push @result, (defined $str ? $str : '') . $rest;
            } else {
              push @result, $rewrites[$i+1] . substr $str, length($rewrites[$i]);
            }
            next STRING;
          }
        }
  
        push @result, $str;
      }
      
      return wantarray ? @result : $result[0];
    };
  }
  
  1;
  
  __END__
  =pod
  
  =head1 NAME
  
  String::RewritePrefix - rewrite strings based on a set of known prefixes
  
  =head1 VERSION
  
  version 0.006
  
  =head1 SYNOPSIS
  
    use String::RewritePrefix;
    my @to_load = String::RewritePrefix->rewrite(
      { '' => 'MyApp::', '+' => '' },
      qw(Plugin Mixin Addon +Corporate::Thinger),
    );
  
    # now you have:
    qw(MyApp::Plugin MyApp::Mixin MyApp::Addon Corporate::Thinger)
  
  You can also import a rewrite routine:
  
    use String::RewritePrefix rewrite => {
      -as => 'rewrite_dt_prefix',
      prefixes => { '' => 'MyApp::', '+' => '' },
    };
  
    my @to_load = rewrite_dt_prefix( qw(Plugin Mixin Addon +Corporate::Thinger));
  
    # now you have:
    qw(MyApp::Plugin MyApp::Mixin MyApp::Addon Corporate::Thinger)
  
  =head1 METHODS
  
  =head2 rewrite
  
    String::RewritePrefix->rewrite(\%prefix, @strings);
  
  This rewrites all the given strings using the rules in C<%prefix>.  Its keys
  are known prefixes for which its values will be substituted.  This is performed
  in longest-first order, and only one prefix will be rewritten.
  
  If the prefix value is a coderef, it will be executed with the remaining string
  as its only argument.  The return value will be used as the prefix.
  
  =head1 AUTHOR
  
  Ricardo Signes <rjbs@cpan.org>
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2010 by Ricardo Signes.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
  
STRING_REWRITEPREFIX

$fatpacked{"Sub/Exporter.pm"} = <<'SUB_EXPORTER';
  use 5.006;
  use strict;
  use warnings;
  package Sub::Exporter;
  
  use Carp ();
  use Data::OptList ();
  use Params::Util ();
  use Sub::Install 0.92 ();
  
  =head1 NAME
  
  Sub::Exporter - a sophisticated exporter for custom-built routines
  
  =head1 VERSION
  
  version 0.982
  
  =cut
  
  our $VERSION = '0.982';
  
  =head1 SYNOPSIS
  
  Sub::Exporter must be used in two places.  First, in an exporting module:
  
    # in the exporting module:
    package Text::Tweaker;
    use Sub::Exporter -setup => {
      exports => [
        qw(squish titlecase), # always works the same way
        reformat => \&build_reformatter, # generator to build exported function
        trim     => \&build_trimmer,
        indent   => \&build_indenter,
      ],
      collectors => [ 'defaults' ],
    };
  
  Then, in an importing module:
  
    # in the importing module:
    use Text::Tweaker
      'squish',
      indent   => { margin => 5 },
      reformat => { width => 79, justify => 'full', -as => 'prettify_text' },
      defaults => { eol => 'CRLF' };
  
  With this setup, the importing module ends up with three routines: C<squish>,
  C<indent>, and C<prettify_text>.  The latter two have been built to the
  specifications of the importer -- they are not just copies of the code in the
  exporting package.
  
  =head1 DESCRIPTION
  
  B<ACHTUNG!>  If you're not familiar with Exporter or exporting, read
  L<Sub::Exporter::Tutorial> first!
  
  =head2 Why Generators?
  
  The biggest benefit of Sub::Exporter over existing exporters (including the
  ubiquitous Exporter.pm) is its ability to build new coderefs for export, rather
  than to simply export code identical to that found in the exporting package.
  
  If your module's consumers get a routine that works like this:
  
    use Data::Analyze qw(analyze);
    my $value = analyze($data, $tolerance, $passes);
  
  and they constantly pass only one or two different set of values for the
  non-C<$data> arguments, your code can benefit from Sub::Exporter.  By writing a
  simple generator, you can let them do this, instead:
  
    use Data::Analyze
      analyze => { tolerance => 0.10, passes => 10, -as => analyze10 },
      analyze => { tolerance => 0.15, passes => 50, -as => analyze50 };
  
    my $value = analyze10($data);
  
  The generator for that would look something like this:
  
    sub build_analyzer {
      my ($class, $name, $arg) = @_;
  
      return sub {
        my $data      = shift;
        my $tolerance = shift || $arg->{tolerance}; 
        my $passes    = shift || $arg->{passes}; 
  
        analyze($data, $tolerance, $passes);
      }
    }
  
  Your module's user now has to do less work to benefit from it -- and remember,
  you're often your own user!  Investing in customized subroutines is an
  investment in future laziness.
  
  This also avoids a common form of ugliness seen in many modules: package-level
  configuration.  That is, you might have seen something like the above
  implemented like so:
  
    use Data::Analyze qw(analyze);
    $Data::Analyze::default_tolerance = 0.10;
    $Data::Analyze::default_passes    = 10;
  
  This might save time, until you have multiple modules using Data::Analyze.
  Because there is only one global configuration, they step on each other's toes
  and your code begins to have mysterious errors.
  
  Generators can also allow you to export class methods to be called as
  subroutines:
  
    package Data::Methodical;
    use Sub::Exporter -setup => { exports => { some_method => \&_curry_class } };
  
    sub _curry_class {
      my ($class, $name) = @_;
      sub { $class->$name(@_); };
    }
  
  Because of the way that exporters and Sub::Exporter work, any package that
  inherits from Data::Methodical can inherit its exporter and override its
  C<some_method>.  If a user imports C<some_method> from that package, he'll
  receive a subroutine that calls the method on the subclass, rather than on
  Data::Methodical itself.
  
  =head2 Other Customizations
  
  Building custom routines with generators isn't the only way that Sub::Exporters
  allows the importing code to refine its use of the exported routines.  They may
  also be renamed to avoid naming collisions.
  
  Consider the following code:
  
    # this program determines to which circle of Hell you will be condemned
    use Morality qw(sin virtue); # for calculating viciousness
    use Math::Trig qw(:all);     # for dealing with circles
  
  The programmer has inadvertantly imported two C<sin> routines.  The solution,
  in Exporter.pm-based modules, would be to import only one and then call the
  other by its fully-qualified name.  Alternately, the importer could write a
  routine that did so, or could mess about with typeglobs.
  
  How much easier to write:
  
    # this program determines to which circle of Hell you will be condemned
    use Morality qw(virtue), sin => { -as => 'offense' };
    use Math::Trig -all => { -prefix => 'trig_' };
  
  and to have at one's disposal C<offense> and C<trig_sin> -- not to mention
  C<trig_cos> and C<trig_tan>.
  
  =head1 EXPORTER CONFIGURATION
  
  You can configure an exporter for your package by using Sub::Exporter like so:
  
    package Tools;
    use Sub::Exporter
      -setup => { exports => [ qw(function1 function2 function3) ] };
  
  This is the simplest way to use the exporter, and is basically equivalent to
  this:
  
    package Tools;
    use base qw(Exporter);
    our @EXPORT_OK = qw(function1 function2 function2);
  
  Any basic use of Sub::Exporter will look like this:
  
    package Tools;
    use Sub::Exporter -setup => \%config;
  
  The following keys are valid in C<%config>:
  
    exports - a list of routines to provide for exporting; each routine may be
              followed by generator
    groups  - a list of groups to provide for exporting; each must be followed by
              either (a) a list of exports, possibly with arguments for each
              export, or (b) a generator
  
    collectors - a list of names into which values are collected for use in
                 routine generation; each name may be followed by a validator
  
  In addition to the basic options above, a few more advanced options may be
  passed:
  
    into_level - how far up the caller stack to look for a target (default 0)
    into       - an explicit target (package) into which to export routines
  
  In other words: Sub::Exporter installs a C<import> routine which, when called,
  exports routines to the calling namespace.  The C<into> and C<into_level>
  options change where those exported routines are installed.
  
    generator  - a callback used to produce the code that will be installed
                 default: Sub::Exporter::default_generator
  
    installer  - a callback used to install the code produced by the generator
                 default: Sub::Exporter::default_installer
  
  For information on how these callbacks are used, see the documentation for
  C<L</default_generator>> and C<L</default_installer>>.
  
  =head2 Export Configuration
  
  The C<exports> list may be provided as an array reference or a hash reference.
  The list is processed in such a way that the following are equivalent:
  
    { exports => [ qw(foo bar baz), quux => \&quux_generator ] }
  
    { exports =>
      { foo => undef, bar => undef, baz => undef, quux => \&quux_generator } }
  
  Generators are code that return coderefs.  They are called with four
  parameters:
  
    $class - the class whose exporter has been called (the exporting class)
    $name  - the name of the export for which the routine is being build
   \%arg   - the arguments passed for this export
   \%col   - the collections for this import
  
  Given the configuration in the L</SYNOPSIS>, the following C<use> statement:
  
    use Text::Tweaker
      reformat => { -as => 'make_narrow', width => 33 },
      defaults => { eol => 'CR' };
  
  would result in the following call to C<&build_reformatter>:
  
    my $code = build_reformatter(
      'Text::Tweaker',
      'reformat',
      { width => 33 }, # note that -as is not passed in
      { defaults => { eol => 'CR' } },
    );
  
  The returned coderef (C<$code>) would then be installed as C<make_narrow> in the
  calling package.
  
  Instead of providing a coderef in the configuration, a reference to a method
  name may be provided.  This method will then be called on the invocant of the
  C<import> method.  (In this case, we do not pass the C<$class> parameter, as it
  would be redundant.)
  
  =head2 Group Configuration
  
  The C<groups> list can be passed in the same forms as C<exports>.  Groups must
  have values to be meaningful, which may either list exports that make up the
  group (optionally with arguments) or may provide a way to build the group.
  
  The simpler case is the first: a group definition is a list of exports.  Here's
  the example that could go in exporter in the L</SYNOPSIS>.
  
    groups  => {
      default    => [ qw(reformat) ],
      shorteners => [ qw(squish trim) ],
      email_safe => [
        'indent',
        reformat => { -as => 'email_format', width => 72 }
      ],
    },
  
  Groups are imported by specifying their name prefixed be either a dash or a
  colon.  This line of code would import the C<shorteners> group:
  
    use Text::Tweaker qw(-shorteners);
  
  Arguments passed to a group when importing are merged into the groups options
  and passed to any relevant generators.  Groups can contain other groups, but
  looping group structures are ignored.
  
  The other possible value for a group definition, a coderef, allows one
  generator to build several exportable routines simultaneously.  This is useful
  when many routines must share enclosed lexical variables.  The coderef must
  return a hash reference.  The keys will be used as export names and the values
  are the subs that will be exported.
  
  This example shows a simple use of the group generator.
  
    package Data::Crypto;
    use Sub::Exporter -setup => { groups => { cipher => \&build_cipher_group } };
  
    sub build_cipher_group {
      my ($class, $group, $arg) = @_;
      my ($encode, $decode) = build_codec($arg->{secret});
      return { cipher => $encode, decipher => $decode };
    }
  
  The C<cipher> and C<decipher> routines are built in a group because they are
  built together by code which encloses their secret in their environment.
  
  =head3 Default Groups
  
  If a module that uses Sub::Exporter is C<use>d with no arguments, it will try
  to export the group named C<default>.  If that group has not been specifically
  configured, it will be empty, and nothing will happen.
  
  Another group is also created if not defined: C<all>.  The C<all> group
  contains all the exports from the exports list.
  
  =head2 Collector Configuration
  
  The C<collectors> entry in the exporter configuration gives names which, when
  found in the import call, have their values collected and passed to every
  generator.
  
  For example, the C<build_analyzer> generator that we saw above could be
  rewritten as:
  
   sub build_analyzer {
     my ($class, $name, $arg, $col) = @_;
  
     return sub {
       my $data      = shift;
       my $tolerance = shift || $arg->{tolerance} || $col->{defaults}{tolerance}; 
       my $passes    = shift || $arg->{passes}    || $col->{defaults}{passes}; 
  
       analyze($data, $tolerance, $passes);
     }
   }
  
  That would allow the import to specify global defaults for his imports:
  
    use Data::Analyze
      'analyze',
      analyze  => { tolerance => 0.10, -as => analyze10 },
      analyze  => { tolerance => 0.15, passes => 50, -as => analyze50 },
      defaults => { passes => 10 };
  
    my $A = analyze10($data);     # equivalent to analyze($data, 0.10, 10);
    my $C = analyze50($data);     # equivalent to analyze($data, 0.15, 10);
    my $B = analyze($data, 0.20); # equivalent to analyze($data, 0.20, 10);
  
  If values are provided in the C<collectors> list during exporter setup, they
  must be code references, and are used to validate the importer's values.  The
  validator is called when the collection is found, and if it returns false, an
  exception is thrown.  We could ensure that no one tries to set a global data
  default easily:
  
    collectors => { defaults => sub { return (exists $_[0]->{data}) ? 0 : 1 } }
  
  Collector coderefs can also be used as hooks to perform arbitrary actions
  before anything is exported.
  
  When the coderef is called, it is passed the value of the collection and a
  hashref containing the following entries:
  
    name        - the name of the collector
    config      - the exporter configuration (hashref)
    import_args - the arguments passed to the exporter, sans collections (aref)
    class       - the package on which the importer was called
    into        - the package into which exports will be exported
  
  Collectors with all-caps names (that is, made up of underscore or capital A
  through Z) are reserved for special use.  The only currently implemented
  special collector is C<INIT>, whose hook (if present in the exporter
  configuration) is always run before any other hook.
  
  =head1 CALLING THE EXPORTER
  
  Arguments to the exporter (that is, the arguments after the module name in a
  C<use> statement) are parsed as follows:
  
  First, the collectors gather any collections found in the arguments.  Any
  reference type may be given as the value for a collector.  For each collection
  given in the arguments, its validator (if any) is called.  
  
  Next, groups are expanded.  If the group is implemented by a group generator,
  the generator is called.  There are two special arguments which, if given to a
  group, have special meaning:
  
    -prefix - a string to prepend to any export imported from this group
    -suffix - a string to append to any export imported from this group
  
  Finally, individual export generators are called and all subs, generated or
  otherwise, are installed in the calling package.  There is only one special
  argument for export generators:
  
    -as     - where to install the exported sub
  
  Normally, C<-as> will contain an alternate name for the routine.  It may,
  however, contain a reference to a scalar.  If that is the case, a reference the
  generated routine will be placed in the scalar referenced by C<-as>.  It will
  not be installed into the calling package.
  
  =head2 Special Exporter Arguments
  
  The generated exporter accept some special options, which may be passed as the
  first argument, in a hashref.
  
  These options are:
  
    into_level
    into
    generator
    installer
  
  These override the same-named configuration options described in L</EXPORTER
  CONFIGURATION>.
  
  =cut
  
  # Given a potential import name, this returns the group name -- if it's got a
  # group prefix.
  sub _group_name {
    my ($name) = @_;
  
    return if (index q{-:}, (substr $name, 0, 1)) == -1;
    return substr $name, 1;
  }
  
  # \@groups is a canonicalized opt list of exports and groups this returns
  # another canonicalized opt list with groups replaced with relevant exports.
  # \%seen is groups we've already expanded and can ignore.
  # \%merge is merged options from the group we're descending through.
  sub _expand_groups {
    my ($class, $config, $groups, $collection, $seen, $merge) = @_;
    $seen  ||= {};
    $merge ||= {};
    my @groups = @$groups;
  
    for my $i (reverse 0 .. $#groups) {
      if (my $group_name = _group_name($groups[$i][0])) {
        my $seen = { %$seen }; # faux-dynamic scoping
  
        splice @groups, $i, 1,
          _expand_group($class, $config, $groups[$i], $collection, $seen, $merge);
      } else {
        # there's nothing to munge in this export's args
        next unless my %merge = %$merge;
  
        # we have things to merge in; do so
        my $prefix = (delete $merge{-prefix}) || '';
        my $suffix = (delete $merge{-suffix}) || '';
  
        if (
          Params::Util::_CODELIKE($groups[$i][1]) ## no critic Private
          or
          Params::Util::_SCALAR0($groups[$i][1]) ## no critic Private
        ) {
          # this entry was build by a group generator
          $groups[$i][0] = $prefix . $groups[$i][0] . $suffix;
        } else {
          my $as
            = ref $groups[$i][1]{-as} ? $groups[$i][1]{-as}
            :     $groups[$i][1]{-as} ? $prefix . $groups[$i][1]{-as} . $suffix
            :                           $prefix . $groups[$i][0]      . $suffix;
  
          $groups[$i][1] = { %{ $groups[$i][1] }, %merge, -as => $as };
        }
      }
    }
  
    return \@groups;
  }
  
  # \@group is a name/value pair from an opt list.
  sub _expand_group {
    my ($class, $config, $group, $collection, $seen, $merge) = @_;
    $merge ||= {};
  
    my ($group_name, $group_arg) = @$group;
    $group_name = _group_name($group_name);
  
    Carp::croak qq(group "$group_name" is not exported by the $class module)
      unless exists $config->{groups}{$group_name};
  
    return if $seen->{$group_name}++;
  
    if (ref $group_arg) {
      my $prefix = (delete $merge->{-prefix}||'') . ($group_arg->{-prefix}||'');
      my $suffix = ($group_arg->{-suffix}||'') . (delete $merge->{-suffix}||'');
      $merge = {
        %$merge,
        %$group_arg,
        ($prefix ? (-prefix => $prefix) : ()),
        ($suffix ? (-suffix => $suffix) : ()),
      };
    }
  
    my $exports = $config->{groups}{$group_name};
  
    if (
      Params::Util::_CODELIKE($exports) ## no critic Private
      or
      Params::Util::_SCALAR0($exports) ## no critic Private
    ) {
      # I'm not very happy with this code for hiding -prefix and -suffix, but
      # it's needed, and I'm not sure, offhand, how to make it better.
      # -- rjbs, 2006-12-05
      my $group_arg = $merge ? { %$merge } : {};
      delete $group_arg->{-prefix};
      delete $group_arg->{-suffix};
  
      my $group = Params::Util::_CODELIKE($exports) ## no critic Private
                ? $exports->($class, $group_name, $group_arg, $collection)
                : $class->$$exports($group_name, $group_arg, $collection);
  
      Carp::croak qq(group generator "$group_name" did not return a hashref)
        if ref $group ne 'HASH';
  
      my $stuff = [ map { [ $_ => $group->{$_} ] } keys %$group ];
      return @{
        _expand_groups($class, $config, $stuff, $collection, $seen, $merge)
      };
    } else {
      $exports
        = Data::OptList::mkopt($exports, "$group_name exports");
  
      return @{
        _expand_groups($class, $config, $exports, $collection, $seen, $merge)
      };
    }
  }
  
  sub _mk_collection_builder {
    my ($col, $etc) = @_;
    my ($config, $import_args, $class, $into) = @$etc;
  
    my %seen;
    sub {
      my ($collection) = @_;
      my ($name, $value) = @$collection;
  
      Carp::croak "collection $name provided multiple times in import"
        if $seen{ $name }++;
  
      if (ref(my $hook = $config->{collectors}{$name})) {
        my $arg = {
          name        => $name,
          config      => $config,
          import_args => $import_args,
          class       => $class,
          into        => $into,
        };
  
        my $error_msg = "collection $name failed validation";
        if (Params::Util::_SCALAR0($hook)) { ## no critic Private
          Carp::croak $error_msg unless $class->$$hook($value, $arg);
        } else {
          Carp::croak $error_msg unless $hook->($value, $arg);
        }
      }
  
      $col->{ $name } = $value;
    }
  }
  
  # Given a config and pre-canonicalized importer args, remove collections from
  # the args and return them.
  sub _collect_collections {
    my ($config, $import_args, $class, $into) = @_;
  
    my @collections
      = map  { splice @$import_args, $_, 1 }
        grep { exists $config->{collectors}{ $import_args->[$_][0] } }
        reverse 0 .. $#$import_args;
  
    unshift @collections, [ INIT => {} ] if $config->{collectors}{INIT};
  
    my $col = {};
    my $builder = _mk_collection_builder($col, \@_);
    for my $collection (@collections) {
      $builder->($collection)
    }
  
    return $col;
  }
  
  =head1 SUBROUTINES
  
  =head2 setup_exporter
  
  This routine builds and installs an C<import> routine.  It is called with one
  argument, a hashref containing the exporter configuration.  Using this, it
  builds an exporter and installs it into the calling package with the name
  "import."  In addition to the normal exporter configuration, a few named
  arguments may be passed in the hashref:
  
    into       - into what package should the exporter be installed
    into_level - into what level up the stack should the exporter be installed
    as         - what name should the installed exporter be given
  
  By default the exporter is installed with the name C<import> into the immediate
  caller of C<setup_exporter>.  In other words, if your package calls
  C<setup_exporter> without providing any of the three above arguments, it will
  have an C<import> routine installed.
  
  Providing both C<into> and C<into_level> will cause an exception to be thrown.
  
  The exporter is built by C<L</build_exporter>>.
  
  =cut
  
  sub setup_exporter {
    my ($config)  = @_;
  
    Carp::croak 'into and into_level may not both be supplied to exporter'
      if exists $config->{into} and exists $config->{into_level};
  
    my $as   = delete $config->{as}   || 'import';
    my $into
      = exists $config->{into}       ? delete $config->{into}
      : exists $config->{into_level} ? caller(delete $config->{into_level})
      :                                caller(0);
  
    my $import = build_exporter($config);
  
    Sub::Install::reinstall_sub({
      code => $import,
      into => $into,
      as   => $as,
    });
  }
  
  =head2 build_exporter
  
  Given a standard exporter configuration, this routine builds and returns an
  exporter -- that is, a subroutine that can be installed as a class method to
  perform exporting on request.
  
  Usually, this method is called by C<L</setup_exporter>>, which then installs
  the exporter as a package's import routine.
  
  =cut
  
  sub _key_intersection {
    my ($x, $y) = @_;
    my %seen = map { $_ => 1 } keys %$x;
    my @names = grep { $seen{$_} } keys %$y;
  }
  
  # Given the config passed to setup_exporter, which contains sugary opt list
  # data, rewrite the opt lists into hashes, catch a few kinds of invalid
  # configurations, and set up defaults.  Since the config is a reference, it's
  # rewritten in place.
  my %valid_config_key;
  BEGIN {
    %valid_config_key =
      map { $_ => 1 }
      qw(as collectors installer generator exports groups into into_level),
      qw(exporter), # deprecated
  }
  
  sub _assert_collector_names_ok {
    my ($collectors) = @_;
  
    for my $reserved_name (grep { /\A[_A-Z]+\z/ } keys %$collectors) {
      Carp::croak "unknown reserved collector name: $reserved_name"
        if $reserved_name ne 'INIT';
    }
  }
  
  sub _rewrite_build_config {
    my ($config) = @_;
  
    if (my @keys = grep { not exists $valid_config_key{$_} } keys %$config) {
      Carp::croak "unknown options (@keys) passed to Sub::Exporter";
    }
  
    Carp::croak q(into and into_level may not both be supplied to exporter)
      if exists $config->{into} and exists $config->{into_level};
  
    # XXX: Remove after deprecation period.
    if ($config->{exporter}) {
      Carp::cluck "'exporter' argument to build_exporter is deprecated. Use 'installer' instead; the semantics are identical.";
      $config->{installer} = delete $config->{exporter};
    }
  
    Carp::croak q(into and into_level may not both be supplied to exporter)
      if exists $config->{into} and exists $config->{into_level};
  
    for (qw(exports collectors)) {
      $config->{$_} = Data::OptList::mkopt_hash(
        $config->{$_},
        $_,
        [ 'CODE', 'SCALAR' ],
      );
    }
  
    _assert_collector_names_ok($config->{collectors});
  
    if (my @names = _key_intersection(@$config{qw(exports collectors)})) {
      Carp::croak "names (@names) used in both collections and exports";
    }
  
    $config->{groups} = Data::OptList::mkopt_hash(
        $config->{groups},
        'groups',
        [
          'HASH',   # standard opt list
          'ARRAY',  # standard opt list
          'CODE',   # group generator
          'SCALAR', # name of group generation method
        ]
      );
  
    # by default, export nothing
    $config->{groups}{default} ||= [];
  
    # by default, build an all-inclusive 'all' group
    $config->{groups}{all} ||= [ keys %{ $config->{exports} } ];
  
    $config->{generator} ||= \&default_generator;
    $config->{installer} ||= \&default_installer;
  }
  
  sub build_exporter {
    my ($config) = @_;
  
    _rewrite_build_config($config);
  
    my $import = sub {
      my ($class) = shift;
  
      # XXX: clean this up -- rjbs, 2006-03-16
      my $special = (ref $_[0]) ? shift(@_) : {};
      Carp::croak q(into and into_level may not both be supplied to exporter)
        if exists $special->{into} and exists $special->{into_level};
  
      if ($special->{exporter}) {
        Carp::cluck "'exporter' special import argument is deprecated. Use 'installer' instead; the semantics are identical.";
        $special->{installer} = delete $special->{exporter};
      }
  
      my $into
        = defined $special->{into}       ? delete $special->{into}
        : defined $special->{into_level} ? caller(delete $special->{into_level})
        : defined $config->{into}        ? $config->{into}
        : defined $config->{into_level}  ? caller($config->{into_level})
        :                                  caller(0);
  
      my $generator = delete $special->{generator} || $config->{generator};
      my $installer = delete $special->{installer} || $config->{installer};
  
      # this builds a AOA, where the inner arrays are [ name => value_ref ]
      my $import_args = Data::OptList::mkopt([ @_ ]);
  
      # is this right?  defaults first or collectors first? -- rjbs, 2006-06-24
      $import_args = [ [ -default => undef ] ] unless @$import_args;
  
      my $collection = _collect_collections($config, $import_args, $class, $into);
  
      my $to_import = _expand_groups($class, $config, $import_args, $collection);
  
      # now, finally $import_arg is really the "to do" list
      _do_import(
        {
          class     => $class,
          col       => $collection,
          config    => $config,
          into      => $into,
          generator => $generator,
          installer => $installer,
        },
        $to_import,
      );
    };
  
    return $import;
  }
  
  sub _do_import {
    my ($arg, $to_import) = @_;
  
    my @todo;
  
    for my $pair (@$to_import) {
      my ($name, $import_arg) = @$pair;
  
      my ($generator, $as);
  
      if ($import_arg and Params::Util::_CODELIKE($import_arg)) { ## no critic
        # This is the case when a group generator has inserted name/code pairs.
        $generator = sub { $import_arg };
        $as = $name;
      } else {
        $import_arg = { $import_arg ? %$import_arg : () };
  
        Carp::croak qq("$name" is not exported by the $arg->{class} module)
          unless exists $arg->{config}{exports}{$name};
  
        $generator = $arg->{config}{exports}{$name};
  
        $as = exists $import_arg->{-as} ? (delete $import_arg->{-as}) : $name;
      }
  
      my $code = $arg->{generator}->(
        { 
          class     => $arg->{class},
          name      => $name,
          arg       => $import_arg,
          col       => $arg->{col},
          generator => $generator,
        }
      );
  
      push @todo, $as, $code;
    }
  
    $arg->{installer}->(
      {
        class => $arg->{class},
        into  => $arg->{into},
        col   => $arg->{col},
      },
      \@todo,
    );
  }
  
  ## Cute idea, possibly for future use: also supply an "unimport" for:
  ## no Module::Whatever qw(arg arg arg);
  # sub _unexport {
  #   my (undef, undef, undef, undef, undef, $as, $into) = @_;
  # 
  #   if (ref $as eq 'SCALAR') {
  #     undef $$as;
  #   } elsif (ref $as) {
  #     Carp::croak "invalid reference type for $as: " . ref $as;
  #   } else {
  #     no strict 'refs';
  #     delete &{$into . '::' . $as};
  #   }
  # }
  
  =head2 default_generator
  
  This is Sub::Exporter's default generator.  It takes bits of configuration that
  have been gathered during the import and turns them into a coderef that can be
  installed.
  
    my $code = default_generator(\%arg);
  
  Passed arguments are:
  
    class - the class on which the import method was called
    name  - the name of the export being generated
    arg   - the arguments to the generator
    col   - the collections
  
    generator - the generator to be used to build the export (code or scalar ref)
  
  =cut
  
  sub default_generator {
    my ($arg) = @_;
    my ($class, $name, $generator) = @$arg{qw(class name generator)};
  
    if (not defined $generator) {
      my $code = $class->can($name)
        or Carp::croak "can't locate exported subroutine $name via $class";
      return $code;
    }
  
    # I considered making this "$class->$generator(" but it seems that
    # overloading precedence would turn an overloaded-as-code generator object
    # into a string before code. -- rjbs, 2006-06-11
    return $generator->($class, $name, $arg->{arg}, $arg->{col})
      if Params::Util::_CODELIKE($generator); ## no critic Private
  
    # This "must" be a scalar reference, to a generator method name.
    # -- rjbs, 2006-12-05
    return $class->$$generator($name, $arg->{arg}, $arg->{col});
  }
  
  =head2 default_installer
  
  This is Sub::Exporter's default installer.  It does what Sub::Exporter
  promises: it installs code into the target package.
  
    default_installer(\%arg, \@to_export);
  
  Passed arguments are:
  
    into - the package into which exports should be delivered
  
  C<@to_export> is a list of name/value pairs.  The default exporter assigns code
  (the values) to named slots (the names) in the given package.  If the name is a
  scalar reference, the scalar reference is made to point to the code reference
  instead.
  
  =cut
  
  sub default_installer {
    my ($arg, $to_export) = @_;
  
    for (my $i = 0; $i < @$to_export; $i += 2) {
      my ($as, $code) = @$to_export[ $i, $i+1 ];
  
      # Allow as isa ARRAY to push onto an array?
      # Allow into isa HASH to install name=>code into hash?
  
      if (ref $as eq 'SCALAR') {
        $$as = $code;
      } elsif (ref $as) {
        Carp::croak "invalid reference type for $as: " . ref $as;
      } else {
        Sub::Install::reinstall_sub({
          code => $code,
          into => $arg->{into},
          as   => $as
        });
      }
    }
  }
  
  sub default_exporter {
    Carp::cluck "default_exporter is deprecated; call default_installer instead; the semantics are identical";
    goto &default_installer;
  }
  
  =head1 EXPORTS
  
  Sub::Exporter also offers its own exports: the C<setup_exporter> and
  C<build_exporter> routines described above.  It also provides a special "setup"
  collector, which will set up an exporter using the parameters passed to it.
  
  Note that the "setup" collector (seen in examples like the L</SYNOPSIS> above)
  uses C<build_exporter>, not C<setup_exporter>.  This means that the special
  arguments like "into" and "as" for C<setup_exporter> are not accepted here.
  Instead, you may write something like:
  
    use Sub::Exporter
      { into => 'Target::Package' },
      -setup => {
        -as     => 'do_import',
        exports => [ ... ],
      }
    ;
  
  Finding a good reason for wanting to do this is left as as exercise for the
  reader.
  
  =cut
  
  setup_exporter({
    exports => [
      qw(setup_exporter build_exporter),
      _import => sub { build_exporter($_[2]) },
    ],
    groups  => {
      all   => [ qw(setup_exporter build_export) ],
    },
    collectors => { -setup => \&_setup },
  });
  
  sub _setup {
    my ($value, $arg) = @_;
  
    if (ref $value eq 'HASH') {
      push @{ $arg->{import_args} }, [ _import => { -as => 'import', %$value } ];
      return 1;
    } elsif (ref $value eq 'ARRAY') {
      push @{ $arg->{import_args} },
        [ _import => { -as => 'import', exports => $value } ];
      return 1;
    }
    return;
  }
  
  =head1 COMPARISONS
  
  There are a whole mess of exporters on the CPAN.  The features included in
  Sub::Exporter set it apart from any existing Exporter.  Here's a summary of
  some other exporters and how they compare.
  
  =over
  
  =item * L<Exporter> and co.
  
  This is the standard Perl exporter.  Its interface is a little clunky, but it's
  fast and ubiquitous.  It can do some things that Sub::Exporter can't:  it can
  export things other than routines, it can import "everything in this group
  except this symbol," and some other more esoteric things.  These features seem
  to go nearly entirely unused.
  
  It always exports things exactly as they appear in the exporting module; it
  can't rename or customize routines.  Its groups ("tags") can't be nested.
  
  L<Exporter::Lite> is a whole lot like Exporter, but it does significantly less:
  it supports exporting symbols, but not groups, pattern matching, or negation.
  
  The fact that Sub::Exporter can't export symbols other than subroutines is
  a good idea, not a missing feature.
  
  For simple uses, setting up Sub::Exporter is about as easy as Exporter.  For
  complex uses, Sub::Exporter makes hard things possible, which would not be
  possible with Exporter. 
  
  When using a module that uses Sub::Exporter, users familiar with Exporter will
  probably see no difference in the basics.  These two lines do about the same
  thing in whether the exporting module uses Exporter or Sub::Exporter.
  
    use Some::Module qw(foo bar baz);
    use Some::Module qw(foo :bar baz);
  
  The definition for exporting in Exporter.pm might look like this:
  
    package Some::Module;
    use base qw(Exporter);
    our @EXPORT_OK   = qw(foo bar baz quux);
    our %EXPORT_TAGS = (bar => [ qw(bar baz) ]);
  
  Using Sub::Exporter, it would look like this:
  
    package Some::Module;
    use Sub::Exporter -setup => {
      exports => [ qw(foo bar baz quux) ],
      groups  => { bar => [ qw(bar baz) ]}
    };
  
  Sub::Exporter respects inheritance, so that a package may export inherited
  routines, and will export the most inherited version.  Exporting methods
  without currying away the invocant is a bad idea, but Sub::Exporter allows you
  to do just that -- and anyway, there are other uses for this feature, like
  packages of exported subroutines which use inheritance specifically to allow
  more specialized, but similar, packages.
  
  L<Exporter::Easy> provides a wrapper around the standard Exporter.  It makes it
  simpler to build groups, but doesn't provide any more functionality.  Because
  it is a front-end to Exporter, it will store your exporter's configuration in
  global package variables.
  
  =item * Attribute-Based Exporters
  
  Some exporters use attributes to mark variables to export.  L<Exporter::Simple>
  supports exporting any kind of symbol, and supports groups.  Using a module
  like Exporter or Sub::Exporter, it's easy to look at one place and see what is
  exported, but it's impossible to look at a variable definition and see whether
  it is exported by that alone.  Exporter::Simple makes this trade in reverse:
  each variable's declaration includes its export definition, but there is no one
  place to look to find a manifest of exports.
  
  More importantly, Exporter::Simple does not add any new features to those of
  Exporter.  In fact, like Exporter::Easy, it is just a front-end to Exporter, so
  it ends up storing its configuration in global package variables.  (This means
  that there is one place to look for your exporter's manifest, actually.  You
  can inspect the C<@EXPORT> package variables, and other related package
  variables, at runtime.)
  
  L<Perl6::Export> isn't actually attribute based, but looks similar.  Its syntax
  is borrowed from Perl 6, and implemented by a source filter.  It is a prototype
  of an interface that is still being designed.  It should probably be avoided
  for production work.  On the other hand, L<Perl6::Export::Attrs> implements
  Perl 6-like exporting, but translates it into Perl 5 by providing attributes.
  
  =item * Other Exporters
  
  L<Exporter::Renaming> wraps the standard Exporter to allow it to export symbols
  with changed names.
  
  L<Class::Exporter> performs a special kind of routine generation, giving each
  importing package an instance of your class, and then exporting the instance's
  methods as normal routines.  (Sub::Exporter, of course, can easily emulate this
  behavior, as shown above.)
  
  L<Exporter::Tidy> implements a form of renaming (using its C<_map> argument)
  and of prefixing, and implements groups.  It also avoids using package
  variables for its configuration.
  
  =back
  
  =head1 TODO
  
  =cut
  
  =over
  
  =item * write a set of longer, more demonstrative examples
  
  =item * solidify the "custom exporter" interface (see C<&default_exporter>)
  
  =item * add an "always" group
  
  =back
  
  =head1 AUTHOR
  
  Ricardo SIGNES, C<< <rjbs@cpan.org> >>
  
  =head1 THANKS
  
  Hans Dieter Pearcey provided helpful advice while I was writing Sub::Exporter.
  Ian Langworth and Shawn Sorichetti asked some good questions and hepled me
  improve my documentation quite a bit.  Yuval Kogman helped me find a bunch of
  little problems.
  
  Thanks, guys! 
  
  =head1 BUGS
  
  Please report any bugs or feature requests through the web interface at
  L<http://rt.cpan.org>. I will be notified, and then you'll automatically be
  notified of progress on your bug as I make changes.
  
  =head1 COPYRIGHT
  
  Copyright 2006-2007, Ricardo SIGNES.  This program is free software;  you can
  redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  "jn8:32"; # <-- magic true value
SUB_EXPORTER

$fatpacked{"Sub/Exporter/Util.pm"} = <<'SUB_EXPORTER_UTIL';
  use strict;
  use warnings;
  
  package Sub::Exporter::Util;
  
  use Data::OptList ();
  use Params::Util ();
  
  =head1 NAME
  
  Sub::Exporter::Util - utilities to make Sub::Exporter easier
  
  =head1 VERSION
  
  version 0.982
  
  =cut
  
  our $VERSION = '0.982';
  
  =head1 DESCRIPTION
  
  This module provides a number of utility functions for performing common or
  useful operations when setting up a Sub::Exporter configuration.  All of the
  utilites may be exported, but none are by default.
  
  =head1 THE UTILITIES
  
  =head2 curry_method
  
    exports => {
      some_method => curry_method,
    }
  
  This utility returns a generator which will produce an invocant-curried version
  of a method.  In other words, it will export a method call with the exporting
  class built in as the invocant.
  
  A module importing the code some the above example might do this:
  
    use Some::Module qw(some_method);
  
    my $x = some_method;
  
  This would be equivalent to:
  
    use Some::Module;
  
    my $x = Some::Module->some_method;
  
  If Some::Module is subclassed and the subclass's import method is called to
  import C<some_method>, the subclass will be curried in as the invocant.
  
  If an argument is provided for C<curry_method> it is used as the name of the
  curried method to export.  This means you could export a Widget constructor
  like this:
  
    exports => { widget => curry_method('new') }
  
  This utility may also be called as C<curry_class>, for backwards compatibility.
  
  =cut
  
  sub curry_method {
    my $override_name = shift;
    sub {
      my ($class, $name) = @_;
      $name = $override_name if defined $override_name;
      sub { $class->$name(@_); };
    }
  }
  
  BEGIN { *curry_class = \&curry_method; }
  
  =head2 curry_chain
  
  C<curry_chain> behaves like C<L</curry_method>>, but is meant for generating
  exports that will call several methods in succession.
  
    exports => {
      reticulate => curry_chain([
        new => gather_data => analyze => [ detail => 100 ] => results
      ]),
    }
  
  If imported from Spliner, calling the C<reticulate> routine will be equivalent
  to:
  
    Splinter->new->gather_data->analyze(detail => 100)->results;
  
  If any method returns something on which methods may not be called, the routine
  croaks.
  
  The arguments to C<curry_chain> form an optlist.  The names are methods to be
  called and the arguments, if given, are arrayrefs to be dereferenced and passed
  as arguments to those methods.  C<curry_chain> returns a generator like those
  expected by Sub::Exporter.
  
  B<Achtung!> at present, there is no way to pass arguments from the generated
  routine to the method calls.  This will probably be solved in future revisions
  by allowing the opt list's values to be subroutines that will be called with
  the generated routine's stack.
  
  =cut
  
  sub curry_chain {
    # In the future, we can make \%arg an optional prepend, like the "special"
    # args to the default Sub::Exporter-generated import routine.
    my (@opt_list) = @_;
  
    my $pairs = Data::OptList::mkopt(\@opt_list, 'args', 'ARRAY');
  
    sub {
      my ($class) = @_;
  
      sub {
        my $next = $class;
  
        for my $i (0 .. $#$pairs) {
          my $pair = $pairs->[ $i ];
          
          unless (Params::Util::_INVOCANT($next)) { ## no critic Private
            my $str = defined $next ? "'$next'" : 'undef';
            Carp::croak("can't call $pair->[0] on non-invocant $str")
          }
  
          my ($method, $args) = @$pair;
  
          if ($i == $#$pairs) {
            return $next->$method($args ? @$args : ());
          } else {
            $next = $next->$method($args ? @$args : ());
          }
        }
      };
    }
  }
  
  # =head2 name_map
  # 
  # This utility returns an list to be used in specify export generators.  For
  # example, the following:
  # 
  #   exports => {
  #     name_map(
  #       '_?_gen'  => [ qw(fee fie) ],
  #       '_make_?' => [ qw(foo bar) ],
  #     ),
  #   }
  # 
  # is equivalent to:
  # 
  #   exports => {
  #     name_map(
  #       fee => \'_fee_gen',
  #       fie => \'_fie_gen',
  #       foo => \'_make_foo',
  #       bar => \'_make_bar',
  #     ),
  #   }
  # 
  # This can save a lot of typing, when providing many exports with similarly-named
  # generators.
  # 
  # =cut
  # 
  # sub name_map {
  #   my (%groups) = @_;
  # 
  #   my %map;
  # 
  #   while (my ($template, $names) = each %groups) {
  #     for my $name (@$names) {
  #       (my $export = $template) =~ s/\?/$name/
  #         or Carp::croak 'no ? found in name_map template';
  # 
  #       $map{ $name } = \$export;
  #     }
  #   }
  # 
  #   return %map;
  # }
  
  =head2 merge_col
  
    exports => {
      merge_col(defaults => {
        twiddle => \'_twiddle_gen',
        tweak   => \&_tweak_gen,
      }),
    }
  
  This utility wraps the given generator in one that will merge the named
  collection into its args before calling it.  This means that you can support a
  "default" collector in multipe exports without writing the code each time.
  
  You can specify as many pairs of collection names and generators as you like.
  
  =cut
  
  sub merge_col {
    my (%groups) = @_;
  
    my %merged;
  
    while (my ($default_name, $group) = each %groups) {
      while (my ($export_name, $gen) = each %$group) {
        $merged{$export_name} = sub {
          my ($class, $name, $arg, $col) = @_;
  
          my $merged_arg = exists $col->{$default_name}
                         ? { %{ $col->{$default_name} }, %$arg }
                         : $arg;
  
          if (Params::Util::_CODELIKE($gen)) { ## no critic Private
            $gen->($class, $name, $merged_arg, $col);
          } else {
            $class->$$gen($name, $merged_arg, $col);
          }
        }
      }
    }
  
    return %merged;
  }
  
  =head2 mixin_installer
  
    use Sub::Exporter -setup => {
      installer => Sub::Exporter::Util::mixin_installer,
      exports   => [ qw(foo bar baz) ],
    };
  
  This utility returns an installer that will install into a superclass and
  adjust the ISA importing class to include the newly generated superclass.
  
  If the target of importing is an object, the hierarchy is reversed: the new
  class will be ISA the object's class, and the object will be reblessed.
  
  B<Prerequisites>: This utility requires that Package::Generator be installed.
  
  =cut
  
  sub __mixin_class_for {
    my ($class, $mix_into) = @_;
    require Package::Generator;
    my $mixin_class = Package::Generator->new_package({
      base => "$class\:\:__mixin__",
    });
  
    ## no critic (ProhibitNoStrict)
    no strict 'refs';
    if (ref $mix_into) {
      unshift @{"$mixin_class" . "::ISA"}, ref $mix_into;
    } else {
      unshift @{"$mix_into" . "::ISA"}, $mixin_class;
    }
    return $mixin_class;
  }
  
  sub mixin_installer {
    sub {
      my ($arg, $to_export) = @_;
  
      my $mixin_class = __mixin_class_for($arg->{class}, $arg->{into});
      bless $arg->{into} => $mixin_class if ref $arg->{into};
  
      Sub::Exporter::default_installer(
        { %$arg, into => $mixin_class },
        $to_export,
      );
    };
  }
  
  sub mixin_exporter {
    Carp::cluck "mixin_exporter is deprecated; use mixin_installer instead; it behaves identically";
    return mixin_installer;
  }
  
  =head2 like
  
  It's a collector that adds imports for anything like given regex.
  
  If you provide this configuration:
  
    exports    => [ qw(igrep imap islurp exhausted) ],
    collectors => { -like => Sub::Exporter::Util::like },
  
  A user may import from your module like this:
  
    use Your::Iterator -like => qr/^i/; # imports igre, imap, islurp
  
  or
  
    use Your::Iterator -like => [ qr/^i/ => { -prefix => 'your_' } ];
  
  The group-like prefix and suffix arguments are respected; other arguments are
  passed on to the generators for matching exports.
  
  =cut
  
  sub like {
    sub {
      my ($value, $arg) = @_;
      Carp::croak "no regex supplied to regex group generator" unless $value;
  
      # Oh, qr//, how you bother me!  See the p5p thread from around now about
      # fixing this problem... too bad it won't help me. -- rjbs, 2006-04-25
      my @values = eval { $value->isa('Regexp') } ? ($value, undef)
                 :                                  @$value;
  
      while (my ($re, $opt) = splice @values, 0, 2) {
        Carp::croak "given pattern for regex group generater is not a Regexp"
          unless eval { $re->isa('Regexp') };
        my @exports  = keys %{ $arg->{config}->{exports} };
        my @matching = grep { $_ =~ $re } @exports;
  
        my %merge = $opt ? %$opt : ();
        my $prefix = (delete $merge{-prefix}) || '';
        my $suffix = (delete $merge{-suffix}) || '';
  
        for my $name (@matching) {
          my $as = $prefix . $name . $suffix;
          push @{ $arg->{import_args} }, [ $name => { %merge, -as => $as } ];
        }
      }
  
      1;
    }
  }
  
  use Sub::Exporter -setup => {
    exports => [ qw(
      like
      name_map
      merge_col
      curry_method curry_class
      curry_chain
      mixin_installer mixin_exporter
    ) ]
  };
  
  =head1 AUTHOR
  
  Ricardo SIGNES, C<< <rjbs@cpan.org> >>
  
  =head1 BUGS
  
  Please report any bugs or feature requests through the web interface at
  L<http://rt.cpan.org>. I will be notified, and then you'll automatically be
  notified of progress on your bug as I make changes.
  
  =head1 COPYRIGHT
  
  Copyright 2006-2007, Ricardo SIGNES.  This program is free software;  you can
  redistribute it and/or modify it under the same terms as Perl itself.
  
  =cut
  
  1;
SUB_EXPORTER_UTIL

$fatpacked{"Sub/Install.pm"} = <<'SUB_INSTALL';
  package Sub::Install;
  
  use warnings;
  use strict;
  
  use Carp;
  use Scalar::Util ();
  
  =head1 NAME
  
  Sub::Install - install subroutines into packages easily
  
  =head1 VERSION
  
  version 0.925
  
  =cut
  
  our $VERSION = '0.925';
  
  =head1 SYNOPSIS
  
    use Sub::Install;
  
    Sub::Install::install_sub({
      code => sub { ... },
      into => $package,
      as   => $subname
    });
  
  =head1 DESCRIPTION
  
  This module makes it easy to install subroutines into packages without the
  unslightly mess of C<no strict> or typeglobs lying about where just anyone can
  see them.
  
  =head1 FUNCTIONS
  
  =head2 install_sub
  
    Sub::Install::install_sub({
     code => \&subroutine,
     into => "Finance::Shady",
     as   => 'launder',
    });
  
  This routine installs a given code reference into a package as a normal
  subroutine.  The above is equivalent to:
  
    no strict 'refs';
    *{"Finance::Shady" . '::' . "launder"} = \&subroutine;
  
  If C<into> is not given, the sub is installed into the calling package.
  
  If C<code> is not a code reference, it is looked for as an existing sub in the
  package named in the C<from> parameter.  If C<from> is not given, it will look
  in the calling package.
  
  If C<as> is not given, and if C<code> is a name, C<as> will default to C<code>.
  If C<as> is not given, but if C<code> is a code ref, Sub::Install will try to
  find the name of the given code ref and use that as C<as>.
  
  That means that this code:
  
    Sub::Install::install_sub({
      code => 'twitch',
      from => 'Person::InPain',
      into => 'Person::Teenager',
      as   => 'dance',
    });
  
  is the same as:
  
    package Person::Teenager;
  
    Sub::Install::install_sub({
      code => Person::InPain->can('twitch'),
      as   => 'dance',
    });
  
  =head2 reinstall_sub
  
  This routine behaves exactly like C<L</install_sub>>, but does not emit a
  warning if warnings are on and the destination is already defined.
  
  =cut
  
  sub _name_of_code {
    my ($code) = @_;
    require B;
    my $name = B::svref_2object($code)->GV->NAME;
    return $name unless $name =~ /\A__ANON__/;
    return;
  }
  
  # See also Params::Util, to which this code was donated.
  sub _CODELIKE {
    (Scalar::Util::reftype($_[0])||'') eq 'CODE'
    || Scalar::Util::blessed($_[0])
    && (overload::Method($_[0],'&{}') ? $_[0] : undef);
  }
  
  # do the heavy lifting
  sub _build_public_installer {
    my ($installer) = @_;
  
    sub {
      my ($arg) = @_;
      my ($calling_pkg) = caller(0);
  
      # I'd rather use ||= but I'm whoring for Devel::Cover.
      for (qw(into from)) { $arg->{$_} = $calling_pkg unless $arg->{$_} }
  
      # This is the only absolutely required argument, in many cases.
      Carp::croak "named argument 'code' is not optional" unless $arg->{code};
  
      if (_CODELIKE($arg->{code})) {
        $arg->{as} ||= _name_of_code($arg->{code});
      } else {
        Carp::croak
          "couldn't find subroutine named $arg->{code} in package $arg->{from}"
          unless my $code = $arg->{from}->can($arg->{code});
  
        $arg->{as}   = $arg->{code} unless $arg->{as};
        $arg->{code} = $code;
      }
  
      Carp::croak "couldn't determine name under which to install subroutine"
        unless $arg->{as};
  
      $installer->(@$arg{qw(into as code) });
    }
  }
  
  # do the ugly work
  
  my $_misc_warn_re;
  my $_redef_warn_re;
  BEGIN {
    $_misc_warn_re = qr/
      Prototype\ mismatch:\ sub\ .+?  |
      Constant subroutine \S+ redefined
    /x;
    $_redef_warn_re = qr/Subroutine\ \S+\ redefined/x;
  }
  
  my $eow_re;
  BEGIN { $eow_re = qr/ at .+? line \d+\.\Z/ };
  
  sub _do_with_warn {
    my ($arg) = @_;
    my $code = delete $arg->{code};
    my $wants_code = sub {
      my $code = shift;
      sub {
        my $warn = $SIG{__WARN__} ? $SIG{__WARN__} : sub { warn @_ }; ## no critic
        local $SIG{__WARN__} = sub {
          my ($error) = @_;
          for (@{ $arg->{suppress} }) {
              return if $error =~ $_;
          }
          for (@{ $arg->{croak} }) {
            if (my ($base_error) = $error =~ /\A($_) $eow_re/x) {
              Carp::croak $base_error;
            }
          }
          for (@{ $arg->{carp} }) {
            if (my ($base_error) = $error =~ /\A($_) $eow_re/x) {
              return $warn->(Carp::shortmess $base_error);
            }
          }
          ($arg->{default} || $warn)->($error);
        };
        $code->(@_);
      };
    };
    return $wants_code->($code) if $code;
    return $wants_code;
  }
  
  sub _installer {
    sub {
      my ($pkg, $name, $code) = @_;
      no strict 'refs'; ## no critic ProhibitNoStrict
      *{"$pkg\::$name"} = $code;
      return $code;
    }
  }
  
  BEGIN {
    *_ignore_warnings = _do_with_warn({
      carp => [ $_misc_warn_re, $_redef_warn_re ]
    });
  
    *install_sub = _build_public_installer(_ignore_warnings(_installer));
  
    *_carp_warnings =  _do_with_warn({
      carp     => [ $_misc_warn_re ],
      suppress => [ $_redef_warn_re ],
    });
  
    *reinstall_sub = _build_public_installer(_carp_warnings(_installer));
  
    *_install_fatal = _do_with_warn({
      code     => _installer,
      croak    => [ $_redef_warn_re ],
    });
  }
  
  =head2 install_installers
  
  This routine is provided to allow Sub::Install compatibility with
  Sub::Installer.  It installs C<install_sub> and C<reinstall_sub> methods into
  the package named by its argument.
  
   Sub::Install::install_installers('Code::Builder'); # just for us, please
   Code::Builder->install_sub({ name => $code_ref });
  
   Sub::Install::install_installers('UNIVERSAL'); # feeling lucky, punk?
   Anything::At::All->install_sub({ name => $code_ref });
  
  The installed installers are similar, but not identical, to those provided by
  Sub::Installer.  They accept a single hash as an argument.  The key/value pairs
  are used as the C<as> and C<code> parameters to the C<install_sub> routine
  detailed above.  The package name on which the method is called is used as the
  C<into> parameter.
  
  Unlike Sub::Installer's C<install_sub> will not eval strings into code, but
  will look for named code in the calling package.
  
  =cut
  
  sub install_installers {
    my ($into) = @_;
  
    for my $method (qw(install_sub reinstall_sub)) {
      my $code = sub {
        my ($package, $subs) = @_;
        my ($caller) = caller(0);
        my $return;
        for (my ($name, $sub) = %$subs) {
          $return = Sub::Install->can($method)->({
            code => $sub,
            from => $caller,
            into => $package,
            as   => $name
          });
        }
        return $return;
      };
      install_sub({ code => $code, into => $into, as => $method });
    }
  }
  
  =head1 EXPORTS
  
  Sub::Install exports C<install_sub> and C<reinstall_sub> only if they are
  requested.
  
  =head2 exporter
  
  Sub::Install has a never-exported subroutine called C<exporter>, which is used
  to implement its C<import> routine.  It takes a hashref of named arguments,
  only one of which is currently recognize: C<exports>.  This must be an arrayref
  of subroutines to offer for export.
  
  This routine is mainly for Sub::Install's own consumption.  Instead, consider
  L<Sub::Exporter>.
  
  =cut
  
  sub exporter {
    my ($arg) = @_;
    
    my %is_exported = map { $_ => undef } @{ $arg->{exports} };
  
    sub {
      my $class = shift;
      my $target = caller;
      for (@_) {
        Carp::croak "'$_' is not exported by $class" if !exists $is_exported{$_};
        install_sub({ code => $_, from => $class, into => $target });
      }
    }
  }
  
  BEGIN { *import = exporter({ exports => [ qw(install_sub reinstall_sub) ] }); }
  
  =head1 SEE ALSO
  
  =over
  
  =item L<Sub::Installer>
  
  This module is (obviously) a reaction to Damian Conway's Sub::Installer, which
  does the same thing, but does it by getting its greasy fingers all over
  UNIVERSAL.  I was really happy about the idea of making the installation of
  coderefs less ugly, but I couldn't bring myself to replace the ugliness of
  typeglobs and loosened strictures with the ugliness of UNIVERSAL methods.
  
  =item L<Sub::Exporter>
  
  This is a complete Exporter.pm replacement, built atop Sub::Install.
  
  =back
  
  =head1 AUTHOR
  
  Ricardo Signes, C<< <rjbs@cpan.org> >>
  
  Several of the tests are adapted from tests that shipped with Damian Conway's
  Sub-Installer distribution.
  
  =head1 BUGS
  
  Please report any bugs or feature requests through the web interface at
  L<http://rt.cpan.org>.  I will be notified, and then you'll automatically be
  notified of progress on your bug as I make changes.
  
  =head1 COPYRIGHT
  
  Copyright 2005-2006 Ricardo Signes, All Rights Reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
  1;
SUB_INSTALL

$fatpacked{"Test/YAML.pm"} = <<'TEST_YAML';
  package Test::YAML;
  
  use Test::Base 0.47 -Base;
  use lib 'lib';
  
  our $VERSION = '0.72';
  our $YAML    = 'YAML';
  our @EXPORT  = qw(
      no_diff
      run_yaml_tests
      run_roundtrip_nyn roundtrip_nyn
      run_load_passes load_passes
      dumper Load Dump LoadFile DumpFile
      XXX
  );
  
  delimiters('===', '+++');
  
  sub Dump     () { YAML(Dump => @_)     }
  sub Load     () { YAML(Load => @_)     }
  sub DumpFile () { YAML(DumpFile => @_) }
  sub LoadFile () { YAML(LoadFile => @_) }
  
  sub YAML () {
      load_yaml_pm();
      my $meth = shift;
      my $code = $YAML->can($meth) or die "$YAML cannot do $meth";
      goto &$code;
  }
  
  sub load_yaml_pm {
      my $file = "$YAML.pm";
      $file =~ s{::}{/}g;
      require $file;
  }
  
  sub run_yaml_tests() {
      run {
          my $block = shift;
          &{_get_function($block)}($block) unless 
            _skip_tests_for_now($block) or
            _skip_yaml_tests($block);
      };
  }
  
  sub run_roundtrip_nyn() {
      my @options = @_;
      run {
          my $block = shift;
          roundtrip_nyn($block, @options);
      };
  }
  
  sub roundtrip_nyn() {
      my $block = shift;
      my $option = shift || '';
      die "'perl' data section required"
          unless exists $block->{perl};
      my @values = eval $block->perl;
      die "roundtrip_nyn eval perl error: $@" if $@;
      my $config = $block->config || '';
      my $result = eval "$config; Dump(\@values)";
      die "roundtrip_nyn YAML::Dump error: $@" if $@;
      if (exists $block->{yaml}) {
          is $result, $block->yaml,
              $block->description . ' (n->y)';
      }
      else {
          pass $block->description . ' (n->y)';
      }
          
      return if exists $block->{no_round_trip} or
          not exists $block->{yaml};
  
      if ($option eq 'dumper') {
          is dumper(Load($block->yaml)), dumper(@values),
              $block->description . ' (y->n)';
      }
      else {
          is_deeply [Load($block->yaml)], [@values],
              $block->description . ' (y->n)';
      }
  }
  
  sub count_roundtrip_nyn() {
      my $block = shift or die "Bad call to count_roundtrip_nyn";
      return 1 if exists $block->{skip_this_for_now};
      my $count = 0;
      $count++ if exists $block->{perl};
      $count++ unless exists $block->{no_round_trip} or
          not exists $block->{yaml};
      die "Invalid test definition" unless $count;
      return $count;
  }
  
  sub run_load_passes() {
      run {
          my $block = shift;
          my $yaml = $block->yaml;
          eval { YAML(Load => $yaml) };
          is("$@", "");
      };
  }
  
  sub load_passes() {
      my $block = shift;
      my $yaml = $block->yaml;
      eval { YAML(Load => $yaml) };
      is "$@", "", $block->description;
  }
  
  sub count_load_passes() {1}
  
  sub dumper() {
      require Data::Dumper;
      $Data::Dumper::Sortkeys = 1;
      $Data::Dumper::Terse = 1;
      $Data::Dumper::Indent = 1;
      return Data::Dumper::Dumper(@_);
  }
  
  {
      no warnings;
      sub XXX {
          YAML::Base::XXX(@_);
      }
  }
  
  sub _count_tests() {
      my $block = shift or die "Bad call to _count_tests";
      no strict 'refs';
      &{'count_' . _get_function_name($block)}($block);
  }
  
  sub _get_function_name() {
      my $block = shift;
      return $block->function || 'roundtrip_nyn';
  }
  
  sub _get_function() {
      my $block = shift;
      no strict 'refs';
      \ &{_get_function_name($block)};
  }
  
  sub _skip_tests_for_now() {
      my $block = shift;
      if (exists $block->{skip_this_for_now}) {
          _skip_test(
              $block->description,
              _count_tests($block),
          );
          return 1;
      }
      return 0;
  }
  
  sub _skip_yaml_tests() {
      my $block = shift;
      if ($block->skip_unless_modules) {
          my @modules = split /[\s\,]+/, $block->skip_unless_modules;
          for my $module (@modules) {
              eval "require $module";
              if ($@) {
                  _skip_test(
                      "This test requires the '$module' module",
                      _count_tests($block),
                  );
                  return 1;
              }
          }
      }
      return 0;
  }
  
  sub _skip_test() {
      my ($message, $count) = @_;
      SKIP: {
          skip($message, $count);
      }
  }
  
  #-------------------------------------------------------------------------------
  package Test::YAML::Filter;
  
  use Test::Base::Filter ();
  
  our @ISA = 'Test::Base::Filter';
  
  sub yaml_dump {
      Test::YAML::Dump(@_);
  }
  
  sub yaml_load {
      Test::YAML::Load(@_);
  }
  
  sub Dump { goto &Test::YAML::Dump }
  sub Load { goto &Test::YAML::Load }
  sub DumpFile { goto &Test::YAML::DumpFile }
  sub LoadFile { goto &Test::YAML::LoadFile }
  
  sub yaml_load_or_fail {
      my ($result, $error, $warning) =
        $self->_yaml_load_result_error_warning(@_);
      return $error || $result;
  }
  
  sub yaml_load_error_or_warning {
      my ($result, $error, $warning) =
        $self->_yaml_load_result_error_warning(@_);
      return $error || $warning || '';
  }
  
  sub perl_eval_error_or_warning {
      my ($result, $error, $warning) =
        $self->_perl_eval_result_error_warning(@_);
      return $error || $warning || '';
  }
  
  sub _yaml_load_result_error_warning {
      $self->assert_scalar(@_);
      my $yaml = shift;
      my $warning = '';
      local $SIG{__WARN__} = sub { $warning = join '', @_ };
      my $result = eval {
          $self->yaml_load($yaml);
      };
      return ($result, $@, $warning);
  }
  
  sub _perl_eval_result_error_warning {
      $self->assert_scalar(@_);
      my $perl = shift;
      my $warning = '';
      local $SIG{__WARN__} = sub { $warning = join '', @_ };
      my $result = eval $perl;
      return ($result, $@, $warning);
  }
  
  1;
  
  =head1 NAME
  
  Test::YAML - Testing Module for YAML Implementations
  
  =head1 SYNOPSIS
  
      use Test::YAML tests => 1;
  
      pass;
  
  =head1 DESCRIPTION
  
  Test::YAML is a subclass of Test::Base with YAML specific support.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
TEST_YAML

$fatpacked{"Text/Glob.pm"} = <<'TEXT_GLOB';
  package Text::Glob;
  use strict;
  use Exporter;
  use vars qw/$VERSION @ISA @EXPORT_OK
              $strict_leading_dot $strict_wildcard_slash/;
  $VERSION = '0.09';
  @ISA = 'Exporter';
  @EXPORT_OK = qw( glob_to_regex glob_to_regex_string match_glob );
  
  $strict_leading_dot    = 1;
  $strict_wildcard_slash = 1;
  
  use constant debug => 0;
  
  sub glob_to_regex {
      my $glob = shift;
      my $regex = glob_to_regex_string($glob);
      return qr/^$regex$/;
  }
  
  sub glob_to_regex_string
  {
      my $glob = shift;
      my ($regex, $in_curlies, $escaping);
      local $_;
      my $first_byte = 1;
      for ($glob =~ m/(.)/gs) {
          if ($first_byte) {
              if ($strict_leading_dot) {
                  $regex .= '(?=[^\.])' unless $_ eq '.';
              }
              $first_byte = 0;
          }
          if ($_ eq '/') {
              $first_byte = 1;
          }
          if ($_ eq '.' || $_ eq '(' || $_ eq ')' || $_ eq '|' ||
              $_ eq '+' || $_ eq '^' || $_ eq '$' || $_ eq '@' || $_ eq '%' ) {
              $regex .= "\\$_";
          }
          elsif ($_ eq '*') {
              $regex .= $escaping ? "\\*" :
                $strict_wildcard_slash ? "[^/]*" : ".*";
          }
          elsif ($_ eq '?') {
              $regex .= $escaping ? "\\?" :
                $strict_wildcard_slash ? "[^/]" : ".";
          }
          elsif ($_ eq '{') {
              $regex .= $escaping ? "\\{" : "(";
              ++$in_curlies unless $escaping;
          }
          elsif ($_ eq '}' && $in_curlies) {
              $regex .= $escaping ? "}" : ")";
              --$in_curlies unless $escaping;
          }
          elsif ($_ eq ',' && $in_curlies) {
              $regex .= $escaping ? "," : "|";
          }
          elsif ($_ eq "\\") {
              if ($escaping) {
                  $regex .= "\\\\";
                  $escaping = 0;
              }
              else {
                  $escaping = 1;
              }
              next;
          }
          else {
              $regex .= $_;
              $escaping = 0;
          }
          $escaping = 0;
      }
      print "# $glob $regex\n" if debug;
  
      return $regex;
  }
  
  sub match_glob {
      print "# ", join(', ', map { "'$_'" } @_), "\n" if debug;
      my $glob = shift;
      my $regex = glob_to_regex $glob;
      local $_;
      grep { $_ =~ $regex } @_;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  Text::Glob - match globbing patterns against text
  
  =head1 SYNOPSIS
  
   use Text::Glob qw( match_glob glob_to_regex );
  
   print "matched\n" if match_glob( "foo.*", "foo.bar" );
  
   # prints foo.bar and foo.baz
   my $regex = glob_to_regex( "foo.*" );
   for ( qw( foo.bar foo.baz foo bar ) ) {
       print "matched: $_\n" if /$regex/;
   }
  
  =head1 DESCRIPTION
  
  Text::Glob implements glob(3) style matching that can be used to match
  against text, rather than fetching names from a filesystem.  If you
  want to do full file globbing use the File::Glob module instead.
  
  =head2 Routines
  
  =over
  
  =item match_glob( $glob, @things_to_test )
  
  Returns the list of things which match the glob from the source list.
  
  =item glob_to_regex( $glob )
  
  Returns a compiled regex which is the equivalent of the globbing
  pattern.
  
  =item glob_to_regex_string( $glob )
  
  Returns a regex string which is the equivalent of the globbing
  pattern.
  
  =back
  
  =head1 SYNTAX
  
  The following metacharacters and rules are respected.
  
  =over
  
  =item C<*> - match zero or more characters
  
  C<a*> matches C<a>, C<aa>, C<aaaa> and many many more.
  
  =item C<?> - match exactly one character
  
  C<a?> matches C<aa>, but not C<a>, or C<aaa>
  
  =item Character sets/ranges
  
  C<example.[ch]> matches C<example.c> and C<example.h>
  
  C<demo.[a-c]> matches C<demo.a>, C<demo.b>, and C<demo.c>
  
  =item alternation
  
  C<example.{foo,bar,baz}> matches C<example.foo>, C<example.bar>, and
  C<example.baz>
  
  =item leading . must be explictly matched
  
  C<*.foo> does not match C<.bar.foo>.  For this you must either specify
  the leading . in the glob pattern (C<.*.foo>), or set
  C<$Text::Glob::strict_leading_dot> to a false value while compiling
  the regex.
  
  =item C<*> and C<?> do not match /
  
  C<*.foo> does not match C<bar/baz.foo>.  For this you must either
  explicitly match the / in the glob (C<*/*.foo>), or set
  C<$Text::Glob::strict_wildcard_slash> to a false value with compiling
  the regex.
  
  =back
  
  =head1 BUGS
  
  The code uses qr// to produce compiled regexes, therefore this module
  requires perl version 5.005_03 or newer.
  
  =head1 AUTHOR
  
  Richard Clamp <richardc@unixbeard.net>
  
  =head1 COPYRIGHT
  
  Copyright (C) 2002, 2003, 2006, 2007 Richard Clamp.  All Rights Reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<File::Glob>, glob(3)
  
  =cut
TEXT_GLOB

$fatpacked{"Try/Tiny.pm"} = <<'TRY_TINY';
  package Try::Tiny;
  
  use strict;
  #use warnings;
  
  use vars qw(@EXPORT @EXPORT_OK $VERSION @ISA);
  
  BEGIN {
  	require Exporter;
  	@ISA = qw(Exporter);
  }
  
  $VERSION = "0.09";
  
  $VERSION = eval $VERSION;
  
  @EXPORT = @EXPORT_OK = qw(try catch finally);
  
  $Carp::Internal{+__PACKAGE__}++;
  
  # Need to prototype as @ not $$ because of the way Perl evaluates the prototype.
  # Keeping it at $$ means you only ever get 1 sub because we need to eval in a list
  # context & not a scalar one
  
  sub try (&;@) {
  	my ( $try, @code_refs ) = @_;
  
  	# we need to save this here, the eval block will be in scalar context due
  	# to $failed
  	my $wantarray = wantarray;
  
  	my ( $catch, @finally );
  
  	# find labeled blocks in the argument list.
  	# catch and finally tag the blocks by blessing a scalar reference to them.
  	foreach my $code_ref (@code_refs) {
  		next unless $code_ref;
  
  		my $ref = ref($code_ref);
  
  		if ( $ref eq 'Try::Tiny::Catch' ) {
  			$catch = ${$code_ref};
  		} elsif ( $ref eq 'Try::Tiny::Finally' ) {
  			push @finally, ${$code_ref};
  		} else {
  			use Carp;
  			confess("Unknown code ref type given '${ref}'. Check your usage & try again");
  		}
  	}
  
  	# save the value of $@ so we can set $@ back to it in the beginning of the eval
  	my $prev_error = $@;
  
  	my ( @ret, $error, $failed );
  
  	# FIXME consider using local $SIG{__DIE__} to accumulate all errors. It's
  	# not perfect, but we could provide a list of additional errors for
  	# $catch->();
  
  	{
  		# localize $@ to prevent clobbering of previous value by a successful
  		# eval.
  		local $@;
  
  		# failed will be true if the eval dies, because 1 will not be returned
  		# from the eval body
  		$failed = not eval {
  			$@ = $prev_error;
  
  			# evaluate the try block in the correct context
  			if ( $wantarray ) {
  				@ret = $try->();
  			} elsif ( defined $wantarray ) {
  				$ret[0] = $try->();
  			} else {
  				$try->();
  			};
  
  			return 1; # properly set $fail to false
  		};
  
  		# copy $@ to $error; when we leave this scope, local $@ will revert $@
  		# back to its previous value
  		$error = $@;
  	}
  
  	# set up a scope guard to invoke the finally block at the end
  	my @guards =
      map { Try::Tiny::ScopeGuard->_new($_, $failed ? $error : ()) }
      @finally;
  
  	# at this point $failed contains a true value if the eval died, even if some
  	# destructor overwrote $@ as the eval was unwinding.
  	if ( $failed ) {
  		# if we got an error, invoke the catch block.
  		if ( $catch ) {
  			# This works like given($error), but is backwards compatible and
  			# sets $_ in the dynamic scope for the body of C<$catch>
  			for ($error) {
  				return $catch->($error);
  			}
  
  			# in case when() was used without an explicit return, the C<for>
  			# loop will be aborted and there's no useful return value
  		}
  
  		return;
  	} else {
  		# no failure, $@ is back to what it was, everything is fine
  		return $wantarray ? @ret : $ret[0];
  	}
  }
  
  sub catch (&;@) {
  	my ( $block, @rest ) = @_;
  
  	return (
  		bless(\$block, 'Try::Tiny::Catch'),
  		@rest,
  	);
  }
  
  sub finally (&;@) {
  	my ( $block, @rest ) = @_;
  
  	return (
  		bless(\$block, 'Try::Tiny::Finally'),
  		@rest,
  	);
  }
  
  {
    package # hide from PAUSE
      Try::Tiny::ScopeGuard;
  
    sub _new {
      shift;
      bless [ @_ ];
    }
  
    sub DESTROY {
      my @guts = @{ shift() };
      my $code = shift @guts;
      $code->(@guts);
    }
  }
  
  __PACKAGE__
  
  __END__
  
  =pod
  
  =head1 NAME
  
  Try::Tiny - minimal try/catch with proper localization of $@
  
  =head1 SYNOPSIS
  
  	# handle errors with a catch handler
  	try {
  		die "foo";
  	} catch {
  		warn "caught error: $_"; # not $@
  	};
  
  	# just silence errors
  	try {
  		die "foo";
  	};
  
  =head1 DESCRIPTION
  
  This module provides bare bones C<try>/C<catch>/C<finally> statements that are designed to
  minimize common mistakes with eval blocks, and NOTHING else.
  
  This is unlike L<TryCatch> which provides a nice syntax and avoids adding
  another call stack layer, and supports calling C<return> from the try block to
  return from the parent subroutine. These extra features come at a cost of a few
  dependencies, namely L<Devel::Declare> and L<Scope::Upper> which are
  occasionally problematic, and the additional catch filtering uses L<Moose>
  type constraints which may not be desirable either.
  
  The main focus of this module is to provide simple and reliable error handling
  for those having a hard time installing L<TryCatch>, but who still want to
  write correct C<eval> blocks without 5 lines of boilerplate each time.
  
  It's designed to work as correctly as possible in light of the various
  pathological edge cases (see L<BACKGROUND>) and to be compatible with any style
  of error values (simple strings, references, objects, overloaded objects, etc).
  
  If the try block dies, it returns the value of the last statement executed in
  the catch block, if there is one. Otherwise, it returns C<undef> in scalar
  context or the empty list in list context. The following two examples both
  assign C<"bar"> to C<$x>.
  
  	my $x = try { die "foo" } catch { "bar" };
  
  	my $x = eval { die "foo" } || "bar";
  
  You can add finally blocks making the following true.
  
  	my $x;
  	try { die 'foo' } finally { $x = 'bar' };
  	try { die 'foo' } catch { warn "Got a die: $_" } finally { $x = 'bar' };
  
  Finally blocks are always executed making them suitable for cleanup code
  which cannot be handled using local.  You can add as many finally blocks to a
  given try block as you like.
  
  =head1 EXPORTS
  
  All functions are exported by default using L<Exporter>.
  
  If you need to rename the C<try>, C<catch> or C<finally> keyword consider using
  L<Sub::Import> to get L<Sub::Exporter>'s flexibility.
  
  =over 4
  
  =item try (&;@)
  
  Takes one mandatory try subroutine, an optional catch subroutine & finally
  subroutine.
  
  The mandatory subroutine is evaluated in the context of an C<eval> block.
  
  If no error occurred the value from the first block is returned, preserving
  list/scalar context.
  
  If there was an error and the second subroutine was given it will be invoked
  with the error in C<$_> (localized) and as that block's first and only
  argument.
  
  C<$@> does B<not> contain the error. Inside the C<catch> block it has the same
  value it had before the C<try> block was executed.
  
  Note that the error may be false, but if that happens the C<catch> block will
  still be invoked.
  
  Once all execution is finished then the finally block if given will execute.
  
  =item catch (&;$)
  
  Intended to be used in the second argument position of C<try>.
  
  Returns a reference to the subroutine it was given but blessed as
  C<Try::Tiny::Catch> which allows try to decode correctly what to do
  with this code reference.
  
  	catch { ... }
  
  Inside the catch block the caught error is stored in C<$_>, while previous
  value of C<$@> is still available for use.  This value may or may not be
  meaningful depending on what happened before the C<try>, but it might be a good
  idea to preserve it in an error stack.
  
  For code that captures C<$@> when throwing new errors (i.e.
  L<Class::Throwable>), you'll need to do:
  
  	local $@ = $_;
  
  =item finally (&;$)
  
    try     { ... }
    catch   { ... }
    finally { ... };
  
  Or
  
    try     { ... }
    finally { ... };
  
  Or even
  
    try     { ... }
    finally { ... }
    catch   { ... };
  
  Intended to be the second or third element of C<try>. Finally blocks are always
  executed in the event of a successful C<try> or if C<catch> is run. This allows
  you to locate cleanup code which cannot be done via C<local()> e.g. closing a file
  handle.
  
  When invoked, the finally block is passed the error that was caught.  If no
  error was caught, it is passed nothing.  In other words, the following code
  does just what you would expect:
  
    try {
      die_sometimes();
    } catch {
      # ...code run in case of error
    } finally {
      if (@_) {
        print "The try block died with: @_\n";
      } else {
        print "The try block ran without error.\n";
      }
    };
  
  B<You must always do your own error handling in the finally block>. C<Try::Tiny> will
  not do anything about handling possible errors coming from code located in these
  blocks.
  
  In the same way C<catch()> blesses the code reference this subroutine does the same
  except it bless them as C<Try::Tiny::Finally>.
  
  =back
  
  =head1 BACKGROUND
  
  There are a number of issues with C<eval>.
  
  =head2 Clobbering $@
  
  When you run an eval block and it succeeds, C<$@> will be cleared, potentially
  clobbering an error that is currently being caught.
  
  This causes action at a distance, clearing previous errors your caller may have
  not yet handled.
  
  C<$@> must be properly localized before invoking C<eval> in order to avoid this
  issue.
  
  More specifically, C<$@> is clobbered at the beginning of the C<eval>, which
  also makes it impossible to capture the previous error before you die (for
  instance when making exception objects with error stacks).
  
  For this reason C<try> will actually set C<$@> to its previous value (before
  the localization) in the beginning of the C<eval> block.
  
  =head2 Localizing $@ silently masks errors
  
  Inside an eval block C<die> behaves sort of like:
  
  	sub die {
  		$@ = $_[0];
  		return_undef_from_eval();
  	}
  
  This means that if you were polite and localized C<$@> you can't die in that
  scope, or your error will be discarded (printing "Something's wrong" instead).
  
  The workaround is very ugly:
  
  	my $error = do {
  		local $@;
  		eval { ... };
  		$@;
  	};
  
  	...
  	die $error;
  
  =head2 $@ might not be a true value
  
  This code is wrong:
  
  	if ( $@ ) {
  		...
  	}
  
  because due to the previous caveats it may have been unset.
  
  C<$@> could also be an overloaded error object that evaluates to false, but
  that's asking for trouble anyway.
  
  The classic failure mode is:
  
  	sub Object::DESTROY {
  		eval { ... }
  	}
  
  	eval {
  		my $obj = Object->new;
  
  		die "foo";
  	};
  
  	if ( $@ ) {
  
  	}
  
  In this case since C<Object::DESTROY> is not localizing C<$@> but still uses
  C<eval>, it will set C<$@> to C<"">.
  
  The destructor is called when the stack is unwound, after C<die> sets C<$@> to
  C<"foo at Foo.pm line 42\n">, so by the time C<if ( $@ )> is evaluated it has
  been cleared by C<eval> in the destructor.
  
  The workaround for this is even uglier than the previous ones. Even though we
  can't save the value of C<$@> from code that doesn't localize, we can at least
  be sure the eval was aborted due to an error:
  
  	my $failed = not eval {
  		...
  
  		return 1;
  	};
  
  This is because an C<eval> that caught a C<die> will always return a false
  value.
  
  =head1 SHINY SYNTAX
  
  Using Perl 5.10 you can use L<perlsyn/"Switch statements">.
  
  The C<catch> block is invoked in a topicalizer context (like a C<given> block),
  but note that you can't return a useful value from C<catch> using the C<when>
  blocks without an explicit C<return>.
  
  This is somewhat similar to Perl 6's C<CATCH> blocks. You can use it to
  concisely match errors:
  
  	try {
  		require Foo;
  	} catch {
  		when (/^Can't locate .*?\.pm in \@INC/) { } # ignore
  		default { die $_ }
  	};
  
  =head1 CAVEATS
  
  =over 4
  
  =item *
  
  C<@_> is not available within the C<try> block, so you need to copy your
  arglist. In case you want to work with argument values directly via C<@_>
  aliasing (i.e. allow C<$_[1] = "foo">), you need to pass C<@_> by reference:
  
  	sub foo {
  		my ( $self, @args ) = @_;
  		try { $self->bar(@args) }
  	}
  
  or
  
  	sub bar_in_place {
  		my $self = shift;
  		my $args = \@_;
  		try { $_ = $self->bar($_) for @$args }
  	}
  
  =item *
  
  C<return> returns from the C<try> block, not from the parent sub (note that
  this is also how C<eval> works, but not how L<TryCatch> works):
  
  	sub bar {
  		try { return "foo" };
  		return "baz";
  	}
  
  	say bar(); # "baz"
  
  =item *
  
  C<try> introduces another caller stack frame. L<Sub::Uplevel> is not used. L<Carp>
  will not report this when using full stack traces, though, because
  C<%Carp::Internal> is used. This lack of magic is considered a feature.
  
  =item *
  
  The value of C<$_> in the C<catch> block is not guaranteed to be the value of
  the exception thrown (C<$@>) in the C<try> block.  There is no safe way to
  ensure this, since C<eval> may be used unhygenically in destructors.  The only
  guarantee is that the C<catch> will be called if an exception is thrown.
  
  =item *
  
  The return value of the C<catch> block is not ignored, so if testing the result
  of the expression for truth on success, be sure to return a false value from
  the C<catch> block:
  
  	my $obj = try {
  		MightFail->new;
  	} catch {
  		...
  
  		return; # avoid returning a true value;
  	};
  
  	return unless $obj;
  
  =item *
  
  C<$SIG{__DIE__}> is still in effect.
  
  Though it can be argued that C<$SIG{__DIE__}> should be disabled inside of
  C<eval> blocks, since it isn't people have grown to rely on it. Therefore in
  the interests of compatibility, C<try> does not disable C<$SIG{__DIE__}> for
  the scope of the error throwing code.
  
  =item *
  
  Lexical C<$_> may override the one set by C<catch>.
  
  For example Perl 5.10's C<given> form uses a lexical C<$_>, creating some
  confusing behavior:
  
  	given ($foo) {
  		when (...) {
  			try {
  				...
  			} catch {
  				warn $_; # will print $foo, not the error
  				warn $_[0]; # instead, get the error like this
  			}
  		}
  	}
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item L<TryCatch>
  
  Much more feature complete, more convenient semantics, but at the cost of
  implementation complexity.
  
  =item L<autodie>
  
  Automatic error throwing for builtin functions and more. Also designed to
  work well with C<given>/C<when>.
  
  =item L<Throwable>
  
  A lightweight role for rolling your own exception classes.
  
  =item L<Error>
  
  Exception object implementation with a C<try> statement. Does not localize
  C<$@>.
  
  =item L<Exception::Class::TryCatch>
  
  Provides a C<catch> statement, but properly calling C<eval> is your
  responsibility.
  
  The C<try> keyword pushes C<$@> onto an error stack, avoiding some of the
  issues with C<$@>, but you still need to localize to prevent clobbering.
  
  =back
  
  =head1 LIGHTNING TALK
  
  I gave a lightning talk about this module, you can see the slides (Firefox
  only):
  
  L<http://nothingmuch.woobling.org/talks/takahashi.xul?data=yapc_asia_2009/try_tiny.txt>
  
  Or read the source:
  
  L<http://nothingmuch.woobling.org/talks/yapc_asia_2009/try_tiny.yml>
  
  =head1 VERSION CONTROL
  
  L<http://github.com/nothingmuch/try-tiny/>
  
  =head1 AUTHOR
  
  Yuval Kogman E<lt>nothingmuch@woobling.orgE<gt>
  
  =head1 COPYRIGHT
  
  	Copyright (c) 2009 Yuval Kogman. All rights reserved.
  	This program is free software; you can redistribute
  	it and/or modify it under the terms of the MIT license.
  
  =cut
  
TRY_TINY

$fatpacked{"YAML.pm"} = <<'YAML';
  package YAML;
  
  use 5.008001;
  use strict;
  use warnings;
  use YAML::Base;
  use YAML::Node; # XXX This is a temp fix for Module::Build
  
  our $VERSION   = '0.72';
  our @ISA       = 'YAML::Base';
  our @EXPORT    = qw{ Dump Load };
  our @EXPORT_OK = qw{ freeze thaw DumpFile LoadFile Bless Blessed };
  
  # XXX This VALUE nonsense needs to go.
  use constant VALUE => "\x07YAML\x07VALUE\x07";
  
  # YAML Object Properties
  field dumper_class => 'YAML::Dumper';
  field loader_class => 'YAML::Loader';
  field dumper_object =>
      -init => '$self->init_action_object("dumper")';
  field loader_object =>
      -init => '$self->init_action_object("loader")';
  
  sub Dump {
      my $yaml = YAML->new;
      $yaml->dumper_class($YAML::DumperClass)
          if $YAML::DumperClass;
      return $yaml->dumper_object->dump(@_);
  }
  
  sub Load {
      my $yaml = YAML->new;
      $yaml->loader_class($YAML::LoaderClass)
          if $YAML::LoaderClass;
      return $yaml->loader_object->load(@_);
  }
  
  {
      no warnings 'once';
      # freeze/thaw is the API for Storable string serialization. Some
      # modules make use of serializing packages on if they use freeze/thaw.
      *freeze = \ &Dump;
      *thaw   = \ &Load;
  }
  
  sub DumpFile {
      my $OUT;
      my $filename = shift;
      if (ref $filename eq 'GLOB') {
          $OUT = $filename;
      }
      else {
          my $mode = '>';
          if ($filename =~ /^\s*(>{1,2})\s*(.*)$/) {
              ($mode, $filename) = ($1, $2);
          }
          open $OUT, $mode, $filename
            or YAML::Base->die('YAML_DUMP_ERR_FILE_OUTPUT', $filename, $!);
      }
      binmode $OUT, ':utf8';  # if $Config{useperlio} eq 'define';
      local $/ = "\n"; # reset special to "sane"
      print $OUT Dump(@_);
  }
  
  sub LoadFile {
      my $IN;
      my $filename = shift;
      if (ref $filename eq 'GLOB') {
          $IN = $filename;
      }
      else {
          open $IN, '<', $filename
            or YAML::Base->die('YAML_LOAD_ERR_FILE_INPUT', $filename, $!);
      }
      binmode $IN, ':utf8';  # if $Config{useperlio} eq 'define';
      return Load(do { local $/; <$IN> });
  }
  
  sub init_action_object {
      my $self = shift;
      my $object_class = (shift) . '_class';
      my $module_name = $self->$object_class;
      eval "require $module_name";
      $self->die("Error in require $module_name - $@")
          if $@ and "$@" !~ /Can't locate/;
      my $object = $self->$object_class->new;
      $object->set_global_options;
      return $object;
  }
  
  my $global = {};
  sub Bless {
      require YAML::Dumper::Base;
      YAML::Dumper::Base::bless($global, @_)
  }
  sub Blessed {
      require YAML::Dumper::Base;
      YAML::Dumper::Base::blessed($global, @_)
  }
  sub global_object { $global }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  YAML - YAML Ain't Markup Language (tm)
  
  =head1 NOTE
  
  This module has been released to CPAN as YAML::Old, and soon YAML.pm
  will be changed to just be a frontend interface module for all the
  various Perl YAML implementation modules, including YAML::Old.
  
  If you want robust and fast YAML processing using the normal Dump/Load
  API, please consider switching to YAML::XS. It is by far the best Perl
  module for YAML at this time. It requires that you have a C compiler,
  since it is written in C.
  
  If you really need to use this version of YAML.pm it will always be
  available as YAML::Old.
  
  If you don't care which YAML module use, as long as it's the best one
  installed on your system, use YAML::Any.
  
  The rest of this documentation is left unchanged, until YAML.pm is
  switched over to the new UI-only version.
  
  =head1 SYNOPSIS
  
      use YAML;
      
      # Load a YAML stream of 3 YAML documents into Perl data structures.
      my ($hashref, $arrayref, $string) = Load(<<'...');
      ---
      name: ingy
      age: old
      weight: heavy
      # I should comment that I also like pink, but don't tell anybody.
      favorite colors:
          - red
          - green
          - blue
      ---
      - Clark Evans
      - Oren Ben-Kiki
      - Ingy dt Net
      --- >
      You probably think YAML stands for "Yet Another Markup Language". It
      ain't! YAML is really a data serialization language. But if you want
      to think of it as a markup, that's OK with me. A lot of people try
      to use XML as a serialization format.
      
      "YAML" is catchy and fun to say. Try it. "YAML, YAML, YAML!!!"
      ...
      
      # Dump the Perl data structures back into YAML.
      print Dump($string, $arrayref, $hashref);
      
      # YAML::Dump is used the same way you'd use Data::Dumper::Dumper
      use Data::Dumper;
      print Dumper($string, $arrayref, $hashref);
  
  =head1 DESCRIPTION
  
  The YAML.pm module implements a YAML Loader and Dumper based on the YAML
  1.0 specification. L<http://www.yaml.org/spec/>
  
  YAML is a generic data serialization language that is optimized for
  human readability. It can be used to express the data structures of most
  modern programming languages. (Including Perl!!!)
  
  For information on the YAML syntax, please refer to the YAML
  specification.
  
  =head1 WHY YAML IS COOL
  
  =over 4
  
  =item YAML is readable for people.
  
  It makes clear sense out of complex data structures. You should find
  that YAML is an exceptional data dumping tool. Structure is shown
  through indentation, YAML supports recursive data, and hash keys are
  sorted by default. In addition, YAML supports several styles of scalar
  formatting for different types of data.
  
  =item YAML is editable.
  
  YAML was designed from the ground up to be an excellent syntax for
  configuration files. Almost all programs need configuration files, so
  why invent a new syntax for each one? And why subject users to the
  complexities of XML or native Perl code?
  
  =item YAML is multilingual.
  
  Yes, YAML supports Unicode. But I'm actually referring to programming
  languages. YAML was designed to meet the serialization needs of Perl,
  Python, Ruby, Tcl, PHP, Javascript and Java. It was also designed to be
  interoperable between those languages. That means YAML serializations
  produced by Perl can be processed by Python.
  
  =item YAML is taint safe.
  
  Using modules like Data::Dumper for serialization is fine as long as you
  can be sure that nobody can tamper with your data files or
  transmissions. That's because you need to use Perl's C<eval()> built-in
  to deserialize the data. Somebody could add a snippet of Perl to erase
  your files.
  
  YAML's parser does not need to eval anything.
  
  =item YAML is full featured.
  
  YAML can accurately serialize all of the common Perl data structures and
  deserialize them again without losing data relationships. Although it is
  not 100% perfect (no serializer is or can be perfect), it fares as well
  as the popular current modules: Data::Dumper, Storable, XML::Dumper and
  Data::Denter.
  
  YAML.pm also has the ability to handle code (subroutine) references and
  typeglobs. (Still experimental) These features are not found in Perl's
  other serialization modules.
  
  =item YAML is extensible.
  
  The YAML language has been designed to be flexible enough to solve it's
  own problems. The markup itself has 3 basic construct which resemble
  Perl's hash, array and scalar. By default, these map to their Perl
  equivalents. But each YAML node also supports a tagging mechanism (type
  system) which can cause that node to be interpreted in a completely
  different manner. That's how YAML can support object serialization and
  oddball structures like Perl's typeglob.
  
  =back
  
  =head1 YAML IMPLEMENTATIONS IN PERL
  
  This module, YAML.pm, is really just the interface module for YAML
  modules written in Perl. The basic interface for YAML consists of two
  functions: C<Dump> and C<Load>. The real work is done by the modules
  YAML::Dumper and YAML::Loader.
  
  Different YAML module distributions can be created by subclassing
  YAML.pm and YAML::Loader and YAML::Dumper. For example, YAML-Simple
  consists of YAML::Simple YAML::Dumper::Simple and YAML::Loader::Simple.
  
  Why would there be more than one implementation of YAML? Well, despite
  YAML's offering of being a simple data format, YAML is actually very
  deep and complex. Implementing the entirety of the YAML specification is
  a daunting task.
  
  For this reason I am currently working on 3 different YAML implementations.
  
  =over
  
  =item YAML
  
  The main YAML distribution will keeping evolving to support the entire
  YAML specification in pure Perl. This may not be the fastest or most
  stable module though. Currently, YAML.pm has lots of known bugs. It is
  mostly a great tool for dumping Perl data structures to a readable form.
  
  =item YAML::Tiny
  
  The point of YAML::Tiny is to strip YAML down to the 90% that people
  use most and offer that in a small, fast, stable, pure Perl form.
  YAML::Tiny will simply die when it is asked to do something it can't.
  
  =item YAML::Syck
  
  C<libsyck> is the C based YAML processing library used by the Ruby
  programming language (and also Python, PHP and Pugs). YAML::Syck is the
  Perl binding to C<libsyck>. It should be very fast, but may have
  problems of its own. It will also require C compilation.
  
  NOTE: Audrey Tang has actually completed this module and it works great
        and is 10 times faster than YAML.pm.
  
  =back
  
  In the future, there will likely be even more YAML modules. Remember,
  people other than Ingy are allowed to write YAML modules!
  
  =head1 FUNCTIONAL USAGE
  
  YAML is completely OO under the hood. Still it exports a few useful top
  level functions so that it is dead simple to use. These functions just
  do the OO stuff for you. If you want direct access to the OO API see the
  documentation for YAML::Dumper and YAML::Loader.
  
  =head2 Exported Functions
  
  The following functions are exported by YAML.pm by default. The reason
  they are exported is so that YAML works much like Data::Dumper. If you
  don't want functions to be imported, just use YAML with an empty
  import list:
  
      use YAML ();
  
  =over 4
  
  =item Dump(list-of-Perl-data-structures)
  
  Turn Perl data into YAML. This function works very much like
  Data::Dumper::Dumper(). It takes a list of Perl data strucures and
  dumps them into a serialized form. It returns a string containing the
  YAML stream. The structures can be references or plain scalars.
  
  =item Load(string-containing-a-YAML-stream)
  
  Turn YAML into Perl data. This is the opposite of Dump. Just like
  Storable's thaw() function or the eval() function in relation to
  Data::Dumper. It parses a string containing a valid YAML stream into a
  list of Perl data structures.
  
  =back
  
  =head2 Exportable Functions
  
  These functions are not exported by default but you can request them in
  an import list like this:
  
      use YAML qw'freeze thaw Bless';
  
  =over 4
  
  =item freeze() and thaw()
  
  Aliases to Dump() and Load() for Storable fans. This will also allow
  YAML.pm to be plugged directly into modules like POE.pm, that use the
  freeze/thaw API for internal serialization.
  
  =item DumpFile(filepath, list)
  
  Writes the YAML stream to a file instead of just returning a string.
  
  =item LoadFile(filepath)
  
  Reads the YAML stream from a file instead of a string.
  
  =item Bless(perl-node, [yaml-node | class-name])
  
  Associate a normal Perl node, with a yaml node. A yaml node is an object
  tied to the YAML::Node class. The second argument is either a yaml node
  that you've already created or a class (package) name that supports a
  yaml_dump() function. A yaml_dump() function should take a perl node and
  return a yaml node. If no second argument is provided, Bless will create
  a yaml node. This node is not returned, but can be retrieved with the
  Blessed() function.
  
  Here's an example of how to use Bless. Say you have a hash containing
  three keys, but you only want to dump two of them. Furthermore the keys
  must be dumped in a certain order. Here's how you do that:
  
      use YAML qw(Dump Bless);
      $hash = {apple => 'good', banana => 'bad', cauliflower => 'ugly'};
      print Dump $hash;
      Bless($hash)->keys(['banana', 'apple']);
      print Dump $hash;
  
  produces:
  
      ---
      apple: good
      banana: bad
      cauliflower: ugly
      ---
      banana: bad
      apple: good
  
  Bless returns the tied part of a yaml-node, so that you can call the
  YAML::Node methods. This is the same thing that YAML::Node::ynode()
  returns. So another way to do the above example is:
  
      use YAML qw(Dump Bless);
      use YAML::Node;
      $hash = {apple => 'good', banana => 'bad', cauliflower => 'ugly'};
      print Dump $hash;
      Bless($hash);
      $ynode = ynode(Blessed($hash));
      $ynode->keys(['banana', 'apple']);
      print Dump $hash;
  
  Note that Blessing a Perl data structure does not change it anyway. The
  extra information is stored separately and looked up by the Blessed
  node's memory address.
  
  =item Blessed(perl-node)
  
  Returns the yaml node that a particular perl node is associated with
  (see above). Returns undef if the node is not (YAML) Blessed.
  
  =back
  
  =head1 GLOBAL OPTIONS
  
  YAML options are set using a group of global variables in the YAML
  namespace. This is similar to how Data::Dumper works.
  
  For example, to change the indentation width, do something like:
  
      local $YAML::Indent = 3;
  
  The current options are:
  
  =over 4
  
  =item DumperClass
  
  You can override which module/class YAML uses for Dumping data.
  
  =item LoaderClass
  
  You can override which module/class YAML uses for Loading data.
  
  =item Indent
  
  This is the number of space characters to use for each indentation level
  when doing a Dump(). The default is 2.
  
  By the way, YAML can use any number of characters for indentation at any
  level. So if you are editing YAML by hand feel free to do it anyway that
  looks pleasing to you; just be consistent for a given level.
  
  =item SortKeys
  
  Default is 1. (true)
  
  Tells YAML.pm whether or not to sort hash keys when storing a document.
  
  YAML::Node objects can have their own sort order, which is usually what
  you want. To override the YAML::Node order and sort the keys anyway, set
  SortKeys to 2.
  
  =item Stringify
  
  Default is 0. (false)
  
  Objects with string overloading should honor the overloading and dump the
  stringification of themselves, rather than the actual object's guts.
  
  =item UseHeader
  
  Default is 1. (true)
  
  This tells YAML.pm whether to use a separator string for a Dump
  operation. This only applies to the first document in a stream.
  Subsequent documents must have a YAML header by definition.
  
  =item UseVersion
  
  Default is 0. (false)
  
  Tells YAML.pm whether to include the YAML version on the
  separator/header.
  
      --- %YAML:1.0
  
  =item AnchorPrefix
  
  Default is ''.
  
  Anchor names are normally numeric. YAML.pm simply starts with '1' and
  increases by one for each new anchor. This option allows you to specify a
  string to be prepended to each anchor number.
  
  =item UseCode
  
  Setting the UseCode option is a shortcut to set both the DumpCode and
  LoadCode options at once. Setting UseCode to '1' tells YAML.pm to dump
  Perl code references as Perl (using B::Deparse) and to load them back
  into memory using eval(). The reason this has to be an option is that
  using eval() to parse untrusted code is, well, untrustworthy.
  
  =item DumpCode
  
  Determines if and how YAML.pm should serialize Perl code references. By
  default YAML.pm will dump code references as dummy placeholders (much
  like Data::Dumper). If DumpCode is set to '1' or 'deparse', code
  references will be dumped as actual Perl code.
  
  DumpCode can also be set to a subroutine reference so that you can
  write your own serializing routine. YAML.pm passes you the code ref. You
  pass back the serialization (as a string) and a format indicator. The
  format indicator is a simple string like: 'deparse' or 'bytecode'.
  
  =item LoadCode
  
  LoadCode is the opposite of DumpCode. It tells YAML if and how to
  deserialize code references. When set to '1' or 'deparse' it will use
  C<eval()>. Since this is potentially risky, only use this option if you
  know where your YAML has been.
  
  LoadCode can also be set to a subroutine reference so that you can write
  your own deserializing routine. YAML.pm passes the serialization (as a
  string) and a format indicator. You pass back the code reference.
  
  =item UseBlock
  
  YAML.pm uses heuristics to guess which scalar style is best for a given
  node. Sometimes you'll want all multiline scalars to use the 'block'
  style. If so, set this option to 1.
  
  NOTE: YAML's block style is akin to Perl's here-document.
  
  =item UseFold
  
  If you want to force YAML to use the 'folded' style for all multiline
  scalars, then set $UseFold to 1.
  
  NOTE: YAML's folded style is akin to the way HTML folds text,
        except smarter.
  
  =item UseAliases
  
  YAML has an alias mechanism such that any given structure in memory gets
  serialized once. Any other references to that structure are serialized
  only as alias markers. This is how YAML can serialize duplicate and
  recursive structures.
  
  Sometimes, when you KNOW that your data is nonrecursive in nature, you
  may want to serialize such that every node is expressed in full. (ie as
  a copy of the original). Setting $YAML::UseAliases to 0 will allow you
  to do this. This also may result in faster processing because the lookup
  overhead is by bypassed.
  
  THIS OPTION CAN BE DANGEROUS. *If* your data is recursive, this option
  *will* cause Dump() to run in an endless loop, chewing up your computers
  memory. You have been warned.
  
  =item CompressSeries
  
  Default is 1.
  
  Compresses the formatting of arrays of hashes:
  
      -
        foo: bar
      - 
        bar: foo
  
  becomes:
  
      - foo: bar
      - bar: foo
  
  Since this output is usually more desirable, this option is turned on by
  default.
  
  =back
  
  =head1 YAML TERMINOLOGY
  
  YAML is a full featured data serialization language, and thus has its
  own terminology.
  
  It is important to remember that although YAML is heavily influenced by
  Perl and Python, it is a language in its own right, not merely just a
  representation of Perl structures.
  
  YAML has three constructs that are conspicuously similar to Perl's hash,
  array, and scalar. They are called mapping, sequence, and string
  respectively. By default, they do what you would expect. But each
  instance may have an explicit or implicit tag (type) that makes it
  behave differently. In this manner, YAML can be extended to represent
  Perl's Glob or Python's tuple, or Ruby's Bigint.
  
  =over 4
  
  =item stream
  
  A YAML stream is the full sequence of unicode characters that a YAML
  parser would read or a YAML emitter would write. A stream may contain
  one or more YAML documents separated by YAML headers.
  
      ---
      a: mapping
      foo: bar
      ---
      - a
      - sequence
  
  =item document
  
  A YAML document is an independent data structure representation within a
  stream. It is a top level node. Each document in a YAML stream must
  begin with a YAML header line. Actually the header is optional on the
  first document.
  
      ---
      This: top level mapping
      is:
          - a
          - YAML
          - document
  
  =item header
  
  A YAML header is a line that begins a YAML document. It consists of
  three dashes, possibly followed by more info. Another purpose of the
  header line is that it serves as a place to put top level tag and anchor
  information.
  
      --- !recursive-sequence &001
      - * 001
      - * 001
  
  =item node
  
  A YAML node is the representation of a particular data stucture. Nodes
  may contain other nodes. (In Perl terms, nodes are like scalars.
  Strings, arrayrefs and hashrefs. But this refers to the serialized
  format, not the in-memory structure.)
  
  =item tag
  
  This is similar to a type. It indicates how a particular YAML node
  serialization should be transferred into or out of memory. For instance
  a Foo::Bar object would use the tag 'perl/Foo::Bar':
  
      - !perl/Foo::Bar
          foo: 42
          bar: stool
  
  =item collection
  
  A collection is the generic term for a YAML data grouping. YAML has two
  types of collections: mappings and sequences. (Similar to hashes and arrays)
  
  =item mapping
  
  A mapping is a YAML collection defined by unordered key/value pairs with
  unique keys. By default YAML mappings are loaded into Perl hashes.
  
      a mapping:
          foo: bar
          two: times two is 4
  
  =item sequence
  
  A sequence is a YAML collection defined by an ordered list of elements. By
  default YAML sequences are loaded into Perl arrays.
  
      a sequence:
          - one bourbon
          - one scotch
          - one beer
  
  =item scalar
  
  A scalar is a YAML node that is a single value. By default YAML scalars
  are loaded into Perl scalars.
  
      a scalar key: a scalar value
  
  YAML has many styles for representing scalars. This is important because
  varying data will have varying formatting requirements to retain the
  optimum human readability.
  
  =item plain scalar
  
  A plain sclar is unquoted. All plain scalars are automatic candidates
  for "implicit tagging". This means that their tag may be determined
  automatically by examination. The typical uses for this are plain alpha
  strings, integers, real numbers, dates, times and currency.
  
      - a plain string
      - -42
      - 3.1415
      - 12:34
      - 123 this is an error
  
  =item single quoted scalar
  
  This is similar to Perl's use of single quotes. It means no escaping
  except for single quotes which are escaped by using two adjacent
  single quotes.
  
      - 'When I say ''\n'' I mean "backslash en"'
  
  =item double quoted scalar
  
  This is similar to Perl's use of double quotes. Character escaping can
  be used.
  
      - "This scalar\nhas two lines, and a bell -->\a"
  
  =item folded scalar
  
  This is a multiline scalar which begins on the next line. It is
  indicated by a single right angle bracket. It is unescaped like the
  single quoted scalar. Line folding is also performed.
  
      - > 
       This is a multiline scalar which begins on
       the next line. It is indicated by a single
       carat. It is unescaped like the single
       quoted scalar. Line folding is also
       performed.
  
  =item block scalar
  
  This final multiline form is akin to Perl's here-document except that
  (as in all YAML data) scope is indicated by indentation. Therefore, no
  ending marker is required. The data is verbatim. No line folding.
  
      - |
          QTY  DESC          PRICE  TOTAL
          ---  ----          -----  -----
            1  Foo Fighters  $19.95 $19.95
            2  Bar Belles    $29.95 $59.90
  
  =item parser
  
  A YAML processor has four stages: parse, load, dump, emit.
  
  A parser parses a YAML stream. YAML.pm's Load() function contains a
  parser.
  
  =item loader
  
  The other half of the Load() function is a loader. This takes the
  information from the parser and loads it into a Perl data structure.
  
  =item dumper
  
  The Dump() function consists of a dumper and an emitter. The dumper
  walks through each Perl data structure and gives info to the emitter.
  
  =item emitter
  
  The emitter takes info from the dumper and turns it into a YAML stream.
  
  NOTE:
  In YAML.pm the parser/loader and the dumper/emitter code are currently
  very closely tied together. In the future they may be broken into
  separate stages.
  
  =back
  
  For more information please refer to the immensely helpful YAML
  specification available at L<http://www.yaml.org/spec/>.
  
  =head1 ysh - The YAML Shell
  
  The YAML distribution ships with a script called 'ysh', the YAML shell.
  ysh provides a simple, interactive way to play with YAML. If you type in
  Perl code, it displays the result in YAML. If you type in YAML it turns
  it into Perl code.
  
  To run ysh, (assuming you installed it along with YAML.pm) simply type:
  
      ysh [options]
  
  Please read the C<ysh> documentation for the full details. There are
  lots of options.
  
  =head1 BUGS & DEFICIENCIES
  
  If you find a bug in YAML, please try to recreate it in the YAML Shell
  with logging turned on ('ysh -L'). When you have successfully reproduced
  the bug, please mail the LOG file to the author (ingy@cpan.org).
  
  WARNING: This is still *ALPHA* code. Well, most of this code has been
  around for years...
  
  BIGGER WARNING: YAML.pm has been slow in the making, but I am committed
  to having top notch YAML tools in the Perl world. The YAML team is close
  to finalizing the YAML 1.1 spec. This version of YAML.pm is based off of
  a very old pre 1.0 spec. In actuality there isn't a ton of difference,
  and this YAML.pm is still fairly useful. Things will get much better in
  the future.
  
  =head1 RESOURCES
  
  L<http://lists.sourceforge.net/lists/listinfo/yaml-core> is the mailing
  list. This is where the language is discussed and designed.
  
  L<http://www.yaml.org> is the official YAML website.
  
  L<http://www.yaml.org/spec/> is the YAML 1.0 specification.
  
  L<http://yaml.kwiki.org> is the official YAML wiki.
  
  =head1 SEE ALSO
  
  See YAML::Syck. Fast!
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  is resonsible for YAML.pm.
  
  The YAML serialization language is the result of years of collaboration
  between Oren Ben-Kiki, Clark Evans and Ingy dE<ouml>t Net. Several others
  have added help along the way.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005, 2006, 2008. Ingy dE<ouml>t Net.
  
  Copyright (c) 2001, 2002, 2005. Brian Ingerson.
  
  Some parts copyright (c) 2009 - 2010 Adam Kennedy
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML

$fatpacked{"YAML/Any.pm"} = <<'YAML_ANY';
  package YAML::Any;
  
  use 5.005003;
  use strict;
  use Exporter ();
  
  $YAML::Any::VERSION   = '0.72';
  @YAML::Any::ISA       = 'Exporter';
  @YAML::Any::EXPORT    = qw(Dump Load);
  @YAML::Any::EXPORT_OK = qw(DumpFile LoadFile);
  
  my @dump_options = qw(
      UseCode
      DumpCode
      SpecVersion
      Indent
      UseHeader
      UseVersion
      SortKeys
      AnchorPrefix
      UseBlock
      UseFold
      CompressSeries
      InlineSeries
      UseAliases
      Purity
      Stringify
  );
  
  my @load_options = qw(
      UseCode
      LoadCode
  );
  
  my @implementations = qw(
      YAML::XS
      YAML::Syck
      YAML::Old
      YAML
      YAML::Tiny
  );
  
  sub import {
      __PACKAGE__->implementation;
      goto &Exporter::import;
  }
  
  sub Dump {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@dump_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::Dump"}(@_);
  }
  
  sub DumpFile {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@dump_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::DumpFile"}(@_);
  }
  
  sub Load {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@load_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::Load"}(@_);
  }
  
  sub LoadFile {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@load_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::LoadFile"}(@_);
  }
  
  sub order {
      return @YAML::Any::_TEST_ORDER
          if defined @YAML::Any::_TEST_ORDER;
      return @implementations;
  }
  
  sub implementation {
      my @order = __PACKAGE__->order;
      for my $module (@order) {
          my $path = $module;
          $path =~ s/::/\//g;
          $path .= '.pm';
          return $module if exists $INC{$path};
          eval "require $module; 1" and return $module;
      }
      croak("YAML::Any couldn't find any of these YAML implementations: @order");
  }
  
  sub croak {
      require Carp;
      Carp::Croak(@_);
  }
  
  1;
  
  =head1 NAME
  
  YAML::Any - Pick a YAML implementation and use it.
  
  =head1 SYNOPSIS
  
      use YAML::Any;
      $YAML::Indent = 3;
      my $yaml = Dump(@objects);
  
  =head1 DESCRIPTION
  
  There are several YAML implementations that support the Dump/Load API.
  This module selects the best one available and uses it.
  
  =head1 ORDER
  
  Currently, YAML::Any will choose the first one of these YAML
  implementations that is installed on your system:
  
      YAML::XS
      YAML::Syck
      YAML::Old
      YAML
      YAML::Tiny
  
  =head1 OPTIONS
  
  If you specify an option like:
  
      $YAML::Indent = 4;
  
  And YAML::Any is using YAML::XS, it will use the proper variable:
  $YAML::XS::Indent.
  
  =head1 SUBROUTINES
  
  Like all the YAML modules that YAML::Any uses, the following subroutines
  are exported by default:
  
      Dump
      Load
  
  and the following subroutines are exportable by request:
  
      DumpFile
      LoadFile
  
  =head1 METHODS
  
  YAML::Any provides the following class methods.
  
  =over
  
  =item YAML::Any->order;
  
  This method returns a list of the current possible implementations that
  YAML::Any will search for.
  
  =item YAML::Any->implementation;
  
  This method returns the implementation the YAML::Any will use. This
  result is obtained by finding the first member of YAML::Any->order that
  is either already loaded in C<%INC> or that can be loaded using
  C<require>. If no implementation is found, an error will be thrown.
  
  =back
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008. Ingy dt Net.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_ANY

$fatpacked{"YAML/Base.pm"} = <<'YAML_BASE';
  package YAML::Base;
  
  use strict;
  use warnings;
  use Exporter ();
  
  our $VERSION = '0.72';
  our @ISA     = 'Exporter';
  our @EXPORT  = qw(field XXX);
  
  sub new {
      my $class = shift;
      $class = ref($class) || $class;
      my $self = bless {}, $class;
      while (@_) {
          my $method = shift;
          $self->$method(shift);
      }
      return $self;
  }
  
  # Use lexical subs to reduce pollution of private methods by base class.
  my ($_new_error, $_info, $_scalar_info, $parse_arguments, $default_as_code);
  
  sub XXX {
      require Data::Dumper;
      CORE::die(Data::Dumper::Dumper(@_));
  }
  
  my %code = (
      sub_start =>
        "sub {\n",
      set_default =>
        "  \$_[0]->{%s} = %s\n    unless exists \$_[0]->{%s};\n",
      init =>
        "  return \$_[0]->{%s} = do { my \$self = \$_[0]; %s }\n" .
        "    unless \$#_ > 0 or defined \$_[0]->{%s};\n",
      return_if_get =>
        "  return \$_[0]->{%s} unless \$#_ > 0;\n",
      set =>
        "  \$_[0]->{%s} = \$_[1];\n",
      sub_end => 
        "  return \$_[0]->{%s};\n}\n",
  );
  
  sub field {
      my $package = caller;
      my ($args, @values) = &$parse_arguments(
          [ qw(-package -init) ],
          @_,
      );
      my ($field, $default) = @values;
      $package = $args->{-package} if defined $args->{-package};
      return if defined &{"${package}::$field"};
      my $default_string =
          ( ref($default) eq 'ARRAY' and not @$default )
          ? '[]'
          : (ref($default) eq 'HASH' and not keys %$default )
            ? '{}'
            : &$default_as_code($default);
  
      my $code = $code{sub_start};
      if ($args->{-init}) {
          my $fragment = $code{init};
          $code .= sprintf $fragment, $field, $args->{-init}, ($field) x 4;
      }
      $code .= sprintf $code{set_default}, $field, $default_string, $field
        if defined $default;
      $code .= sprintf $code{return_if_get}, $field;
      $code .= sprintf $code{set}, $field;
      $code .= sprintf $code{sub_end}, $field;
  
      my $sub = eval $code;
      die $@ if $@;
      no strict 'refs';
      *{"${package}::$field"} = $sub;
      return $code if defined wantarray;
  }
  
  sub die {
      my $self = shift;
      my $error = $self->$_new_error(@_);
      $error->type('Error');
      Carp::croak($error->format_message);
  }
  
  sub warn {
      my $self = shift;
      return unless $^W;
      my $error = $self->$_new_error(@_);
      $error->type('Warning');
      Carp::cluck($error->format_message);
  }
  
  # This code needs to be refactored to be simpler and more precise, and no,
  # Scalar::Util doesn't DWIM.
  #
  # Can't handle:
  # * blessed regexp
  sub node_info {
      my $self = shift;
      my $stringify = $_[1] || 0;
      my ($class, $type, $id) =
          ref($_[0])
          ? $stringify
            ? &$_info("$_[0]")
            : do {
                require overload;
                my @info = &$_info(overload::StrVal($_[0]));
                if (ref($_[0]) eq 'Regexp') {
                    @info[0, 1] = (undef, 'REGEXP');
                }
                @info;
            }
          : &$_scalar_info($_[0]);
      ($class, $type, $id) = &$_scalar_info("$_[0]")
          unless $id;
      return wantarray ? ($class, $type, $id) : $id;
  }
  
  #-------------------------------------------------------------------------------
  $_info = sub {
      return (($_[0]) =~ qr{^(?:(.*)\=)?([^=]*)\(([^\(]*)\)$}o);
  };
  
  $_scalar_info = sub {
      my $id = 'undef';
      if (defined $_[0]) {
          \$_[0] =~ /\((\w+)\)$/o or CORE::die();
          $id = "$1-S";
      }
      return (undef, undef, $id);
  };
  
  $_new_error = sub {
      require Carp;
      my $self = shift;
      require YAML::Error;
  
      my $code = shift || 'unknown error';
      my $error = YAML::Error->new(code => $code);
      $error->line($self->line) if $self->can('line');
      $error->document($self->document) if $self->can('document');
      $error->arguments([@_]);
      return $error;
  };
      
  $parse_arguments = sub {
      my $paired_arguments = shift || []; 
      my ($args, @values) = ({}, ());
      my %pairs = map { ($_, 1) } @$paired_arguments;
      while (@_) {
          my $elem = shift;
          if (defined $elem and defined $pairs{$elem} and @_) {
              $args->{$elem} = shift;
          }
          else {
              push @values, $elem;
          }
      }
      return wantarray ? ($args, @values) : $args;        
  };
  
  $default_as_code = sub {
      no warnings 'once';
      require Data::Dumper;
      local $Data::Dumper::Sortkeys = 1;
      my $code = Data::Dumper::Dumper(shift);
      $code =~ s/^\$VAR1 = //;
      $code =~ s/;$//;
      return $code;
  };
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Base - Base class for YAML classes
  
  =head1 SYNOPSIS
  
      package YAML::Something;
      use YAML::Base -base;
  
  =head1 DESCRIPTION
  
  YAML::Base is the parent of all YAML classes.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_BASE

$fatpacked{"YAML/Dumper.pm"} = <<'YAML_DUMPER';
  package YAML::Dumper;
  
  use strict;
  use warnings;
  use YAML::Base;
  use YAML::Dumper::Base;
  use YAML::Node;
  use YAML::Types;
  
  our $VERSION = '0.72';
  our @ISA     = 'YAML::Dumper::Base';
  
  # Context constants
  use constant KEY       => 3;
  use constant BLESSED   => 4;
  use constant FROMARRAY => 5;
  use constant VALUE     => "\x07YAML\x07VALUE\x07";
  
  # Common YAML character sets
  my $ESCAPE_CHAR = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f]';
  my $LIT_CHAR    = '|';    
  
  #==============================================================================
  # OO version of Dump. YAML->new->dump($foo); 
  sub dump {
      my $self = shift;
      $self->stream('');
      $self->document(0);
      for my $document (@_) {
          $self->{document}++;
          $self->transferred({});
          $self->id_refcnt({});
          $self->id_anchor({});
          $self->anchor(1);
          $self->level(0);
          $self->offset->[0] = 0 - $self->indent_width;
          $self->_prewalk($document);
          $self->_emit_header($document);
          $self->_emit_node($document);
      }
      return $self->stream;
  }
  
  # Every YAML document in the stream must begin with a YAML header, unless
  # there is only a single document and the user requests "no header".
  sub _emit_header {
      my $self = shift;
      my ($node) = @_;
      if (not $self->use_header and 
          $self->document == 1
         ) {
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            unless ref($node) =~ /^(HASH|ARRAY)$/;
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            if ref($node) eq 'HASH' and keys(%$node) == 0;
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            if ref($node) eq 'ARRAY' and @$node == 0;
          # XXX Also croak if aliased, blessed, or ynode
          $self->headless(1);
          return;
      }
      $self->{stream} .= '---';
  # XXX Consider switching to 1.1 style
      if ($self->use_version) {
  #         $self->{stream} .= " #YAML:1.0";
      }
  }
  
  # Walk the tree to be dumped and keep track of its reference counts.
  # This function is where the Dumper does all its work. All type
  # transfers happen here.
  sub _prewalk {
      my $self = shift;
      my $stringify = $self->stringify;
      my ($class, $type, $node_id) = $self->node_info(\$_[0], $stringify);
  
      # Handle typeglobs
      if ($type eq 'GLOB') {
          $self->transferred->{$node_id} =
            YAML::Type::glob->yaml_dump($_[0]);
          $self->_prewalk($self->transferred->{$node_id});
          return;
      }
  
      # Handle regexps
      if (ref($_[0]) eq 'Regexp') {  
          return;
      }
  
      # Handle Purity for scalars.
      # XXX can't find a use case yet. Might be YAGNI.
      if (not ref $_[0]) {
          $self->{id_refcnt}{$node_id}++ if $self->purity;
          return;
      }
  
      # Make a copy of original
      my $value = $_[0];
      ($class, $type, $node_id) = $self->node_info($value, $stringify);
  
      # Must be a stringified object.
      return if (ref($value) and not $type);
  
      # Look for things already transferred.
      if ($self->transferred->{$node_id}) {
          (undef, undef, $node_id) = (ref $self->transferred->{$node_id})
            ? $self->node_info($self->transferred->{$node_id}, $stringify)
            : $self->node_info(\ $self->transferred->{$node_id}, $stringify);
          $self->{id_refcnt}{$node_id}++;
          return;
      }
  
      # Handle code refs
      if ($type eq 'CODE') {
          $self->transferred->{$node_id} = 'placeholder';
          YAML::Type::code->yaml_dump(
              $self->dump_code,
              $_[0], 
              $self->transferred->{$node_id}
          );
          ($class, $type, $node_id) = 
            $self->node_info(\ $self->transferred->{$node_id}, $stringify);
          $self->{id_refcnt}{$node_id}++;
          return;
      }
  
      # Handle blessed things
      if (defined $class) {
          if ($value->can('yaml_dump')) {
              $value = $value->yaml_dump;
          }
          elsif ($type eq 'SCALAR') {
              $self->transferred->{$node_id} = 'placeholder';
              YAML::Type::blessed->yaml_dump
                ($_[0], $self->transferred->{$node_id});
              ($class, $type, $node_id) =
                $self->node_info(\ $self->transferred->{$node_id}, $stringify);
              $self->{id_refcnt}{$node_id}++;
              return;
          }
          else {
              $value = YAML::Type::blessed->yaml_dump($value);
          }
          $self->transferred->{$node_id} = $value;
          (undef, $type, $node_id) = $self->node_info($value, $stringify);
      }
  
      # Handle YAML Blessed things
      if (defined YAML->global_object()->{blessed_map}{$node_id}) {
          $value = YAML->global_object()->{blessed_map}{$node_id};
          $self->transferred->{$node_id} = $value;
          ($class, $type, $node_id) = $self->node_info($value, $stringify);
          $self->_prewalk($value);
          return;
      }
  
      # Handle hard refs
      if ($type eq 'REF' or $type eq 'SCALAR') {
          $value = YAML::Type::ref->yaml_dump($value);
          $self->transferred->{$node_id} = $value;
          (undef, $type, $node_id) = $self->node_info($value, $stringify);
      }
  
      # Handle ref-to-glob's
      elsif ($type eq 'GLOB') {
          my $ref_ynode = $self->transferred->{$node_id} =
            YAML::Type::ref->yaml_dump($value);
  
          my $glob_ynode = $ref_ynode->{&VALUE} = 
            YAML::Type::glob->yaml_dump($$value);
  
          (undef, undef, $node_id) = $self->node_info($glob_ynode, $stringify);
          $self->transferred->{$node_id} = $glob_ynode;
          $self->_prewalk($glob_ynode);
          return;
      }
  
      # Increment ref count for node
      return if ++($self->{id_refcnt}{$node_id}) > 1;
  
      # Keep on walking
      if ($type eq 'HASH') {
          $self->_prewalk($value->{$_})
              for keys %{$value};
          return;
      }
      elsif ($type eq 'ARRAY') {
          $self->_prewalk($_)
              for @{$value};
          return;
      }
  
      # Unknown type. Need to know about it.
      $self->warn(<<"...");
  YAML::Dumper can't handle dumping this type of data.
  Please report this to the author.
  
  id:    $node_id
  type:  $type
  class: $class
  value: $value
  
  ...
  
      return;
  }
  
  # Every data element and sub data element is a node.
  # Everything emitted goes through this function.
  sub _emit_node {
      my $self = shift;
      my ($type, $node_id);
      my $ref = ref($_[0]);
      if ($ref) {
          if ($ref eq 'Regexp') {
              $self->_emit(' !!perl/regexp');
              $self->_emit_str("$_[0]");
              return;
          }
          (undef, $type, $node_id) = $self->node_info($_[0], $self->stringify);
      }
      else {
          $type = $ref || 'SCALAR';
          (undef, undef, $node_id) = $self->node_info(\$_[0], $self->stringify);
      }
  
      my ($ynode, $tag) = ('') x 2;
      my ($value, $context) = (@_, 0);
  
      if (defined $self->transferred->{$node_id}) {
          $value = $self->transferred->{$node_id};
          $ynode = ynode($value);
          if (ref $value) {
              $tag = defined $ynode ? $ynode->tag->short : '';
              (undef, $type, $node_id) =
                $self->node_info($value, $self->stringify);
          }
          else {
              $ynode = ynode($self->transferred->{$node_id});
              $tag = defined $ynode ? $ynode->tag->short : '';
              $type = 'SCALAR';
              (undef, undef, $node_id) = 
                $self->node_info(
                    \ $self->transferred->{$node_id},
                    $self->stringify
                );
          }
      }
      elsif ($ynode = ynode($value)) {
          $tag = $ynode->tag->short;
      }
  
      if ($self->use_aliases) {
          $self->{id_refcnt}{$node_id} ||= 0;
          if ($self->{id_refcnt}{$node_id} > 1) {
              if (defined $self->{id_anchor}{$node_id}) {
                  $self->{stream} .= ' *' . $self->{id_anchor}{$node_id} . "\n";
                  return;
              }
              my $anchor = $self->anchor_prefix . $self->{anchor}++;
              $self->{stream} .= ' &' . $anchor;
              $self->{id_anchor}{$node_id} = $anchor;
          }
      }
  
      return $self->_emit_str("$value")   # Stringified object
        if ref($value) and not $type;
      return $self->_emit_scalar($value, $tag)
        if $type eq 'SCALAR' and $tag;
      return $self->_emit_str($value)
        if $type eq 'SCALAR';
      return $self->_emit_mapping($value, $tag, $node_id, $context)
        if $type eq 'HASH';
      return $self->_emit_sequence($value, $tag)
        if $type eq 'ARRAY';
      $self->warn('YAML_DUMP_WARN_BAD_NODE_TYPE', $type);
      return $self->_emit_str("$value");
  }
  
  # A YAML mapping is akin to a Perl hash. 
  sub _emit_mapping {
      my $self = shift;
      my ($value, $tag, $node_id, $context) = @_;
      $self->{stream} .= " !$tag" if $tag;
  
      # Sometimes 'keys' fails. Like on a bad tie implementation.
      my $empty_hash = not(eval {keys %$value});
      $self->warn('YAML_EMIT_WARN_KEYS', $@) if $@;
      return ($self->{stream} .= " {}\n") if $empty_hash;
  
      # If CompressSeries is on (default) and legal is this context, then
      # use it and make the indent level be 2 for this node.
      if ($context == FROMARRAY and
          $self->compress_series and
          not (defined $self->{id_anchor}{$node_id} or $tag or $empty_hash)
         ) {
          $self->{stream} .= ' ';
          $self->offset->[$self->level+1] = $self->offset->[$self->level] + 2;
      }
      else {
          $context = 0;
          $self->{stream} .= "\n"
            unless $self->headless && not($self->headless(0));
          $self->offset->[$self->level+1] =
            $self->offset->[$self->level] + $self->indent_width;
      }
  
      $self->{level}++;
      my @keys;
      if ($self->sort_keys == 1) {
          if (ynode($value)) {
              @keys = keys %$value;
          }
          else {
              @keys = sort keys %$value;
          }
      }
      elsif ($self->sort_keys == 2) {
          @keys = sort keys %$value;
      }
      # XXX This is hackish but sometimes handy. Not sure whether to leave it in.
      elsif (ref($self->sort_keys) eq 'ARRAY') {
          my $i = 1;
          my %order = map { ($_, $i++) } @{$self->sort_keys};
          @keys = sort {
              (defined $order{$a} and defined $order{$b})
                ? ($order{$a} <=> $order{$b})
                : ($a cmp $b);
          } keys %$value;
      }
      else {
          @keys = keys %$value;
      }
      # Force the YAML::VALUE ('=') key to sort last.
      if (exists $value->{&VALUE}) {
          for (my $i = 0; $i < @keys; $i++) {
              if ($keys[$i] eq &VALUE) {
                  splice(@keys, $i, 1);
                  push @keys, &VALUE;
                  last;
              }
          }
      }
  
      for my $key (@keys) {
          $self->_emit_key($key, $context);
          $context = 0;
          $self->{stream} .= ':';
          $self->_emit_node($value->{$key});
      }
      $self->{level}--;
  }
  
  # A YAML series is akin to a Perl array.
  sub _emit_sequence {
      my $self = shift;
      my ($value, $tag) = @_;
      $self->{stream} .= " !$tag" if $tag;
  
      return ($self->{stream} .= " []\n") if @$value == 0;
          
      $self->{stream} .= "\n"
        unless $self->headless && not($self->headless(0));
  
      # XXX Really crufty feature. Better implemented by ynodes.
      if ($self->inline_series and
          @$value <= $self->inline_series and
          not (scalar grep {ref or /\n/} @$value)
         ) {
          $self->{stream} =~ s/\n\Z/ /;
          $self->{stream} .= '[';
          for (my $i = 0; $i < @$value; $i++) {
              $self->_emit_str($value->[$i], KEY);
              last if $i == $#{$value};
              $self->{stream} .= ', ';
          }
          $self->{stream} .= "]\n";
          return;
      }
  
      $self->offset->[$self->level + 1] =
        $self->offset->[$self->level] + $self->indent_width;
      $self->{level}++;
      for my $val (@$value) {
          $self->{stream} .= ' ' x $self->offset->[$self->level];
          $self->{stream} .= '-';
          $self->_emit_node($val, FROMARRAY);
      }
      $self->{level}--;
  }
  
  # Emit a mapping key
  sub _emit_key {
      my $self = shift;
      my ($value, $context) = @_;
      $self->{stream} .= ' ' x $self->offset->[$self->level]
        unless $context == FROMARRAY;
      $self->_emit_str($value, KEY);
  }
  
  # Emit a blessed SCALAR
  sub _emit_scalar {
      my $self = shift;
      my ($value, $tag) = @_;
      $self->{stream} .= " !$tag";
      $self->_emit_str($value, BLESSED);
  }
  
  sub _emit {
      my $self = shift;
      $self->{stream} .= join '', @_;
  }
  
  # Emit a string value. YAML has many scalar styles. This routine attempts to
  # guess the best style for the text.
  sub _emit_str {
      my $self = shift;
      my $type = $_[1] || 0;
  
      # Use heuristics to find the best scalar emission style.
      $self->offset->[$self->level + 1] =
        $self->offset->[$self->level] + $self->indent_width;
      $self->{level}++;
  
      my $sf = $type == KEY ? '' : ' ';
      my $sb = $type == KEY ? '? ' : ' ';
      my $ef = $type == KEY ? '' : "\n";
      my $eb = "\n";
  
      while (1) {
          $self->_emit($sf),
          $self->_emit_plain($_[0]),
          $self->_emit($ef), last 
            if not defined $_[0];
          $self->_emit($sf, '=', $ef), last
            if $_[0] eq VALUE;
          $self->_emit($sf),
          $self->_emit_double($_[0]),
          $self->_emit($ef), last
            if $_[0] =~ /$ESCAPE_CHAR/;
          if ($_[0] =~ /\n/) {
              $self->_emit($sb),
              $self->_emit_block($LIT_CHAR, $_[0]),
              $self->_emit($eb), last
                if $self->use_block;
                Carp::cluck "[YAML] \$UseFold is no longer supported"
                if $self->use_fold;
              $self->_emit($sf),
              $self->_emit_double($_[0]),
              $self->_emit($ef), last
                if length $_[0] <= 30;
              $self->_emit($sf),
              $self->_emit_double($_[0]),
              $self->_emit($ef), last
                if $_[0] !~ /\n\s*\S/;
              $self->_emit($sb),
              $self->_emit_block($LIT_CHAR, $_[0]),
              $self->_emit($eb), last;
          }
          $self->_emit($sf),
          $self->_emit_plain($_[0]),
          $self->_emit($ef), last
            if $self->is_valid_plain($_[0]);
          $self->_emit($sf),
          $self->_emit_double($_[0]),
          $self->_emit($ef), last
            if $_[0] =~ /'/;
          $self->_emit($sf),
          $self->_emit_single($_[0]),
          $self->_emit($ef);
          last;
      }
  
      $self->{level}--;
  
      return;
  }
  
  # Check whether or not a scalar should be emitted as an plain scalar.
  sub is_valid_plain {
      my $self = shift;
      return 0 unless length $_[0];
      # refer to YAML::Loader::parse_inline_simple()
      return 0 if $_[0] =~ /^[\s\{\[\~\`\'\"\!\@\#\>\|\%\&\?\*\^]/;
      return 0 if $_[0] =~ /[\{\[\]\},]/;
      return 0 if $_[0] =~ /[:\-\?]\s/;
      return 0 if $_[0] =~ /\s#/;
      return 0 if $_[0] =~ /\:(\s|$)/;
      return 0 if $_[0] =~ /[\s\|\>]$/;
      return 1;
  }
  
  sub _emit_block {
      my $self = shift;
      my ($indicator, $value) = @_;
      $self->{stream} .= $indicator;
      $value =~ /(\n*)\Z/;
      my $chomp = length $1 ? (length $1 > 1) ? '+' : '' : '-';
      $value = '~' if not defined $value;
      $self->{stream} .= $chomp;
      $self->{stream} .= $self->indent_width if $value =~ /^\s/;
      $self->{stream} .= $self->indent($value);
  }
  
  # Plain means that the scalar is unquoted.
  sub _emit_plain {
      my $self = shift;
      $self->{stream} .= defined $_[0] ? $_[0] : '~';
  }
  
  # Double quoting is for single lined escaped strings.
  sub _emit_double {
      my $self = shift;
      (my $escaped = $self->escape($_[0])) =~ s/"/\\"/g;
      $self->{stream} .= qq{"$escaped"};
  }
  
  # Single quoting is for single lined unescaped strings.
  sub _emit_single {
      my $self = shift;
      my $item = shift;
      $item =~ s{'}{''}g;
      $self->{stream} .= "'$item'";
  }
  
  #==============================================================================
  # Utility subroutines.
  #==============================================================================
  
  # Indent a scalar to the current indentation level.
  sub indent {
      my $self = shift;
      my ($text) = @_;
      return $text unless length $text;
      $text =~ s/\n\Z//;
      my $indent = ' ' x $self->offset->[$self->level];
      $text =~ s/^/$indent/gm;
      $text = "\n$text";
      return $text;
  }
  
  # Escapes for unprintable characters
  my @escapes = qw(\0   \x01 \x02 \x03 \x04 \x05 \x06 \a
                   \x08 \t   \n   \v   \f   \r   \x0e \x0f
                   \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17
                   \x18 \x19 \x1a \e   \x1c \x1d \x1e \x1f
                  );
  
  # Escape the unprintable characters
  sub escape {
      my $self = shift;
      my ($text) = @_;
      $text =~ s/\\/\\\\/g;
      $text =~ s/([\x00-\x1f])/$escapes[ord($1)]/ge;
      return $text;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Dumper - YAML class for dumping Perl objects to YAML
  
  =head1 SYNOPSIS
  
      use YAML::Dumper;
      my $dumper = YAML::Dumper->new;
      $dumper->indent_width(4);
      print $dumper->dump({foo => 'bar'});
  
  =head1 DESCRIPTION
  
  YAML::Dumper is the module that YAML.pm used to serialize Perl objects to
  YAML. It is fully object oriented and usable on its own.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_DUMPER

$fatpacked{"YAML/Dumper/Base.pm"} = <<'YAML_DUMPER_BASE';
  package YAML::Dumper::Base;
  
  use strict;
  use warnings;
  use YAML::Base;
  use YAML::Node;
  
  our $VERSION = '0.72';
  our @ISA     = 'YAML::Base';
  
  # YAML Dumping options
  field spec_version    => '1.0';
  field indent_width    => 2;
  field use_header      => 1;
  field use_version     => 0;
  field sort_keys       => 1;
  field anchor_prefix   => '';
  field dump_code       => 0;
  field use_block       => 0;
  field use_fold        => 0;
  field compress_series => 1;
  field inline_series   => 0;
  field use_aliases     => 1;
  field purity          => 0;
  field stringify       => 0;
  
  # Properties
  field stream      => '';
  field document    => 0;
  field transferred => {};
  field id_refcnt   => {};
  field id_anchor   => {};
  field anchor      => 1;
  field level       => 0;
  field offset      => [];
  field headless    => 0;
  field blessed_map => {};
  
  # Global Options are an idea taken from Data::Dumper. Really they are just
  # sugar on top of real OO properties. They make the simple Dump/Load API
  # easy to configure.
  sub set_global_options {
      my $self = shift;
      $self->spec_version($YAML::SpecVersion)
        if defined $YAML::SpecVersion;
      $self->indent_width($YAML::Indent)
        if defined $YAML::Indent;
      $self->use_header($YAML::UseHeader)
        if defined $YAML::UseHeader;
      $self->use_version($YAML::UseVersion)
        if defined $YAML::UseVersion;
      $self->sort_keys($YAML::SortKeys)
        if defined $YAML::SortKeys;
      $self->anchor_prefix($YAML::AnchorPrefix)
        if defined $YAML::AnchorPrefix;
      $self->dump_code($YAML::DumpCode || $YAML::UseCode)
        if defined $YAML::DumpCode or defined $YAML::UseCode;
      $self->use_block($YAML::UseBlock)
        if defined $YAML::UseBlock;
      $self->use_fold($YAML::UseFold)
        if defined $YAML::UseFold;
      $self->compress_series($YAML::CompressSeries)
        if defined $YAML::CompressSeries;
      $self->inline_series($YAML::InlineSeries)
        if defined $YAML::InlineSeries;
      $self->use_aliases($YAML::UseAliases)
        if defined $YAML::UseAliases;
      $self->purity($YAML::Purity)
        if defined $YAML::Purity;
      $self->stringify($YAML::Stringify)
        if defined $YAML::Stringify;
  }
  
  sub dump {
      my $self = shift;
      $self->die('dump() not implemented in this class.');
  }
  
  sub blessed {
      my $self = shift;
      my ($ref) = @_;
      $ref = \$_[0] unless ref $ref;
      my (undef, undef, $node_id) = YAML::Base->node_info($ref);
      $self->{blessed_map}->{$node_id};
  }
      
  sub bless {
      my $self = shift;
      my ($ref, $blessing) = @_;
      my $ynode;
      $ref = \$_[0] unless ref $ref;
      my (undef, undef, $node_id) = YAML::Base->node_info($ref);
      if (not defined $blessing) {
          $ynode = YAML::Node->new($ref);
      }
      elsif (ref $blessing) {
          $self->die() unless ynode($blessing);
          $ynode = $blessing;
      }
      else {
          no strict 'refs';
          my $transfer = $blessing . "::yaml_dump";
          $self->die() unless defined &{$transfer};
          $ynode = &{$transfer}($ref);
          $self->die() unless ynode($ynode);
      }
      $self->{blessed_map}->{$node_id} = $ynode;
      my $object = ynode($ynode) or $self->die();
      return $object;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Dumper::Base - Base class for YAML Dumper classes
  
  =head1 SYNOPSIS
  
      package YAML::Dumper::Something;
      use YAML::Dumper::Base -base;
  
  =head1 DESCRIPTION
  
  YAML::Dumper::Base is a base class for creating YAML dumper classes.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_DUMPER_BASE

$fatpacked{"YAML/Error.pm"} = <<'YAML_ERROR';
  package YAML::Error;
  
  use strict;
  use warnings;
  use YAML::Base;
  
  our $VERSION = '0.72';
  our @ISA     = 'YAML::Base';
  
  field 'code';
  field 'type' => 'Error';
  field 'line';
  field 'document';
  field 'arguments' => [];
  
  my ($error_messages, %line_adjust);
  
  sub format_message {
      my $self = shift;
      my $output = 'YAML ' . $self->type . ': ';
      my $code = $self->code;
      if ($error_messages->{$code}) {
          $code = sprintf($error_messages->{$code}, @{$self->arguments});
      }
      $output .= $code . "\n";
  
      $output .= '   Code: ' . $self->code . "\n"
          if defined $self->code;
      $output .= '   Line: ' . $self->line . "\n"
          if defined $self->line;
      $output .= '   Document: ' . $self->document . "\n"
          if defined $self->document;
      return $output;
  }
  
  sub error_messages {
      $error_messages;
  }
  
  %$error_messages = map {s/^\s+//;$_} split "\n", <<'...';
  YAML_PARSE_ERR_BAD_CHARS
    Invalid characters in stream. This parser only supports printable ASCII
  YAML_PARSE_ERR_NO_FINAL_NEWLINE
    Stream does not end with newline character
  YAML_PARSE_ERR_BAD_MAJOR_VERSION
    Can't parse a %s document with a 1.0 parser
  YAML_PARSE_WARN_BAD_MINOR_VERSION
    Parsing a %s document with a 1.0 parser
  YAML_PARSE_WARN_MULTIPLE_DIRECTIVES
    '%s directive used more than once'
  YAML_PARSE_ERR_TEXT_AFTER_INDICATOR
    No text allowed after indicator
  YAML_PARSE_ERR_NO_ANCHOR
    No anchor for alias '*%s'
  YAML_PARSE_ERR_NO_SEPARATOR
    Expected separator '---'
  YAML_PARSE_ERR_SINGLE_LINE
    Couldn't parse single line value
  YAML_PARSE_ERR_BAD_ANCHOR
    Invalid anchor
  YAML_DUMP_ERR_INVALID_INDENT
    Invalid Indent width specified: '%s'
  YAML_LOAD_USAGE
    usage: YAML::Load($yaml_stream_scalar)
  YAML_PARSE_ERR_BAD_NODE
    Can't parse node
  YAML_PARSE_ERR_BAD_EXPLICIT
    Unsupported explicit transfer: '%s'
  YAML_DUMP_USAGE_DUMPCODE
    Invalid value for DumpCode: '%s'
  YAML_LOAD_ERR_FILE_INPUT
    Couldn't open %s for input:\n%s
  YAML_DUMP_ERR_FILE_CONCATENATE
    Can't concatenate to YAML file %s
  YAML_DUMP_ERR_FILE_OUTPUT
    Couldn't open %s for output:\n%s
  YAML_DUMP_ERR_NO_HEADER
    With UseHeader=0, the node must be a plain hash or array
  YAML_DUMP_WARN_BAD_NODE_TYPE
    Can't perform serialization for node type: '%s'
  YAML_EMIT_WARN_KEYS
    Encountered a problem with 'keys':\n%s
  YAML_DUMP_WARN_DEPARSE_FAILED
    Deparse failed for CODE reference
  YAML_DUMP_WARN_CODE_DUMMY
    Emitting dummy subroutine for CODE reference
  YAML_PARSE_ERR_MANY_EXPLICIT
    More than one explicit transfer
  YAML_PARSE_ERR_MANY_IMPLICIT
    More than one implicit request
  YAML_PARSE_ERR_MANY_ANCHOR
    More than one anchor
  YAML_PARSE_ERR_ANCHOR_ALIAS
    Can't define both an anchor and an alias
  YAML_PARSE_ERR_BAD_ALIAS
    Invalid alias
  YAML_PARSE_ERR_MANY_ALIAS
    More than one alias
  YAML_LOAD_ERR_NO_CONVERT
    Can't convert implicit '%s' node to explicit '%s' node
  YAML_LOAD_ERR_NO_DEFAULT_VALUE
    No default value for '%s' explicit transfer
  YAML_LOAD_ERR_NON_EMPTY_STRING
    Only the empty string can be converted to a '%s'
  YAML_LOAD_ERR_BAD_MAP_TO_SEQ
    Can't transfer map as sequence. Non numeric key '%s' encountered.
  YAML_DUMP_ERR_BAD_GLOB
    '%s' is an invalid value for Perl glob
  YAML_DUMP_ERR_BAD_REGEXP
    '%s' is an invalid value for Perl Regexp
  YAML_LOAD_ERR_BAD_MAP_ELEMENT
    Invalid element in map
  YAML_LOAD_WARN_DUPLICATE_KEY
    Duplicate map key found. Ignoring.
  YAML_LOAD_ERR_BAD_SEQ_ELEMENT
    Invalid element in sequence
  YAML_PARSE_ERR_INLINE_MAP
    Can't parse inline map
  YAML_PARSE_ERR_INLINE_SEQUENCE
    Can't parse inline sequence
  YAML_PARSE_ERR_BAD_DOUBLE
    Can't parse double quoted string
  YAML_PARSE_ERR_BAD_SINGLE
    Can't parse single quoted string
  YAML_PARSE_ERR_BAD_INLINE_IMPLICIT
    Can't parse inline implicit value '%s'
  YAML_PARSE_ERR_BAD_IMPLICIT
    Unrecognized implicit value '%s'
  YAML_PARSE_ERR_INDENTATION
    Error. Invalid indentation level
  YAML_PARSE_ERR_INCONSISTENT_INDENTATION
    Inconsistent indentation level
  YAML_LOAD_WARN_UNRESOLVED_ALIAS
    Can't resolve alias *%s
  YAML_LOAD_WARN_NO_REGEXP_IN_REGEXP
    No 'REGEXP' element for Perl regexp
  YAML_LOAD_WARN_BAD_REGEXP_ELEM
    Unknown element '%s' in Perl regexp
  YAML_LOAD_WARN_GLOB_NAME
    No 'NAME' element for Perl glob
  YAML_LOAD_WARN_PARSE_CODE
    Couldn't parse Perl code scalar: %s
  YAML_LOAD_WARN_CODE_DEPARSE
    Won't parse Perl code unless $YAML::LoadCode is set
  YAML_EMIT_ERR_BAD_LEVEL
    Internal Error: Bad level detected
  YAML_PARSE_WARN_AMBIGUOUS_TAB
    Amibiguous tab converted to spaces
  YAML_LOAD_WARN_BAD_GLOB_ELEM
    Unknown element '%s' in Perl glob
  YAML_PARSE_ERR_ZERO_INDENT
    Can't use zero as an indentation width
  YAML_LOAD_WARN_GLOB_IO
    Can't load an IO filehandle. Yet!!!
  ...
  
  %line_adjust = map {($_, 1)} 
    qw(YAML_PARSE_ERR_BAD_MAJOR_VERSION
       YAML_PARSE_WARN_BAD_MINOR_VERSION 
       YAML_PARSE_ERR_TEXT_AFTER_INDICATOR 
       YAML_PARSE_ERR_NO_ANCHOR 
       YAML_PARSE_ERR_MANY_EXPLICIT
       YAML_PARSE_ERR_MANY_IMPLICIT
       YAML_PARSE_ERR_MANY_ANCHOR
       YAML_PARSE_ERR_ANCHOR_ALIAS
       YAML_PARSE_ERR_BAD_ALIAS
       YAML_PARSE_ERR_MANY_ALIAS
       YAML_LOAD_ERR_NO_CONVERT
       YAML_LOAD_ERR_NO_DEFAULT_VALUE
       YAML_LOAD_ERR_NON_EMPTY_STRING
       YAML_LOAD_ERR_BAD_MAP_TO_SEQ
       YAML_LOAD_ERR_BAD_STR_TO_INT
       YAML_LOAD_ERR_BAD_STR_TO_DATE
       YAML_LOAD_ERR_BAD_STR_TO_TIME
       YAML_LOAD_WARN_DUPLICATE_KEY
       YAML_PARSE_ERR_INLINE_MAP
       YAML_PARSE_ERR_INLINE_SEQUENCE
       YAML_PARSE_ERR_BAD_DOUBLE
       YAML_PARSE_ERR_BAD_SINGLE
       YAML_PARSE_ERR_BAD_INLINE_IMPLICIT
       YAML_PARSE_ERR_BAD_IMPLICIT
       YAML_LOAD_WARN_NO_REGEXP_IN_REGEXP
       YAML_LOAD_WARN_BAD_REGEXP_ELEM
       YAML_LOAD_WARN_REGEXP_CREATE
       YAML_LOAD_WARN_GLOB_NAME
       YAML_LOAD_WARN_PARSE_CODE
       YAML_LOAD_WARN_CODE_DEPARSE
       YAML_LOAD_WARN_BAD_GLOB_ELEM
       YAML_PARSE_ERR_ZERO_INDENT
      );
  
  package YAML::Warning;
  
  our @ISA = 'YAML::Error';
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Error - Error formatting class for YAML modules
  
  =head1 SYNOPSIS
  
      $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias);
      $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
  
  =head1 DESCRIPTION
  
  This module provides a C<die> and a C<warn> facility.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_ERROR

$fatpacked{"YAML/Loader.pm"} = <<'YAML_LOADER';
  package YAML::Loader;
  
  use strict;
  use warnings;
  use YAML::Base;
  use YAML::Loader::Base;
  use YAML::Types;
  
  our $VERSION = '0.72';
  our @ISA     = 'YAML::Loader::Base';
  
  # Context constants
  use constant LEAF       => 1;
  use constant COLLECTION => 2;
  use constant VALUE      => "\x07YAML\x07VALUE\x07";
  use constant COMMENT    => "\x07YAML\x07COMMENT\x07";
  
  # Common YAML character sets
  my $ESCAPE_CHAR = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f]';
  my $FOLD_CHAR   = '>';
  my $LIT_CHAR    = '|';    
  my $LIT_CHAR_RX = "\\$LIT_CHAR";    
  
  sub load {
      my $self = shift;
      $self->stream($_[0] || '');
      return $self->_parse();
  }
  
  # Top level function for parsing. Parse each document in order and
  # handle processing for YAML headers.
  sub _parse {
      my $self = shift;
      my (%directives, $preface);
      $self->{stream} =~ s|\015\012|\012|g;
      $self->{stream} =~ s|\015|\012|g;
      $self->line(0);
      $self->die('YAML_PARSE_ERR_BAD_CHARS') 
        if $self->stream =~ /$ESCAPE_CHAR/;
      $self->die('YAML_PARSE_ERR_NO_FINAL_NEWLINE') 
        if length($self->stream) and 
           $self->{stream} !~ s/(.)\n\Z/$1/s;
      $self->lines([split /\x0a/, $self->stream, -1]);
      $self->line(1);
      # Throw away any comments or blanks before the header (or start of
      # content for headerless streams)
      $self->_parse_throwaway_comments();
      $self->document(0);
      $self->documents([]);
      # Add an "assumed" header if there is no header and the stream is
      # not empty (after initial throwaways).
      if (not $self->eos) {
          if ($self->lines->[0] !~ /^---(\s|$)/) {
              unshift @{$self->lines}, '---';
              $self->{line}--;
          }
      }
  
      # Main Loop. Parse out all the top level nodes and return them.
      while (not $self->eos) {
          $self->anchor2node({});
          $self->{document}++;
          $self->done(0);
          $self->level(0);
          $self->offset->[0] = -1;
  
          if ($self->lines->[0] =~ /^---\s*(.*)$/) {
              my @words = split /\s+/, $1;
              %directives = ();
              while (@words && $words[0] =~ /^#(\w+):(\S.*)$/) {
                  my ($key, $value) = ($1, $2);
                  shift(@words);
                  if (defined $directives{$key}) {
                      $self->warn('YAML_PARSE_WARN_MULTIPLE_DIRECTIVES',
                        $key, $self->document);
                      next;
                  }
                  $directives{$key} = $value;
              }
              $self->preface(join ' ', @words);
          }
          else {
              $self->die('YAML_PARSE_ERR_NO_SEPARATOR');
          }
  
          if (not $self->done) {
              $self->_parse_next_line(COLLECTION);
          }
          if ($self->done) {
              $self->{indent} = -1;
              $self->content('');
          }
  
          $directives{YAML} ||= '1.0';
          $directives{TAB} ||= 'NONE';
          ($self->{major_version}, $self->{minor_version}) = 
            split /\./, $directives{YAML}, 2;
          $self->die('YAML_PARSE_ERR_BAD_MAJOR_VERSION', $directives{YAML})
            if $self->major_version ne '1';
          $self->warn('YAML_PARSE_WARN_BAD_MINOR_VERSION', $directives{YAML})
            if $self->minor_version ne '0';
          $self->die('Unrecognized TAB policy')
            unless $directives{TAB} =~ /^(NONE|\d+)(:HARD)?$/;
  
          push @{$self->documents}, $self->_parse_node();
      }
      return wantarray ? @{$self->documents} : $self->documents->[-1];
  }
  
  # This function is the dispatcher for parsing each node. Every node
  # recurses back through here. (Inlines are an exception as they have
  # their own sub-parser.)
  sub _parse_node {
      my $self = shift;
      my $preface = $self->preface;
      $self->preface('');
      my ($node, $type, $indicator, $escape, $chomp) = ('') x 5;
      my ($anchor, $alias, $explicit, $implicit, $class) = ('') x 5;
      ($anchor, $alias, $explicit, $implicit, $preface) = 
        $self->_parse_qualifiers($preface);
      if ($anchor) {
          $self->anchor2node->{$anchor} = CORE::bless [], 'YAML-anchor2node';
      }
      $self->inline('');
      while (length $preface) {
          my $line = $self->line - 1;
          if ($preface =~ s/^($FOLD_CHAR|$LIT_CHAR_RX)(-|\+)?\d*\s*//) { 
              $indicator = $1;
              $chomp = $2 if defined($2);
          }
          else {
              $self->die('YAML_PARSE_ERR_TEXT_AFTER_INDICATOR') if $indicator;
              $self->inline($preface);
              $preface = '';
          }
      }
      if ($alias) {
          $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias)
            unless defined $self->anchor2node->{$alias};
          if (ref($self->anchor2node->{$alias}) ne 'YAML-anchor2node') {
              $node = $self->anchor2node->{$alias};
          }
          else {
              $node = do {my $sv = "*$alias"};
              push @{$self->anchor2node->{$alias}}, [\$node, $self->line]; 
          }
      }
      elsif (length $self->inline) {
          $node = $self->_parse_inline(1, $implicit, $explicit);
          if (length $self->inline) {
              $self->die('YAML_PARSE_ERR_SINGLE_LINE'); 
          }
      }
      elsif ($indicator eq $LIT_CHAR) {
          $self->{level}++;
          $node = $self->_parse_block($chomp);
          $node = $self->_parse_implicit($node) if $implicit;
          $self->{level}--; 
      }
      elsif ($indicator eq $FOLD_CHAR) {
          $self->{level}++;
          $node = $self->_parse_unfold($chomp);
          $node = $self->_parse_implicit($node) if $implicit;
          $self->{level}--;
      }
      else {
          $self->{level}++;
          $self->offset->[$self->level] ||= 0;
          if ($self->indent == $self->offset->[$self->level]) {
              if ($self->content =~ /^-( |$)/) {
                  $node = $self->_parse_seq($anchor);
              }
              elsif ($self->content =~ /(^\?|\:( |$))/) {
                  $node = $self->_parse_mapping($anchor);
              }
              elsif ($preface =~ /^\s*$/) {
                  $node = $self->_parse_implicit('');
              }
              else {
                  $self->die('YAML_PARSE_ERR_BAD_NODE');
              }
          }
          else {
              $node = undef;
          }
          $self->{level}--;
      }
      $#{$self->offset} = $self->level;
  
      if ($explicit) {
          if ($class) {
              if (not ref $node) {
                  my $copy = $node;
                  undef $node;
                  $node = \$copy;
              }
              CORE::bless $node, $class;
          }
          else {
              $node = $self->_parse_explicit($node, $explicit);
          }
      }
      if ($anchor) {
          if (ref($self->anchor2node->{$anchor}) eq 'YAML-anchor2node') {
              # XXX Can't remember what this code actually does
              for my $ref (@{$self->anchor2node->{$anchor}}) {
                  ${$ref->[0]} = $node;
                  $self->warn('YAML_LOAD_WARN_UNRESOLVED_ALIAS',
                      $anchor, $ref->[1]);
              }
          }
          $self->anchor2node->{$anchor} = $node;
      }
      return $node;
  }
  
  # Preprocess the qualifiers that may be attached to any node.
  sub _parse_qualifiers {
      my $self = shift;
      my ($preface) = @_;
      my ($anchor, $alias, $explicit, $implicit, $token) = ('') x 5;
      $self->inline('');
      while ($preface =~ /^[&*!]/) {
          my $line = $self->line - 1;
          if ($preface =~ s/^\!(\S+)\s*//) {
              $self->die('YAML_PARSE_ERR_MANY_EXPLICIT') if $explicit;
              $explicit = $1;
          }
          elsif ($preface =~ s/^\!\s*//) {
              $self->die('YAML_PARSE_ERR_MANY_IMPLICIT') if $implicit;
              $implicit = 1;
          }
          elsif ($preface =~ s/^\&([^ ,:]+)\s*//) {
              $token = $1;
              $self->die('YAML_PARSE_ERR_BAD_ANCHOR') 
                unless $token =~ /^[a-zA-Z0-9]+$/;
              $self->die('YAML_PARSE_ERR_MANY_ANCHOR') if $anchor;
              $self->die('YAML_PARSE_ERR_ANCHOR_ALIAS') if $alias;
              $anchor = $token;
          }
          elsif ($preface =~ s/^\*([^ ,:]+)\s*//) {
              $token = $1;
              $self->die('YAML_PARSE_ERR_BAD_ALIAS')
                unless $token =~ /^[a-zA-Z0-9]+$/;
              $self->die('YAML_PARSE_ERR_MANY_ALIAS') if $alias;
              $self->die('YAML_PARSE_ERR_ANCHOR_ALIAS') if $anchor;
              $alias = $token;
          }
      }
      return ($anchor, $alias, $explicit, $implicit, $preface); 
  }
  
  # Morph a node to it's explicit type  
  sub _parse_explicit {
      my $self = shift;
      my ($node, $explicit) = @_;
      my ($type, $class);
      if ($explicit =~ /^\!?perl\/(hash|array|ref|scalar)(?:\:(\w(\w|\:\:)*)?)?$/) {
          ($type, $class) = (($1 || ''), ($2 || ''));
  
          # FIXME # die unless uc($type) eq ref($node) ?
  
          if ( $type eq "ref" ) {
              $self->die('YAML_LOAD_ERR_NO_DEFAULT_VALUE', 'XXX', $explicit)
              unless exists $node->{VALUE()} and scalar(keys %$node) == 1;
  
              my $value = $node->{VALUE()};
              $node = \$value;
          }
          
          if ( $type eq "scalar" and length($class) and !ref($node) ) {
              my $value = $node;
              $node = \$value;
          }
  
          if ( length($class) ) {
              CORE::bless($node, $class);
          }
  
          return $node;
      }
      if ($explicit =~ m{^!?perl/(glob|regexp|code)(?:\:(\w(\w|\:\:)*)?)?$}) {
          ($type, $class) = (($1 || ''), ($2 || ''));
          my $type_class = "YAML::Type::$type";
          no strict 'refs';
          if ($type_class->can('yaml_load')) {
              return $type_class->yaml_load($node, $class, $self);
          }
          else {
              $self->die('YAML_LOAD_ERR_NO_CONVERT', 'XXX', $explicit);
          }
      }
      # This !perl/@Foo and !perl/$Foo are deprecated but still parsed
      elsif ($YAML::TagClass->{$explicit} ||
             $explicit =~ m{^perl/(\@|\$)?([a-zA-Z](\w|::)+)$}
            ) {
          $class = $YAML::TagClass->{$explicit} || $2;
          if ($class->can('yaml_load')) {
              require YAML::Node;
              return $class->yaml_load(YAML::Node->new($node, $explicit));
          }
          else {
              if (ref $node) {
                  return CORE::bless $node, $class;
              }
              else {
                  return CORE::bless \$node, $class;
              }
          }
      }
      elsif (ref $node) {
          require YAML::Node;
          return YAML::Node->new($node, $explicit);
      }
      else {
          # XXX This is likely wrong. Failing test:
          # --- !unknown 'scalar value'
          return $node;
      }
  }
  
  # Parse a YAML mapping into a Perl hash
  sub _parse_mapping {
      my $self = shift;
      my ($anchor) = @_;
      my $mapping = {};
      $self->anchor2node->{$anchor} = $mapping;
      my $key;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          # If structured key:
          if ($self->{content} =~ s/^\?\s*//) {
              $self->preface($self->content);
              $self->_parse_next_line(COLLECTION);
              $key = $self->_parse_node();
              $key = "$key";
          }
          # If "default" key (equals sign) 
          elsif ($self->{content} =~ s/^\=\s*//) {
              $key = VALUE;
          }
          # If "comment" key (slash slash)
          elsif ($self->{content} =~ s/^\=\s*//) {
              $key = COMMENT;
          }
          # Regular scalar key:
          else {
              $self->inline($self->content);
              $key = $self->_parse_inline();
              $key = "$key";
              $self->content($self->inline);
              $self->inline('');
          }
              
          unless ($self->{content} =~ s/^:\s*//) {
              $self->die('YAML_LOAD_ERR_BAD_MAP_ELEMENT');
          }
          $self->preface($self->content);
          my $line = $self->line;
          $self->_parse_next_line(COLLECTION);
          my $value = $self->_parse_node();
          if (exists $mapping->{$key}) {
              $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
          }
          else {
              $mapping->{$key} = $value;
          }
      }
      return $mapping;
  }
  
  # Parse a YAML sequence into a Perl array
  sub _parse_seq {
      my $self = shift;
      my ($anchor) = @_;
      my $seq = [];
      $self->anchor2node->{$anchor} = $seq;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          if ($self->content =~ /^-(?: (.*))?$/) {
              $self->preface(defined($1) ? $1 : '');
          }
          else {
              $self->die('YAML_LOAD_ERR_BAD_SEQ_ELEMENT');
          }
          if ($self->preface =~ /^(\s*)(\w.*\:(?: |$).*)$/) {
              $self->indent($self->offset->[$self->level] + 2 + length($1));
              $self->content($2);
              $self->level($self->level + 1);
              $self->offset->[$self->level] = $self->indent;
              $self->preface('');
              push @$seq, $self->_parse_mapping('');
              $self->{level}--;
              $#{$self->offset} = $self->level;
          }
          else {
              $self->_parse_next_line(COLLECTION);
              push @$seq, $self->_parse_node();
          }
      }
      return $seq;
  }
  
  # Parse an inline value. Since YAML supports inline collections, this is
  # the top level of a sub parsing.
  sub _parse_inline {
      my $self = shift;
      my ($top, $top_implicit, $top_explicit) = (@_, '', '', '');
      $self->{inline} =~ s/^\s*(.*)\s*$/$1/; # OUCH - mugwump
      my ($node, $anchor, $alias, $explicit, $implicit) = ('') x 5;
      ($anchor, $alias, $explicit, $implicit, $self->{inline}) = 
        $self->_parse_qualifiers($self->inline);
      if ($anchor) {
          $self->anchor2node->{$anchor} = CORE::bless [], 'YAML-anchor2node';
      }
      $implicit ||= $top_implicit;
      $explicit ||= $top_explicit;
      ($top_implicit, $top_explicit) = ('', '');
      if ($alias) {
          $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias)
            unless defined $self->anchor2node->{$alias};
          if (ref($self->anchor2node->{$alias}) ne 'YAML-anchor2node') {
              $node = $self->anchor2node->{$alias};
          }
          else {
              $node = do {my $sv = "*$alias"};
              push @{$self->anchor2node->{$alias}}, [\$node, $self->line]; 
          }
      }
      elsif ($self->inline =~ /^\{/) {
          $node = $self->_parse_inline_mapping($anchor);
      }
      elsif ($self->inline =~ /^\[/) {
          $node = $self->_parse_inline_seq($anchor);
      }
      elsif ($self->inline =~ /^"/) {
          $node = $self->_parse_inline_double_quoted();
          $node = $self->_unescape($node);
          $node = $self->_parse_implicit($node) if $implicit;
      }
      elsif ($self->inline =~ /^'/) {
          $node = $self->_parse_inline_single_quoted();
          $node = $self->_parse_implicit($node) if $implicit;
      }
      else {
          if ($top) {
              $node = $self->inline;
              $self->inline('');
          }
          else {
              $node = $self->_parse_inline_simple();
          }
          $node = $self->_parse_implicit($node) unless $explicit;
      }
      if ($explicit) {
          $node = $self->_parse_explicit($node, $explicit);
      }
      if ($anchor) {
          if (ref($self->anchor2node->{$anchor}) eq 'YAML-anchor2node') {
              for my $ref (@{$self->anchor2node->{$anchor}}) {
                  ${$ref->[0]} = $node;
                  $self->warn('YAML_LOAD_WARN_UNRESOLVED_ALIAS',
                      $anchor, $ref->[1]);
              }
          }
          $self->anchor2node->{$anchor} = $node;
      }
      return $node;
  }
  
  # Parse the inline YAML mapping into a Perl hash
  sub _parse_inline_mapping {
      my $self = shift;
      my ($anchor) = @_;
      my $node = {};
      $self->anchor2node->{$anchor} = $node;
  
      $self->die('YAML_PARSE_ERR_INLINE_MAP')
        unless $self->{inline} =~ s/^\{\s*//;
      while (not $self->{inline} =~ s/^\s*\}//) {
          my $key = $self->_parse_inline();
          $self->die('YAML_PARSE_ERR_INLINE_MAP')
            unless $self->{inline} =~ s/^\: \s*//;
          my $value = $self->_parse_inline();
          if (exists $node->{$key}) {
              $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
          }
          else {
              $node->{$key} = $value;
          }
          next if $self->inline =~ /^\s*\}/;
          $self->die('YAML_PARSE_ERR_INLINE_MAP')
            unless $self->{inline} =~ s/^\,\s*//;
      }
      return $node;
  }
  
  # Parse the inline YAML sequence into a Perl array
  sub _parse_inline_seq {
      my $self = shift;
      my ($anchor) = @_;
      my $node = [];
      $self->anchor2node->{$anchor} = $node;
  
      $self->die('YAML_PARSE_ERR_INLINE_SEQUENCE')
        unless $self->{inline} =~ s/^\[\s*//;
      while (not $self->{inline} =~ s/^\s*\]//) {
          my $value = $self->_parse_inline();
          push @$node, $value;
          next if $self->inline =~ /^\s*\]/;
          $self->die('YAML_PARSE_ERR_INLINE_SEQUENCE') 
            unless $self->{inline} =~ s/^\,\s*//;
      }
      return $node;
  }
  
  # Parse the inline double quoted string.
  sub _parse_inline_double_quoted {
      my $self = shift;
      my $node;
      if ($self->inline =~ /^"((?:\\"|[^"])*)"\s*(.*)$/) {
          $node = $1;
          $self->inline($2);
          $node =~ s/\\"/"/g;
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_DOUBLE');
      }
      return $node;
  }
  
  
  # Parse the inline single quoted string.
  sub _parse_inline_single_quoted {
      my $self = shift;
      my $node;
      if ($self->inline =~ /^'((?:''|[^'])*)'\s*(.*)$/) {
          $node = $1;
          $self->inline($2);
          $node =~ s/''/'/g;
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_SINGLE');
      }
      return $node;
  }
  
  # Parse the inline unquoted string and do implicit typing.
  sub _parse_inline_simple {
      my $self = shift;
      my $value;
      if ($self->inline =~ /^(|[^!@#%^&*].*?)(?=[\[\]\{\},]|, |: |- |:\s*$|$)/) {
          $value = $1;
          substr($self->{inline}, 0, length($1)) = '';
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_INLINE_IMPLICIT', $value);
      }
      return $value;
  }
  
  sub _parse_implicit {
      my $self = shift;
      my ($value) = @_;
      $value =~ s/\s*$//;
      return $value if $value eq '';
      return undef if $value =~ /^~$/;
      return $value
        unless $value =~ /^[\@\`\^]/ or
               $value =~ /^[\-\?]\s/;
      $self->die('YAML_PARSE_ERR_BAD_IMPLICIT', $value);
  }
  
  # Unfold a YAML multiline scalar into a single string.
  sub _parse_unfold {
      my $self = shift;
      my ($chomp) = @_;
      my $node = '';
      my $space = 0;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          $node .= $self->content. "\n";
          $self->_parse_next_line(LEAF);
      }
      $node =~ s/^(\S.*)\n(?=\S)/$1 /gm;
      $node =~ s/^(\S.*)\n(\n+\S)/$1$2/gm;
      $node =~ s/\n*\Z// unless $chomp eq '+';
      $node .= "\n" unless $chomp;
      return $node;
  }
  
  # Parse a YAML block style scalar. This is like a Perl here-document.
  sub _parse_block {
      my $self = shift;
      my ($chomp) = @_;
      my $node = '';
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          $node .= $self->content . "\n";
          $self->_parse_next_line(LEAF);
      }
      return $node if '+' eq $chomp;
      $node =~ s/\n*\Z/\n/;
      $node =~ s/\n\Z// if $chomp eq '-';
      return $node;
  }
  
  # Handle Perl style '#' comments. Comments must be at the same indentation
  # level as the collection line following them.
  sub _parse_throwaway_comments {
      my $self = shift;
      while (@{$self->lines} and
             $self->lines->[0] =~ m{^\s*(\#|$)}
            ) {
          shift @{$self->lines};
          $self->{line}++;
      }
      $self->eos($self->{done} = not @{$self->lines});
  }
  
  # This is the routine that controls what line is being parsed. It gets called
  # once for each line in the YAML stream.
  #
  # This routine must:
  # 1) Skip past the current line
  # 2) Determine the indentation offset for a new level
  # 3) Find the next _content_ line
  #   A) Skip over any throwaways (Comments/blanks)
  #   B) Set $self->indent, $self->content, $self->line
  # 4) Expand tabs appropriately  
  sub _parse_next_line {
      my $self = shift;
      my ($type) = @_;
      my $level = $self->level;
      my $offset = $self->offset->[$level];
      $self->die('YAML_EMIT_ERR_BAD_LEVEL') unless defined $offset;
      shift @{$self->lines};
      $self->eos($self->{done} = not @{$self->lines});
      return if $self->eos;
      $self->{line}++;
  
      # Determine the offset for a new leaf node
      if ($self->preface =~
          qr/(?:^|\s)(?:$FOLD_CHAR|$LIT_CHAR_RX)(?:-|\+)?(\d*)\s*$/
         ) {
          $self->die('YAML_PARSE_ERR_ZERO_INDENT')
            if length($1) and $1 == 0;
          $type = LEAF;
          if (length($1)) {
              $self->offset->[$level + 1] = $offset + $1;
          }
          else {
              # First get rid of any comments.
              while (@{$self->lines} && ($self->lines->[0] =~ /^\s*#/)) {
                  $self->lines->[0] =~ /^( *)/ or die;
                  last unless length($1) <= $offset;
                  shift @{$self->lines};
                  $self->{line}++;
              }
              $self->eos($self->{done} = not @{$self->lines});
              return if $self->eos;
              if ($self->lines->[0] =~ /^( *)\S/ and length($1) > $offset) {
                  $self->offset->[$level+1] = length($1);
              }
              else {
                  $self->offset->[$level+1] = $offset + 1;
              }
          }
          $offset = $self->offset->[++$level];
      }
      # Determine the offset for a new collection level
      elsif ($type == COLLECTION and 
             $self->preface =~ /^(\s*(\!\S*|\&\S+))*\s*$/) {
          $self->_parse_throwaway_comments();
          if ($self->eos) {
              $self->offset->[$level+1] = $offset + 1;
              return;
          }
          else {
              $self->lines->[0] =~ /^( *)\S/ or die;
              if (length($1) > $offset) {
                  $self->offset->[$level+1] = length($1);
              }
              else {
                  $self->offset->[$level+1] = $offset + 1;
              }
          }
          $offset = $self->offset->[++$level];
      }
          
      if ($type == LEAF) {
          while (@{$self->lines} and
                 $self->lines->[0] =~ m{^( *)(\#)} and
                 length($1) < $offset
                ) {
              shift @{$self->lines};
              $self->{line}++;
          }
          $self->eos($self->{done} = not @{$self->lines});
      }
      else {
          $self->_parse_throwaway_comments();
      }
      return if $self->eos; 
      
      if ($self->lines->[0] =~ /^---(\s|$)/) {
          $self->done(1);
          return;
      }
      if ($type == LEAF and 
          $self->lines->[0] =~ /^ {$offset}(.*)$/
         ) {
          $self->indent($offset);
          $self->content($1);
      }
      elsif ($self->lines->[0] =~ /^\s*$/) {
          $self->indent($offset);
          $self->content('');
      }
      else {
          $self->lines->[0] =~ /^( *)(\S.*)$/;
          while ($self->offset->[$level] > length($1)) {
              $level--;
          }
          $self->die('YAML_PARSE_ERR_INCONSISTENT_INDENTATION') 
            if $self->offset->[$level] != length($1);
          $self->indent(length($1));
          $self->content($2);
      }
      $self->die('YAML_PARSE_ERR_INDENTATION')
        if $self->indent - $offset > 1;
  }
  
  #==============================================================================
  # Utility subroutines.
  #==============================================================================
  
  # Printable characters for escapes
  my %unescapes = (
     0 => "\x00",
     a => "\x07",
     t => "\x09",
     n => "\x0a",
     'v' => "\x0b", # Potential v-string error on 5.6.2 if not quoted
     f => "\x0c",
     r => "\x0d",
     e => "\x1b",
     '\\' => '\\',
    );
     
  # Transform all the backslash style escape characters to their literal meaning
  sub _unescape {
      my $self = shift;
      my ($node) = @_;
      $node =~ s/\\([never\\fart0]|x([0-9a-fA-F]{2}))/
                (length($1)>1)?pack("H2",$2):$unescapes{$1}/gex;
      return $node;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Loader - YAML class for loading Perl objects to YAML
  
  =head1 SYNOPSIS
  
      use YAML::Loader;
      my $loader = YAML::Loader->new;
      my $hash = $loader->load(<<'...');
      foo: bar
      ...
  
  =head1 DESCRIPTION
  
  YAML::Loader is the module that YAML.pm used to deserialize YAML to Perl
  objects. It is fully object oriented and usable on its own.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_LOADER

$fatpacked{"YAML/Loader/Base.pm"} = <<'YAML_LOADER_BASE';
  package YAML::Loader::Base;
  
  use strict;
  use warnings;
  use YAML::Base;
  
  our $VERSION = '0.72';
  our @ISA     = 'YAML::Base';
  
  field load_code     => 0;
  field stream        => '';
  field document      => 0;
  field line          => 0;
  field documents     => [];
  field lines         => [];
  field eos           => 0;
  field done          => 0;
  field anchor2node   => {};
  field level         => 0;
  field offset        => [];
  field preface       => '';
  field content       => '';
  field indent        => 0;
  field major_version => 0;
  field minor_version => 0;
  field inline        => '';
  
  sub set_global_options {
      my $self = shift;
      $self->load_code($YAML::LoadCode || $YAML::UseCode)
        if defined $YAML::LoadCode or defined $YAML::UseCode;
  }
  
  sub load {
      die 'load() not implemented in this class.';
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Loader::Base - Base class for YAML Loader classes
  
  =head1 SYNOPSIS
  
      package YAML::Loader::Something;
      use YAML::Loader::Base -base;
  
  =head1 DESCRIPTION
  
  YAML::Loader::Base is a base class for creating YAML loader classes.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_LOADER_BASE

$fatpacked{"YAML/Marshall.pm"} = <<'YAML_MARSHALL';
  package YAML::Marshall;
  
  use strict;
  use warnings;
  use YAML::Node ();
  
  our $VERSION = '0.72';
  
  sub import {
      my $class = shift;
      no strict 'refs';
      my $package = caller;
      unless (grep { $_ eq $class} @{$package . '::ISA'}) {
          push @{$package . '::ISA'}, $class;
      }
  
      my $tag = shift;
      if ( $tag ) {
          no warnings 'once';
          $YAML::TagClass->{$tag} = $package;
          ${$package . "::YamlTag"} = $tag;
      }
  }
  
  sub yaml_dump {
      my $self = shift;
      no strict 'refs';
      my $tag = ${ref($self) . "::YamlTag"} || 'perl/' . ref($self);
      $self->yaml_node($self, $tag);
  }
  
  sub yaml_load {
      my ($class, $node) = @_;
      if (my $ynode = $class->yaml_ynode($node)) {
          $node = $ynode->{NODE};
      }
      bless $node, $class;
  }
  
  sub yaml_node {
      shift;
      YAML::Node->new(@_);
  }
  
  sub yaml_ynode {
      shift;
      YAML::Node::ynode(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Marshall - YAML marshalling class you can mixin to your classes
  
  =head1 SYNOPSIS
  
      package Bar;
      use Foo -base;
      use YAML::Marshall -mixin;
  
  =head1 DESCRIPTION
  
  For classes that want to handle their own YAML serialization.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_MARSHALL

$fatpacked{"YAML/Node.pm"} = <<'YAML_NODE';
  package YAML::Node;
  
  use strict;
  use warnings;
  
  use YAML::Base;
  use YAML::Tag;
  
  our $VERSION = '0.72';
  our @ISA     = 'YAML::Base';
  our @EXPORT  = qw(ynode);
  
  sub ynode {
      my $self;
      if (ref($_[0]) eq 'HASH') {
  	$self = tied(%{$_[0]});
      }
      elsif (ref($_[0]) eq 'ARRAY') {
  	$self = tied(@{$_[0]});
      }
      else {
  	$self = tied($_[0]);
      }
      return (ref($self) =~ /^yaml_/) ? $self : undef;
  }
  
  sub new {
      my ($class, $node, $tag) = @_;
      my $self;
      $self->{NODE} = $node;
      my (undef, $type) = $class->node_info($node);
      $self->{KIND} = (not defined $type) ? 'scalar' :
                      ($type eq 'ARRAY') ? 'sequence' :
  		    ($type eq 'HASH') ? 'mapping' :
  		    $class->die("Can't create YAML::Node from '$type'");
      tag($self, ($tag || ''));
      if ($self->{KIND} eq 'scalar') {
  	yaml_scalar->new($self, $_[1]);
  	return \ $_[1];
      }
      my $package = "yaml_" . $self->{KIND};    
      $package->new($self)
  }
  
  sub node { $_->{NODE} }
  sub kind { $_->{KIND} }
  sub tag {
      my ($self, $value) = @_;
      if (defined $value) {
         	$self->{TAG} = YAML::Tag->new($value);
  	return $self;
      }
      else {
         return $self->{TAG};
      }
  }
  sub keys {
      my ($self, $value) = @_;
      if (defined $value) {
         	$self->{KEYS} = $value;
  	return $self;
      }
      else {
         return $self->{KEYS};
      }
  }
  
  #==============================================================================
  package yaml_scalar;
  
  @yaml_scalar::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      tie $_[2], $class, $self;
  }
  
  sub TIESCALAR {
      my ($class, $self) = @_;
      bless $self, $class;
      $self
  }
  
  sub FETCH {
      my ($self) = @_;
      $self->{NODE}
  }
  
  sub STORE {
      my ($self, $value) = @_;
      $self->{NODE} = $value
  }
  
  #==============================================================================
  package yaml_sequence;
  
  @yaml_sequence::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      my $new;
      tie @$new, $class, $self;
      $new
  }
  
  sub TIEARRAY {
      my ($class, $self) = @_;
      bless $self, $class
  }
  
  sub FETCHSIZE {
      my ($self) = @_;
      scalar @{$self->{NODE}};
  }
  
  sub FETCH {
      my ($self, $index) = @_;
      $self->{NODE}[$index]
  }
  
  sub STORE {
      my ($self, $index, $value) = @_;
      $self->{NODE}[$index] = $value
  }
  
  sub undone {
      die "Not implemented yet"; # XXX
  }
  
  *STORESIZE = *POP = *PUSH = *SHIFT = *UNSHIFT = *SPLICE = *DELETE = *EXISTS = 
  *STORESIZE = *POP = *PUSH = *SHIFT = *UNSHIFT = *SPLICE = *DELETE = *EXISTS = 
  *undone; # XXX Must implement before release
  
  #==============================================================================
  package yaml_mapping;
  
  @yaml_mapping::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      @{$self->{KEYS}} = sort keys %{$self->{NODE}}; 
      my $new;
      tie %$new, $class, $self;
      $new
  }
  
  sub TIEHASH {
      my ($class, $self) = @_;
      bless $self, $class
  }
  
  sub FETCH {
      my ($self, $key) = @_;
      if (exists $self->{NODE}{$key}) {
  	return (grep {$_ eq $key} @{$self->{KEYS}}) 
  	       ? $self->{NODE}{$key} : undef;
      }
      return $self->{HASH}{$key};
  }
  
  sub STORE {
      my ($self, $key, $value) = @_;
      if (exists $self->{NODE}{$key}) {
  	$self->{NODE}{$key} = $value;
      }
      elsif (exists $self->{HASH}{$key}) {
  	$self->{HASH}{$key} = $value;
      }
      else {
  	if (not grep {$_ eq $key} @{$self->{KEYS}}) {
  	    push(@{$self->{KEYS}}, $key);
  	}
  	$self->{HASH}{$key} = $value;
      }
      $value
  }
  
  sub DELETE {
      my ($self, $key) = @_;
      my $return;
      if (exists $self->{NODE}{$key}) {
  	$return = $self->{NODE}{$key};
      }
      elsif (exists $self->{HASH}{$key}) {
  	$return = delete $self->{NODE}{$key};
      }
      for (my $i = 0; $i < @{$self->{KEYS}}; $i++) {
  	if ($self->{KEYS}[$i] eq $key) {
  	    splice(@{$self->{KEYS}}, $i, 1);
  	}
      }
      return $return;
  }
  
  sub CLEAR {
      my ($self) = @_;
      @{$self->{KEYS}} = ();
      %{$self->{HASH}} = ();
  }
  
  sub FIRSTKEY {
      my ($self) = @_;
      $self->{ITER} = 0;
      $self->{KEYS}[0]
  }
  
  sub NEXTKEY {
      my ($self) = @_;
      $self->{KEYS}[++$self->{ITER}]
  }
  
  sub EXISTS {
      my ($self, $key) = @_;
      exists $self->{NODE}{$key}
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Node - A generic data node that encapsulates YAML information
  
  =head1 SYNOPSIS
  
      use YAML;
      use YAML::Node;
      
      my $ynode = YAML::Node->new({}, 'ingerson.com/fruit');
      %$ynode = qw(orange orange apple red grape green);
      print Dump $ynode;
  
  yields:
  
      --- !ingerson.com/fruit
      orange: orange
      apple: red
      grape: green
  
  =head1 DESCRIPTION
  
  A generic node in YAML is similar to a plain hash, array, or scalar node
  in Perl except that it must also keep track of its type. The type is a
  URI called the YAML type tag.
  
  YAML::Node is a class for generating and manipulating these containers.
  A YAML node (or ynode) is a tied hash, array or scalar. In most ways it
  behaves just like the plain thing. But you can assign and retrieve and
  YAML type tag URI to it. For the hash flavor, you can also assign the
  order that the keys will be retrieved in. By default a ynode will offer
  its keys in the same order that they were assigned.
  
  YAML::Node has a class method call new() that will return a ynode. You
  pass it a regular node and an optional type tag. After that you can
  use it like a normal Perl node, but when you YAML::Dump it, the magical
  properties will be honored.
  
  This is how you can control the sort order of hash keys during a YAML
  serialization. By default, YAML sorts keys alphabetically. But notice
  in the above example that the keys were Dumped in the same order they
  were assigned.
  
  YAML::Node exports a function called ynode(). This function returns the tied object so that you can call special methods on it like ->keys().
  
  keys() works like this:
  
      use YAML;
      use YAML::Node;
      
      %$node = qw(orange orange apple red grape green);
      $ynode = YAML::Node->new($node);
      ynode($ynode)->keys(['grape', 'apple']);
      print Dump $ynode;
  
  produces:
  
      ---
      grape: green
      apple: red
  
  It tells the ynode which keys and what order to use.
  
  ynodes will play a very important role in how programs use YAML. They
  are the foundation of how a Perl class can marshall the Loading and
  Dumping of its objects.
  
  The upcoming versions of YAML.pm will have much more information on this.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006. Ingy dt Net. All rights reserved.
  
  Copyright (c) 2002. Brian Ingerson. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_NODE

$fatpacked{"YAML/Tag.pm"} = <<'YAML_TAG';
  package YAML::Tag;
  
  use strict;
  use warnings;
  
  our $VERSION = '0.72';
  
  use overload '""' => sub { ${$_[0]} };
  
  sub new {
      my ($class, $self) = @_;
      bless \$self, $class
  }
  
  sub short {
      ${$_[0]}
  }
  
  sub canonical {
      ${$_[0]}
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Tag - Tag URI object class for YAML
  
  =head1 SYNOPSIS
  
      use YAML::Tag;
  
  =head1 DESCRIPTION
  
  Used by YAML::Node.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_TAG

$fatpacked{"YAML/Types.pm"} = <<'YAML_TYPES';
  package YAML::Types;
  
  use strict;
  use warnings;
  use YAML::Base;
  use YAML::Node;
  
  our $VERSION = '0.72';
  our @ISA     = 'YAML::Base';
  
  # XXX These classes and their APIs could still use some refactoring,
  # but at least they work for now.
  #-------------------------------------------------------------------------------
  package YAML::Type::blessed;
  
  use YAML::Base; # XXX
  
  sub yaml_dump {
      my $self = shift;
      my ($value) = @_;
      my ($class, $type) = YAML::Base->node_info($value);
      no strict 'refs';
      my $kind = lc($type) . ':';
      my $tag = ${$class . '::ClassTag'} ||
                "!perl/$kind$class";
      if ($type eq 'REF') {
          YAML::Node->new(
              {(&YAML::VALUE, ${$_[0]})}, $tag
          );
      }
      elsif ($type eq 'SCALAR') {
          $_[1] = $$value;
          YAML::Node->new($_[1], $tag);
      } else {
          YAML::Node->new($value, $tag);
      }
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::undef;
  
  sub yaml_dump {
      my $self = shift;
  }
  
  sub yaml_load {
      my $self = shift;
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::glob;
  
  sub yaml_dump {
      my $self = shift;
      my $ynode = YAML::Node->new({}, '!perl/glob:');
      for my $type (qw(PACKAGE NAME SCALAR ARRAY HASH CODE IO)) {
          my $value = *{$_[0]}{$type};
          $value = $$value if $type eq 'SCALAR';
          if (defined $value) {
              if ($type eq 'IO') {
                  my @stats = qw(device inode mode links uid gid rdev size
                                 atime mtime ctime blksize blocks);
                  undef $value;
                  $value->{stat} = YAML::Node->new({});
                  map {$value->{stat}{shift @stats} = $_} stat(*{$_[0]});
                  $value->{fileno} = fileno(*{$_[0]});
                  {
                      local $^W;
                      $value->{tell} = tell(*{$_[0]});
                  }
              }
              $ynode->{$type} = $value; 
          }
      }
      return $ynode;
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      my ($name, $package);
      if (defined $node->{NAME}) {
          $name = $node->{NAME};
          delete $node->{NAME};
      }
      else {
          $loader->warn('YAML_LOAD_WARN_GLOB_NAME');
          return undef;
      }
      if (defined $node->{PACKAGE}) {
          $package = $node->{PACKAGE};
          delete $node->{PACKAGE};
      }
      else {
          $package = 'main';
      }
      no strict 'refs';
      if (exists $node->{SCALAR}) {
          *{"${package}::$name"} = \$node->{SCALAR};
          delete $node->{SCALAR};
      }
      for my $elem (qw(ARRAY HASH CODE IO)) {
          if (exists $node->{$elem}) {
              if ($elem eq 'IO') {
                  $loader->warn('YAML_LOAD_WARN_GLOB_IO');
                  delete $node->{IO};
                  next;
              }
              *{"${package}::$name"} = $node->{$elem};
              delete $node->{$elem};
          }
      }
      for my $elem (sort keys %$node) {
          $loader->warn('YAML_LOAD_WARN_BAD_GLOB_ELEM', $elem);
      }
      return *{"${package}::$name"};
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::code;
  
  my $dummy_warned = 0; 
  my $default = '{ "DUMMY" }';
  
  sub yaml_dump {
      my $self = shift;
      my $code;
      my ($dumpflag, $value) = @_;
      my ($class, $type) = YAML::Base->node_info($value);
      my $tag = "!perl/code";
      $tag .= ":$class" if defined $class;
      if (not $dumpflag) {
          $code = $default;
      }
      else {
          bless $value, "CODE" if $class;
          eval { use B::Deparse };
          return if $@;
          my $deparse = B::Deparse->new();
          eval {
              local $^W = 0;
              $code = $deparse->coderef2text($value);
          };
          if ($@) {
              warn YAML::YAML_DUMP_WARN_DEPARSE_FAILED() if $^W;
              $code = $default;
          }
          bless $value, $class if $class;
          chomp $code;
          $code .= "\n";
      }
      $_[2] = $code;
      YAML::Node->new($_[2], $tag);
  }    
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      if ($loader->load_code) {
          my $code = eval "package main; sub $node";
          if ($@) {
              $loader->warn('YAML_LOAD_WARN_PARSE_CODE', $@);
              return sub {};
          }
          else {
              CORE::bless $code, $class if $class;
              return $code;
          }
      }
      else {
          return CORE::bless sub {}, $class if $class;
          return sub {};
      }
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::ref;
  
  sub yaml_dump {
      my $self = shift;
      YAML::Node->new({(&YAML::VALUE, ${$_[0]})}, '!perl/ref')
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      $loader->die('YAML_LOAD_ERR_NO_DEFAULT_VALUE', 'ptr')
        unless exists $node->{&YAML::VALUE};
      return \$node->{&YAML::VALUE};
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::regexp;
  
  # XXX Be sure to handle blessed regexps (if possible)
  sub yaml_dump {
      die "YAML::Type::regexp::yaml_dump not currently implemented";
  }
  
  use constant _QR_TYPES => {
      '' => sub { qr{$_[0]} },
      x => sub { qr{$_[0]}x },
      i => sub { qr{$_[0]}i },
      s => sub { qr{$_[0]}s },
      m => sub { qr{$_[0]}m },
      ix => sub { qr{$_[0]}ix },
      sx => sub { qr{$_[0]}sx },
      mx => sub { qr{$_[0]}mx },
      si => sub { qr{$_[0]}si },
      mi => sub { qr{$_[0]}mi },
      ms => sub { qr{$_[0]}sm },
      six => sub { qr{$_[0]}six },
      mix => sub { qr{$_[0]}mix },
      msx => sub { qr{$_[0]}msx },
      msi => sub { qr{$_[0]}msi },
      msix => sub { qr{$_[0]}msix },
  };
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class) = @_;
      return qr{$node} unless $node =~ /^\(\?([\-xism]*):(.*)\)\z/s;
      my ($flags, $re) = ($1, $2);
      $flags =~ s/-.*//;
      my $sub = _QR_TYPES->{$flags} || sub { qr{$_[0]} };
      my $qr = &$sub($re);
      bless $qr, $class if length $class;
      return $qr;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Types - Marshall Perl internal data types to/from YAML
  
  =head1 SYNOPSIS
  
      $::foo = 42;
      print YAML::Dump(*::foo);
  
      print YAML::Dump(qr{match me});
  
  =head1 DESCRIPTION
  
  This module has the helper classes for transferring objects,
  subroutines, references, globs, regexps and file handles to and
  from YAML.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_TYPES

$fatpacked{"i686-linux-gnu-thread-multi/Params/Util.pm"} = <<'I686-LINUX-GNU-THREAD-MULTI_PARAMS_UTIL';
  package Params::Util;
  
  =pod
  
  =head1 NAME
  
  Params::Util - Simple, compact and correct param-checking functions
  
  =head1 SYNOPSIS
  
    # Import some functions
    use Params::Util qw{_SCALAR _HASH _INSTANCE};
    
    # If you are lazy, or need a lot of them...
    use Params::Util ':ALL';
    
    sub foo {
        my $object  = _INSTANCE(shift, 'Foo') or return undef;
        my $image   = _SCALAR(shift)          or return undef;
        my $options = _HASH(shift)            or return undef;
        # etc...
    }
  
  =head1 DESCRIPTION
  
  C<Params::Util> provides a basic set of importable functions that makes
  checking parameters a hell of a lot easier
  
  While they can be (and are) used in other contexts, the main point
  behind this module is that the functions B<both> Do What You Mean,
  and Do The Right Thing, so they are most useful when you are getting
  params passed into your code from someone and/or somewhere else
  and you can't really trust the quality.
  
  Thus, C<Params::Util> is of most use at the edges of your API, where
  params and data are coming in from outside your code.
  
  The functions provided by C<Params::Util> check in the most strictly
  correct manner known, are documented as thoroughly as possible so their
  exact behaviour is clear, and heavily tested so make sure they are not
  fooled by weird data and Really Bad Things.
  
  To use, simply load the module providing the functions you want to use
  as arguments (as shown in the SYNOPSIS).
  
  To aid in maintainability, C<Params::Util> will B<never> export by
  default.
  
  You must explicitly name the functions you want to export, or use the
  C<:ALL> param to just have it export everything (although this is not
  recommended if you have any _FOO functions yourself with which future
  additions to C<Params::Util> may clash)
  
  =head1 FUNCTIONS
  
  =cut
  
  use 5.00503;
  use strict;
  require overload;
  require Exporter;
  require Scalar::Util;
  require DynaLoader;
  
  use vars qw{$VERSION @ISA @EXPORT_OK %EXPORT_TAGS};
  
  $VERSION   = '1.03';
  @ISA       = qw{
  	Exporter
  	DynaLoader
  };
  @EXPORT_OK = qw{
  	_STRING     _IDENTIFIER
  	_CLASS      _CLASSISA   _SUBCLASS  _DRIVER
  	_NUMBER     _POSINT     _NONNEGINT
  	_SCALAR     _SCALAR0
  	_ARRAY      _ARRAY0     _ARRAYLIKE
  	_HASH       _HASH0      _HASHLIKE
  	_CODE       _CODELIKE
  	_INVOCANT   _REGEX      _INSTANCE
  	_SET        _SET0
  	_HANDLE
  };
  %EXPORT_TAGS = ( ALL => \@EXPORT_OK );
  
  eval {
  	local $ENV{PERL_DL_NONLAZY} = 0 if $ENV{PERL_DL_NONLAZY};
  	bootstrap Params::Util $VERSION;
  	1;
  } unless $ENV{PERL_PARAMS_UTIL_PP};
  
  
  
  
  
  #####################################################################
  # Param Checking Functions
  
  =pod
  
  =head2 _STRING $string
  
  The C<_STRING> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a normal non-false string of non-zero length.
  
  Note that this will NOT do anything magic to deal with the special
  C<'0'> false negative case, but will return it.
  
    # '0' not considered valid data
    my $name = _STRING(shift) or die "Bad name";
    
    # '0' is considered valid data
    my $string = _STRING($_[0]) ? shift : die "Bad string";
  
  Please also note that this function expects a normal string. It does
  not support overloading or other magic techniques to get a string.
  
  Returns the string as a conveince if it is a valid string, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_STRING;
  sub _STRING ($) {
  	(defined $_[0] and ! ref $_[0] and length($_[0])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _IDENTIFIER $string
  
  The C<_IDENTIFIER> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a valid Perl identifier.
  
  Returns the string as a convenience if it is a valid identifier, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_IDENTIFIER;
  sub _IDENTIFIER ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*\z/s) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CLASS $string
  
  The C<_CLASS> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a valid Perl class.
  
  This function only checks that the format is valid, not that the
  class is actually loaded. It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASS;
  sub _CLASS ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CLASSISA $string, $class
  
  The C<_CLASSISA> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a particularly class, or a subclass of it.
  
  This function checks that the format is valid and calls the -E<gt>isa
  method on the class name. It does not check that the class is actually
  loaded.
  
  It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CLASSISA;
  sub _CLASSISA ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SUBCLASS $string, $class
  
  The C<_SUBCLASS> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a string that is a subclass of a specified class.
  
  This function checks that the format is valid and calls the -E<gt>isa
  method on the class name. It does not check that the class is actually
  loaded.
  
  It also assumes "normalised" form, and does
  not accept class names such as C<::Foo> or C<D'Oh>.
  
  Returns the string as a convenience if it is a valid class name, or
  C<undef> if not.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SUBCLASS;
  sub _SUBCLASS ($$) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s and $_[0] ne $_[1] and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _NUMBER $scalar
  
  The C<_NUMBER> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a number. That is, it is defined and perl thinks it's a number.
  
  This function is basically a Params::Util-style wrapper around the
  L<Scalar::Util> C<looks_like_number> function.
  
  Returns the value as a convience, or C<undef> if the value is not a
  number.
  
  =cut
  
  eval <<'END_PERL' unless defined &_NUMBER;
  sub _NUMBER ($) {
  	( defined $_[0] and ! ref $_[0] and Scalar::Util::looks_like_number($_[0]) )
  	? $_[0]
  	: undef;
  }
  END_PERL
  
  =pod
  
  =head2 _POSINT $integer
  
  The C<_POSINT> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a positive integer (of any length).
  
  Returns the value as a convience, or C<undef> if the value is not a
  positive integer.
  
  The name itself is derived from the XML schema constraint of the same
  name.
  
  =cut
  
  eval <<'END_PERL' unless defined &_POSINT;
  sub _POSINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[1-9]\d*$/) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _NONNEGINT $integer
  
  The C<_NONNEGINT> function is intended to be imported into your
  package, and provides a convenient way to test to see if a value is
  a non-negative integer (of any length). That is, a positive integer,
  or zero.
  
  Returns the value as a convience, or C<undef> if the value is not a
  non-negative integer.
  
  As with other tests that may return false values, care should be taken
  to test via "defined" in boolean validy contexts.
  
    unless ( defined _NONNEGINT($value) ) {
       die "Invalid value";
    }
  
  The name itself is derived from the XML schema constraint of the same
  name.
  
  =cut
  
  eval <<'END_PERL' unless defined &_NONNEGINT;
  sub _NONNEGINT ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^(?:0|[1-9]\d*)$/) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SCALAR \$scalar
  
  The C<_SCALAR> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<SCALAR> reference, with content of non-zero length.
  
  For a version that allows zero length C<SCALAR> references, see
  the C<_SCALAR0> function.
  
  Returns the C<SCALAR> reference itself as a convenience, or C<undef>
  if the value provided is not a C<SCALAR> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SCALAR;
  sub _SCALAR ($) {
  	(ref $_[0] eq 'SCALAR' and defined ${$_[0]} and ${$_[0]} ne '') ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SCALAR0 \$scalar
  
  The C<_SCALAR0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<SCALAR0> reference, allowing content of zero-length.
  
  For a simpler "give me some content" version that requires non-zero
  length, C<_SCALAR> function.
  
  Returns the C<SCALAR> reference itself as a convenience, or C<undef>
  if the value provided is not a C<SCALAR> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SCALAR0;
  sub _SCALAR0 ($) {
  	ref $_[0] eq 'SCALAR' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAY $value
  
  The C<_ARRAY> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<ARRAY> reference containing B<at least> one element of any kind.
  
  For a more basic form that allows zero length ARRAY references, see
  the C<_ARRAY0> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef>
  if the value provided is not an C<ARRAY> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAY;
  sub _ARRAY ($) {
  	(ref $_[0] eq 'ARRAY' and @{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAY0 $value
  
  The C<_ARRAY0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<ARRAY> reference, allowing C<ARRAY> references that contain no
  elements.
  
  For a more basic "An array of something" form that also requires at
  least one element, see the C<_ARRAY> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef>
  if the value provided is not an C<ARRAY> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAY0;
  sub _ARRAY0 ($) {
  	ref $_[0] eq 'ARRAY' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _ARRAYLIKE $value
  
  The C<_ARRAYLIKE> function tests whether a given scalar value can respond to
  array dereferencing.  If it can, the value is returned.  If it cannot,
  C<_ARRAYLIKE> returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_ARRAYLIKE;
  sub _ARRAYLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'ARRAY')
  		or
  		overload::Method($_[0], '@{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASH $value
  
  The C<_HASH> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<HASH> reference with at least one entry.
  
  For a version of this function that allows the C<HASH> to be empty,
  see the C<_HASH0> function.
  
  Returns the C<HASH> reference itself as a convenience, or C<undef>
  if the value provided is not an C<HASH> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASH;
  sub _HASH ($) {
  	(ref $_[0] eq 'HASH' and scalar %{$_[0]}) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASH0 $value
  
  The C<_HASH0> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<HASH> reference, regardless of the C<HASH> content.
  
  For a simpler "A hash of something" version that requires at least one
  element, see the C<_HASH> function.
  
  Returns the C<HASH> reference itself as a convenience, or C<undef>
  if the value provided is not an C<HASH> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASH0;
  sub _HASH0 ($) {
  	ref $_[0] eq 'HASH' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _HASHLIKE $value
  
  The C<_HASHLIKE> function tests whether a given scalar value can respond to
  hash dereferencing.  If it can, the value is returned.  If it cannot,
  C<_HASHLIKE> returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_HASHLIKE;
  sub _HASHLIKE {
  	(defined $_[0] and ref $_[0] and (
  		(Scalar::Util::reftype($_[0]) eq 'HASH')
  		or
  		overload::Method($_[0], '%{}')
  	)) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CODE $value
  
  The C<_CODE> function is intended to be imported into your package,
  and provides a convenient way to test for a raw and unblessed
  C<CODE> reference.
  
  Returns the C<CODE> reference itself as a convenience, or C<undef>
  if the value provided is not an C<CODE> reference.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CODE;
  sub _CODE ($) {
  	ref $_[0] eq 'CODE' ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _CODELIKE $value
  
  The C<_CODELIKE> is the more generic version of C<_CODE>. Unlike C<_CODE>,
  which checks for an explicit C<CODE> reference, the C<_CODELIKE> function
  also includes things that act like them, such as blessed objects that
  overload C<'&{}'>.
  
  Please note that in the case of objects overloaded with '&{}', you will
  almost always end up also testing it in 'bool' context at some stage.
  
  For example:
  
    sub foo {
        my $code1 = _CODELIKE(shift) or die "No code param provided";
        my $code2 = _CODELIKE(shift);
        if ( $code2 ) {
             print "Got optional second code param";
        }
    }
  
  As such, you will most likely always want to make sure your class has
  at least the following to allow it to evaluate to true in boolean
  context.
  
    # Always evaluate to true in boolean context
    use overload 'bool' => sub () { 1 };
  
  Returns the callable value as a convenience, or C<undef> if the
  value provided is not callable.
  
  Note - This function was formerly known as _CALLABLE but has been renamed
  for greater symmetry with the other _XXXXLIKE functions.
  
  The use of _CALLABLE has been deprecated. It will continue to work, but
  with a warning, until end-2006, then will be removed.
  
  I apologise for any inconvenience caused.
  
  =cut
  
  eval <<'END_PERL' unless defined &_CODELIKE;
  sub _CODELIKE($) {
  	(
  		(Scalar::Util::reftype($_[0])||'') eq 'CODE'
  		or
  		Scalar::Util::blessed($_[0]) and overload::Method($_[0],'&{}')
  	)
  	? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _INVOCANT $value
  
  This routine tests whether the given value is a valid method invocant.
  This can be either an instance of an object, or a class name.
  
  If so, the value itself is returned.  Otherwise, C<_INVOCANT>
  returns C<undef>.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INVOCANT;
  sub _INVOCANT($) {
  	(defined $_[0] and
  		(defined Scalar::Util::blessed($_[0])
  		or      
  		# We used to check for stash definedness, but any class-like name is a
  		# valid invocant for UNIVERSAL methods, so we stopped. -- rjbs, 2006-07-02
  		Params::Util::_CLASS($_[0]))
  	) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _INSTANCE $object, $class
  
  The C<_INSTANCE> function is intended to be imported into your package,
  and provides a convenient way to test for an object of a particular class
  in a strictly correct manner.
  
  Returns the object itself as a convenience, or C<undef> if the value
  provided is not an object of that type.
  
  =cut
  
  eval <<'END_PERL' unless defined &_INSTANCE;
  sub _INSTANCE ($$) {
  	(Scalar::Util::blessed($_[0]) and $_[0]->isa($_[1])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _REGEX $value
  
  The C<_REGEX> function is intended to be imported into your package,
  and provides a convenient way to test for a regular expression.
  
  Returns the value itself as a convenience, or C<undef> if the value
  provided is not a regular expression.
  
  =cut
  
  eval <<'END_PERL' unless defined &_REGEX;
  sub _REGEX ($) {
  	(defined $_[0] and 'Regexp' eq ref($_[0])) ? $_[0] : undef;
  }
  END_PERL
  
  =pod
  
  =head2 _SET \@array, $class
  
  The C<_SET> function is intended to be imported into your package,
  and provides a convenient way to test for set of at least one object of
  a particular class in a strictly correct manner.
  
  The set is provided as a reference to an C<ARRAY> of objects of the
  class provided.
  
  For an alternative function that allows zero-length sets, see the
  C<_SET0> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef> if
  the value provided is not a set of that class.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SET;
  sub _SET ($$) {
  	my $set = shift;
  	_ARRAY($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  
  =pod
  
  =head2 _SET0 \@array, $class
  
  The C<_SET0> function is intended to be imported into your package,
  and provides a convenient way to test for a set of objects of a
  particular class in a strictly correct manner, allowing for zero objects.
  
  The set is provided as a reference to an C<ARRAY> of objects of the
  class provided.
  
  For an alternative function that requires at least one object, see the
  C<_SET> function.
  
  Returns the C<ARRAY> reference itself as a convenience, or C<undef> if
  the value provided is not a set of that class.
  
  =cut
  
  eval <<'END_PERL' unless defined &_SET0;
  sub _SET0 ($$) {
  	my $set = shift;
  	_ARRAY0($set) or return undef;
  	foreach my $item ( @$set ) {
  		_INSTANCE($item,$_[0]) or return undef;
  	}
  	$set;
  }
  END_PERL
  
  =pod
  
  =head2 _HANDLE
  
  The C<_HANDLE> function is intended to be imported into your package,
  and provides a convenient way to test whether or not a single scalar
  value is a file handle.
  
  Unfortunately, in Perl the definition of a file handle can be a little
  bit fuzzy, so this function is likely to be somewhat imperfect (at first
  anyway).
  
  That said, it is implement as well or better than the other file handle
  detectors in existance (and we stole from the best of them).
  
  =cut
  
  # We're doing this longhand for now. Once everything is perfect,
  # we'll compress this into something that compiles more efficiently.
  # Further, testing file handles is not something that is generally
  # done millions of times, so doing it slowly is not a big speed hit.
  eval <<'END_PERL' unless defined &_HANDLE;
  sub _HANDLE {
  	my $it = shift;
  
  	# It has to be defined, of course
  	unless ( defined $it ) {
  		return undef;
  	}
  
  	# Normal globs are considered to be file handles
  	if ( ref $it eq 'GLOB' ) {
  		return $it;
  	}
  
  	# Check for a normal tied filehandle
  	# Side Note: 5.5.4's tied() and can() doesn't like getting undef
  	if ( tied($it) and tied($it)->can('TIEHANDLE') ) {
  		return $it;
  	}
  
  	# There are no other non-object handles that we support
  	unless ( Scalar::Util::blessed($it) ) {
  		return undef;
  	}
  
  	# Check for a common base classes for conventional IO::Handle object
  	if ( $it->isa('IO::Handle') ) {
  		return $it;
  	}
  
  
  	# Check for tied file handles using Tie::Handle
  	if ( $it->isa('Tie::Handle') ) {
  		return $it;
  	}
  
  	# IO::Scalar is not a proper seekable, but it is valid is a
  	# regular file handle
  	if ( $it->isa('IO::Scalar') ) {
  		return $it;
  	}
  
  	# Yet another special case for IO::String, which refuses (for now
  	# anyway) to become a subclass of IO::Handle.
  	if ( $it->isa('IO::String') ) {
  		return $it;
  	}
  
  	# This is not any sort of object we know about
  	return undef;
  }
  END_PERL
  
  =pod
  
  =head2 _DRIVER $string
  
    sub foo {
      my $class = _DRIVER(shift, 'My::Driver::Base') or die "Bad driver";
      ...
    }
  
  The C<_DRIVER> function is intended to be imported into your
  package, and provides a convenient way to load and validate
  a driver class.
  
  The most common pattern when taking a driver class as a parameter
  is to check that the name is a class (i.e. check against _CLASS)
  and then to load the class (if it exists) and then ensure that
  the class returns true for the isa method on some base driver name.
  
  Return the value as a convenience, or C<undef> if the value is not
  a class name, the module does not exist, the module does not load,
  or the class fails the isa test.
  
  =cut
  
  eval <<'END_PERL' unless defined &_DRIVER;
  sub _DRIVER ($$) {
  	(defined _CLASS($_[0]) and eval "require $_[0];" and ! $@ and $_[0]->isa($_[1]) and $_[0] ne $_[1]) ? $_[0] : undef;
  }
  END_PERL
  
  1;
  
  =pod
  
  =head1 TO DO
  
  - Add _CAN to help resolve the UNIVERSAL::can debacle
  
  - Would be even nicer if someone would demonstrate how the hell to
  build a Module::Install dist of the ::Util dual Perl/XS type. :/
  
  - Implement an assertion-like version of this module, that dies on
  error.
  
  - Implement a Test:: version of this module, for use in testing
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker at
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Params-Util>
  
  For other issues, contact the author.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<Params::Validate>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2010 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
I686-LINUX-GNU-THREAD-MULTI_PARAMS_UTIL

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    open my $fh, '<', \$fat
      or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
    return $fh;
  }
  return
};

} # END OF FATPACK CODE
#!/usr/bin/perl

use FindBin qw/$Bin/;
use lib "$Bin/../lib";

use App::Mist;
App::Mist->run;
